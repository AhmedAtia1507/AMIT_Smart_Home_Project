
Final_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000260e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000724  00800060  0000260e  000026a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000026  00800784  00800784  00002dc6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002dc6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002df8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004a8  00000000  00000000  00002e34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000559e  00000000  00000000  000032dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001361  00000000  00000000  0000887a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e48  00000000  00000000  00009bdb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d1c  00000000  00000000  0000ca24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000013b3  00000000  00000000  0000d740  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002e7b  00000000  00000000  0000eaf3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000428  00000000  00000000  0001196e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 37 00 	jmp	0x6e	; 0x6e <__ctors_end>
       4:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
       8:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
       c:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      10:	0c 94 90 0e 	jmp	0x1d20	; 0x1d20 <__vector_4>
      14:	0c 94 b9 0e 	jmp	0x1d72	; 0x1d72 <__vector_5>
      18:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      1c:	0c 94 df 0d 	jmp	0x1bbe	; 0x1bbe <__vector_7>
      20:	0c 94 08 0e 	jmp	0x1c10	; 0x1c10 <__vector_8>
      24:	0c 94 31 0e 	jmp	0x1c62	; 0x1c62 <__vector_9>
      28:	0c 94 0e 0d 	jmp	0x1a1c	; 0x1a1c <__vector_10>
      2c:	0c 94 37 0d 	jmp	0x1a6e	; 0x1a6e <__vector_11>
      30:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      34:	0c 94 24 0f 	jmp	0x1e48	; 0x1e48 <__vector_13>
      38:	0c 94 4d 0f 	jmp	0x1e9a	; 0x1e9a <__vector_14>
      3c:	0c 94 76 0f 	jmp	0x1eec	; 0x1eec <__vector_15>
      40:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__vector_16>
      44:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      48:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      4c:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      50:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      54:	b4 05       	cpc	r27, r4
      56:	e9 05       	cpc	r30, r9
      58:	fc 05       	cpc	r31, r12
      5a:	5c 06       	cpc	r5, r28
      5c:	28 07       	cpc	r18, r24
      5e:	81 07       	cpc	r24, r17
      60:	e6 08       	sbc	r14, r6
      62:	de 06       	cpc	r13, r30
      64:	7d 08       	sbc	r7, r13
      66:	90 08       	sbc	r9, r0
      68:	b8 08       	sbc	r11, r8
      6a:	e6 08       	sbc	r14, r6
      6c:	cb 08       	sbc	r12, r11

0000006e <__ctors_end>:
      6e:	11 24       	eor	r1, r1
      70:	1f be       	out	0x3f, r1	; 63
      72:	cf e5       	ldi	r28, 0x5F	; 95
      74:	d8 e0       	ldi	r29, 0x08	; 8
      76:	de bf       	out	0x3e, r29	; 62
      78:	cd bf       	out	0x3d, r28	; 61

0000007a <__do_copy_data>:
      7a:	17 e0       	ldi	r17, 0x07	; 7
      7c:	a0 e6       	ldi	r26, 0x60	; 96
      7e:	b0 e0       	ldi	r27, 0x00	; 0
      80:	ee e0       	ldi	r30, 0x0E	; 14
      82:	f6 e2       	ldi	r31, 0x26	; 38
      84:	02 c0       	rjmp	.+4      	; 0x8a <__do_copy_data+0x10>
      86:	05 90       	lpm	r0, Z+
      88:	0d 92       	st	X+, r0
      8a:	a4 38       	cpi	r26, 0x84	; 132
      8c:	b1 07       	cpc	r27, r17
      8e:	d9 f7       	brne	.-10     	; 0x86 <__do_copy_data+0xc>

00000090 <__do_clear_bss>:
      90:	27 e0       	ldi	r18, 0x07	; 7
      92:	a4 e8       	ldi	r26, 0x84	; 132
      94:	b7 e0       	ldi	r27, 0x07	; 7
      96:	01 c0       	rjmp	.+2      	; 0x9a <.do_clear_bss_start>

00000098 <.do_clear_bss_loop>:
      98:	1d 92       	st	X+, r1

0000009a <.do_clear_bss_start>:
      9a:	aa 3a       	cpi	r26, 0xAA	; 170
      9c:	b2 07       	cpc	r27, r18
      9e:	e1 f7       	brne	.-8      	; 0x98 <.do_clear_bss_loop>
      a0:	0e 94 13 0c 	call	0x1826	; 0x1826 <main>
      a4:	0c 94 05 13 	jmp	0x260a	; 0x260a <_exit>

000000a8 <__bad_interrupt>:
      a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ac <ADC_Init>:

            //Clear ADC Flag
            SET_BIT(ADCSRA,ADIF);

            //Read Digital Value
            *P_u16DigitalValue = ADC_u16;
      ac:	87 b1       	in	r24, 0x07	; 7
      ae:	80 64       	ori	r24, 0x40	; 64
      b0:	87 b9       	out	0x07, r24	; 7
      b2:	87 b1       	in	r24, 0x07	; 7
      b4:	80 68       	ori	r24, 0x80	; 128
      b6:	87 b9       	out	0x07, r24	; 7
      b8:	87 b1       	in	r24, 0x07	; 7
      ba:	8f 7d       	andi	r24, 0xDF	; 223
      bc:	87 b9       	out	0x07, r24	; 7
      be:	86 b1       	in	r24, 0x06	; 6
      c0:	88 60       	ori	r24, 0x08	; 8
      c2:	86 b9       	out	0x06, r24	; 6
      c4:	86 b1       	in	r24, 0x06	; 6
      c6:	8f 7d       	andi	r24, 0xDF	; 223
      c8:	86 b9       	out	0x06, r24	; 6
      ca:	86 b1       	in	r24, 0x06	; 6
      cc:	8e 7f       	andi	r24, 0xFE	; 254
      ce:	86 b9       	out	0x06, r24	; 6
      d0:	86 b1       	in	r24, 0x06	; 6
      d2:	82 60       	ori	r24, 0x02	; 2
      d4:	86 b9       	out	0x06, r24	; 6
      d6:	86 b1       	in	r24, 0x06	; 6
      d8:	84 60       	ori	r24, 0x04	; 4
      da:	86 b9       	out	0x06, r24	; 6
      dc:	86 b1       	in	r24, 0x06	; 6
      de:	80 68       	ori	r24, 0x80	; 128
      e0:	86 b9       	out	0x06, r24	; 6
      e2:	08 95       	ret

000000e4 <ADC_StartConversion>:
 * 
 * @param Copy_u8ChannelNumber: Channel Number to which the analog signal is connected to
 */
void ADC_StartConversion(u8 Copy_u8ChannelNumber)
{
    if(Copy_u8ChannelNumber >= ADC_CHANNEL_0 && Copy_u8ChannelNumber <= ADC_CHANNEL_7)
      e4:	88 30       	cpi	r24, 0x08	; 8
      e6:	48 f4       	brcc	.+18     	; 0xfa <ADC_StartConversion+0x16>
    {
        //clear the first 5 bits of the ADMUX register
        ADMUX &= 0b11100000; 
      e8:	97 b1       	in	r25, 0x07	; 7
      ea:	90 7e       	andi	r25, 0xE0	; 224
      ec:	97 b9       	out	0x07, r25	; 7
        //Set the values of the first 5 bits as the channel number
        ADMUX |= Copy_u8ChannelNumber; 
      ee:	97 b1       	in	r25, 0x07	; 7
      f0:	89 2b       	or	r24, r25
      f2:	87 b9       	out	0x07, r24	; 7
        //Start Conversion
        SET_BIT(ADCSRA, ADSC);
      f4:	86 b1       	in	r24, 0x06	; 6
      f6:	80 64       	ori	r24, 0x40	; 64
      f8:	86 b9       	out	0x06, r24	; 6
      fa:	08 95       	ret

000000fc <ADC_ConversionCompleteSetCallback>:
 * 
 * @param P_CallbackFunction 
 */
void ADC_ConversionCompleteSetCallback(ptr_to_func_t P_CallbackFunction)
{
    if(P_CallbackFunction != NULL)
      fc:	00 97       	sbiw	r24, 0x00	; 0
      fe:	21 f0       	breq	.+8      	; 0x108 <ADC_ConversionCompleteSetCallback+0xc>
    {
        ADC_ConversionComplete_PCallback = P_CallbackFunction;
     100:	90 93 85 07 	sts	0x0785, r25	; 0x800785 <__data_end+0x1>
     104:	80 93 84 07 	sts	0x0784, r24	; 0x800784 <__data_end>
     108:	08 95       	ret

0000010a <ADC_GetDigitalValueAsynchronous>:
 * 
 * @param P_u16DigitalValue: Digital Value
 */
void ADC_GetDigitalValueAsynchronous(u16* P_u16DigitalValue)
{
    if(P_u16DigitalValue != NULL)
     10a:	00 97       	sbiw	r24, 0x00	; 0
     10c:	29 f0       	breq	.+10     	; 0x118 <ADC_GetDigitalValueAsynchronous+0xe>
    {
        *P_u16DigitalValue = ADC_u16;
     10e:	24 b1       	in	r18, 0x04	; 4
     110:	35 b1       	in	r19, 0x05	; 5
     112:	fc 01       	movw	r30, r24
     114:	31 83       	std	Z+1, r19	; 0x01
     116:	20 83       	st	Z, r18
     118:	08 95       	ret

0000011a <__vector_16>:
    }
}
//ISR Function prototype for ADC Conversion Complete
void __vector_16(void) __attribute__ ((signal));
void __vector_16(void)
{
     11a:	1f 92       	push	r1
     11c:	0f 92       	push	r0
     11e:	0f b6       	in	r0, 0x3f	; 63
     120:	0f 92       	push	r0
     122:	11 24       	eor	r1, r1
     124:	2f 93       	push	r18
     126:	3f 93       	push	r19
     128:	4f 93       	push	r20
     12a:	5f 93       	push	r21
     12c:	6f 93       	push	r22
     12e:	7f 93       	push	r23
     130:	8f 93       	push	r24
     132:	9f 93       	push	r25
     134:	af 93       	push	r26
     136:	bf 93       	push	r27
     138:	ef 93       	push	r30
     13a:	ff 93       	push	r31
    if(ADC_ConversionComplete_PCallback != NULL)
     13c:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <__data_end>
     140:	90 91 85 07 	lds	r25, 0x0785	; 0x800785 <__data_end+0x1>
     144:	89 2b       	or	r24, r25
     146:	41 f0       	breq	.+16     	; 0x158 <__vector_16+0x3e>
    {
        //Clear ADC Flag
        SET_BIT(ADCSRA,ADIF);
     148:	86 b1       	in	r24, 0x06	; 6
     14a:	80 61       	ori	r24, 0x10	; 16
     14c:	86 b9       	out	0x06, r24	; 6
        ADC_ConversionComplete_PCallback();
     14e:	e0 91 84 07 	lds	r30, 0x0784	; 0x800784 <__data_end>
     152:	f0 91 85 07 	lds	r31, 0x0785	; 0x800785 <__data_end+0x1>
     156:	09 95       	icall
    else
    {
        /*Do nothing*/
    }
    //Clear ADC Flag
    SET_BIT(ADCSRA,ADIF);
     158:	86 b1       	in	r24, 0x06	; 6
     15a:	80 61       	ori	r24, 0x10	; 16
     15c:	86 b9       	out	0x06, r24	; 6
     15e:	ff 91       	pop	r31
     160:	ef 91       	pop	r30
     162:	bf 91       	pop	r27
     164:	af 91       	pop	r26
     166:	9f 91       	pop	r25
     168:	8f 91       	pop	r24
     16a:	7f 91       	pop	r23
     16c:	6f 91       	pop	r22
     16e:	5f 91       	pop	r21
     170:	4f 91       	pop	r20
     172:	3f 91       	pop	r19
     174:	2f 91       	pop	r18
     176:	0f 90       	pop	r0
     178:	0f be       	out	0x3f, r0	; 63
     17a:	0f 90       	pop	r0
     17c:	1f 90       	pop	r1
     17e:	18 95       	reti

00000180 <BUZZER_Init>:
 * @brief: Function to initialize the Buzzer Peripheral
 * 
 */
void BUZZER_Init(void)
{
    DIO_SetPinDirection(BUZZER_PORT_ID, BUZZER_PIN_ID, DIO_PIN_OUTPUT);
     180:	41 e0       	ldi	r20, 0x01	; 1
     182:	63 e0       	ldi	r22, 0x03	; 3
     184:	80 e0       	ldi	r24, 0x00	; 0
     186:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
     18a:	08 95       	ret

0000018c <BUZZER_On>:
 * @brief: Function to turn on the Buzzer Peripheral
 * 
 */
void BUZZER_On(void)
{
    DIO_SetPinValue(BUZZER_PORT_ID, BUZZER_PIN_ID, DIO_PIN_HIGH);
     18c:	41 e0       	ldi	r20, 0x01	; 1
     18e:	63 e0       	ldi	r22, 0x03	; 3
     190:	80 e0       	ldi	r24, 0x00	; 0
     192:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
     196:	08 95       	ret

00000198 <BUZZER_Off>:
 * @brief: Function to turn off the Buzzer Peripheral
 * 
 */
void BUZZER_Off(void)
{
    DIO_SetPinValue(BUZZER_PORT_ID, BUZZER_PIN_ID, DIO_PIN_LOW);
     198:	40 e0       	ldi	r20, 0x00	; 0
     19a:	63 e0       	ldi	r22, 0x03	; 3
     19c:	80 e0       	ldi	r24, 0x00	; 0
     19e:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
     1a2:	08 95       	ret

000001a4 <DIO_SetPinDirection>:
					*P_u8PortValue = PINC;
					break;
				}
				case DIO_PORTD:
				{
					*P_u8PortValue = PIND;
     1a4:	84 30       	cpi	r24, 0x04	; 4
     1a6:	08 f0       	brcs	.+2      	; 0x1aa <DIO_SetPinDirection+0x6>
     1a8:	77 c0       	rjmp	.+238    	; 0x298 <DIO_SetPinDirection+0xf4>
     1aa:	68 30       	cpi	r22, 0x08	; 8
     1ac:	08 f0       	brcs	.+2      	; 0x1b0 <DIO_SetPinDirection+0xc>
     1ae:	74 c0       	rjmp	.+232    	; 0x298 <DIO_SetPinDirection+0xf4>
     1b0:	81 30       	cpi	r24, 0x01	; 1
     1b2:	11 f1       	breq	.+68     	; 0x1f8 <DIO_SetPinDirection+0x54>
     1b4:	30 f0       	brcs	.+12     	; 0x1c2 <DIO_SetPinDirection+0x1e>
     1b6:	82 30       	cpi	r24, 0x02	; 2
     1b8:	d1 f1       	breq	.+116    	; 0x22e <DIO_SetPinDirection+0x8a>
     1ba:	83 30       	cpi	r24, 0x03	; 3
     1bc:	09 f4       	brne	.+2      	; 0x1c0 <DIO_SetPinDirection+0x1c>
     1be:	52 c0       	rjmp	.+164    	; 0x264 <DIO_SetPinDirection+0xc0>
     1c0:	08 95       	ret
     1c2:	41 30       	cpi	r20, 0x01	; 1
     1c4:	59 f4       	brne	.+22     	; 0x1dc <DIO_SetPinDirection+0x38>
     1c6:	2a b3       	in	r18, 0x1a	; 26
     1c8:	81 e0       	ldi	r24, 0x01	; 1
     1ca:	90 e0       	ldi	r25, 0x00	; 0
     1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <DIO_SetPinDirection+0x2e>
     1ce:	88 0f       	add	r24, r24
     1d0:	99 1f       	adc	r25, r25
     1d2:	6a 95       	dec	r22
     1d4:	e2 f7       	brpl	.-8      	; 0x1ce <DIO_SetPinDirection+0x2a>
     1d6:	82 2b       	or	r24, r18
     1d8:	8a bb       	out	0x1a, r24	; 26
     1da:	08 95       	ret
     1dc:	41 11       	cpse	r20, r1
     1de:	5c c0       	rjmp	.+184    	; 0x298 <DIO_SetPinDirection+0xf4>
     1e0:	2a b3       	in	r18, 0x1a	; 26
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	02 c0       	rjmp	.+4      	; 0x1ec <DIO_SetPinDirection+0x48>
     1e8:	88 0f       	add	r24, r24
     1ea:	99 1f       	adc	r25, r25
     1ec:	6a 95       	dec	r22
     1ee:	e2 f7       	brpl	.-8      	; 0x1e8 <DIO_SetPinDirection+0x44>
     1f0:	80 95       	com	r24
     1f2:	82 23       	and	r24, r18
     1f4:	8a bb       	out	0x1a, r24	; 26
     1f6:	08 95       	ret
     1f8:	41 30       	cpi	r20, 0x01	; 1
     1fa:	59 f4       	brne	.+22     	; 0x212 <DIO_SetPinDirection+0x6e>
     1fc:	27 b3       	in	r18, 0x17	; 23
     1fe:	81 e0       	ldi	r24, 0x01	; 1
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	02 c0       	rjmp	.+4      	; 0x208 <DIO_SetPinDirection+0x64>
     204:	88 0f       	add	r24, r24
     206:	99 1f       	adc	r25, r25
     208:	6a 95       	dec	r22
     20a:	e2 f7       	brpl	.-8      	; 0x204 <DIO_SetPinDirection+0x60>
     20c:	82 2b       	or	r24, r18
     20e:	87 bb       	out	0x17, r24	; 23
     210:	08 95       	ret
     212:	41 11       	cpse	r20, r1
     214:	41 c0       	rjmp	.+130    	; 0x298 <DIO_SetPinDirection+0xf4>
     216:	27 b3       	in	r18, 0x17	; 23
     218:	81 e0       	ldi	r24, 0x01	; 1
     21a:	90 e0       	ldi	r25, 0x00	; 0
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_SetPinDirection+0x7e>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	6a 95       	dec	r22
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_SetPinDirection+0x7a>
     226:	80 95       	com	r24
     228:	82 23       	and	r24, r18
     22a:	87 bb       	out	0x17, r24	; 23
     22c:	08 95       	ret
     22e:	41 30       	cpi	r20, 0x01	; 1
     230:	59 f4       	brne	.+22     	; 0x248 <DIO_SetPinDirection+0xa4>
     232:	24 b3       	in	r18, 0x14	; 20
     234:	81 e0       	ldi	r24, 0x01	; 1
     236:	90 e0       	ldi	r25, 0x00	; 0
     238:	02 c0       	rjmp	.+4      	; 0x23e <DIO_SetPinDirection+0x9a>
     23a:	88 0f       	add	r24, r24
     23c:	99 1f       	adc	r25, r25
     23e:	6a 95       	dec	r22
     240:	e2 f7       	brpl	.-8      	; 0x23a <DIO_SetPinDirection+0x96>
     242:	82 2b       	or	r24, r18
     244:	84 bb       	out	0x14, r24	; 20
     246:	08 95       	ret
     248:	41 11       	cpse	r20, r1
     24a:	26 c0       	rjmp	.+76     	; 0x298 <DIO_SetPinDirection+0xf4>
     24c:	24 b3       	in	r18, 0x14	; 20
     24e:	81 e0       	ldi	r24, 0x01	; 1
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	02 c0       	rjmp	.+4      	; 0x258 <DIO_SetPinDirection+0xb4>
     254:	88 0f       	add	r24, r24
     256:	99 1f       	adc	r25, r25
     258:	6a 95       	dec	r22
     25a:	e2 f7       	brpl	.-8      	; 0x254 <DIO_SetPinDirection+0xb0>
     25c:	80 95       	com	r24
     25e:	82 23       	and	r24, r18
     260:	84 bb       	out	0x14, r24	; 20
     262:	08 95       	ret
     264:	41 30       	cpi	r20, 0x01	; 1
     266:	59 f4       	brne	.+22     	; 0x27e <DIO_SetPinDirection+0xda>
     268:	21 b3       	in	r18, 0x11	; 17
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	02 c0       	rjmp	.+4      	; 0x274 <DIO_SetPinDirection+0xd0>
     270:	88 0f       	add	r24, r24
     272:	99 1f       	adc	r25, r25
     274:	6a 95       	dec	r22
     276:	e2 f7       	brpl	.-8      	; 0x270 <DIO_SetPinDirection+0xcc>
     278:	82 2b       	or	r24, r18
     27a:	81 bb       	out	0x11, r24	; 17
     27c:	08 95       	ret
     27e:	41 11       	cpse	r20, r1
     280:	0b c0       	rjmp	.+22     	; 0x298 <DIO_SetPinDirection+0xf4>
     282:	21 b3       	in	r18, 0x11	; 17
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	02 c0       	rjmp	.+4      	; 0x28e <DIO_SetPinDirection+0xea>
     28a:	88 0f       	add	r24, r24
     28c:	99 1f       	adc	r25, r25
     28e:	6a 95       	dec	r22
     290:	e2 f7       	brpl	.-8      	; 0x28a <DIO_SetPinDirection+0xe6>
     292:	80 95       	com	r24
     294:	82 23       	and	r24, r18
     296:	81 bb       	out	0x11, r24	; 17
     298:	08 95       	ret

0000029a <DIO_SetPinValue>:
     29a:	84 30       	cpi	r24, 0x04	; 4
     29c:	08 f0       	brcs	.+2      	; 0x2a0 <DIO_SetPinValue+0x6>
     29e:	77 c0       	rjmp	.+238    	; 0x38e <DIO_SetPinValue+0xf4>
     2a0:	68 30       	cpi	r22, 0x08	; 8
     2a2:	08 f0       	brcs	.+2      	; 0x2a6 <DIO_SetPinValue+0xc>
     2a4:	74 c0       	rjmp	.+232    	; 0x38e <DIO_SetPinValue+0xf4>
     2a6:	81 30       	cpi	r24, 0x01	; 1
     2a8:	11 f1       	breq	.+68     	; 0x2ee <DIO_SetPinValue+0x54>
     2aa:	30 f0       	brcs	.+12     	; 0x2b8 <DIO_SetPinValue+0x1e>
     2ac:	82 30       	cpi	r24, 0x02	; 2
     2ae:	d1 f1       	breq	.+116    	; 0x324 <DIO_SetPinValue+0x8a>
     2b0:	83 30       	cpi	r24, 0x03	; 3
     2b2:	09 f4       	brne	.+2      	; 0x2b6 <DIO_SetPinValue+0x1c>
     2b4:	52 c0       	rjmp	.+164    	; 0x35a <DIO_SetPinValue+0xc0>
     2b6:	08 95       	ret
     2b8:	41 30       	cpi	r20, 0x01	; 1
     2ba:	59 f4       	brne	.+22     	; 0x2d2 <DIO_SetPinValue+0x38>
     2bc:	2b b3       	in	r18, 0x1b	; 27
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	90 e0       	ldi	r25, 0x00	; 0
     2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <DIO_SetPinValue+0x2e>
     2c4:	88 0f       	add	r24, r24
     2c6:	99 1f       	adc	r25, r25
     2c8:	6a 95       	dec	r22
     2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <DIO_SetPinValue+0x2a>
     2cc:	82 2b       	or	r24, r18
     2ce:	8b bb       	out	0x1b, r24	; 27
     2d0:	08 95       	ret
     2d2:	41 11       	cpse	r20, r1
     2d4:	5c c0       	rjmp	.+184    	; 0x38e <DIO_SetPinValue+0xf4>
     2d6:	2b b3       	in	r18, 0x1b	; 27
     2d8:	81 e0       	ldi	r24, 0x01	; 1
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	02 c0       	rjmp	.+4      	; 0x2e2 <DIO_SetPinValue+0x48>
     2de:	88 0f       	add	r24, r24
     2e0:	99 1f       	adc	r25, r25
     2e2:	6a 95       	dec	r22
     2e4:	e2 f7       	brpl	.-8      	; 0x2de <DIO_SetPinValue+0x44>
     2e6:	80 95       	com	r24
     2e8:	82 23       	and	r24, r18
     2ea:	8b bb       	out	0x1b, r24	; 27
     2ec:	08 95       	ret
     2ee:	41 30       	cpi	r20, 0x01	; 1
     2f0:	59 f4       	brne	.+22     	; 0x308 <DIO_SetPinValue+0x6e>
     2f2:	28 b3       	in	r18, 0x18	; 24
     2f4:	81 e0       	ldi	r24, 0x01	; 1
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <DIO_SetPinValue+0x64>
     2fa:	88 0f       	add	r24, r24
     2fc:	99 1f       	adc	r25, r25
     2fe:	6a 95       	dec	r22
     300:	e2 f7       	brpl	.-8      	; 0x2fa <DIO_SetPinValue+0x60>
     302:	82 2b       	or	r24, r18
     304:	88 bb       	out	0x18, r24	; 24
     306:	08 95       	ret
     308:	41 11       	cpse	r20, r1
     30a:	41 c0       	rjmp	.+130    	; 0x38e <DIO_SetPinValue+0xf4>
     30c:	28 b3       	in	r18, 0x18	; 24
     30e:	81 e0       	ldi	r24, 0x01	; 1
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	02 c0       	rjmp	.+4      	; 0x318 <DIO_SetPinValue+0x7e>
     314:	88 0f       	add	r24, r24
     316:	99 1f       	adc	r25, r25
     318:	6a 95       	dec	r22
     31a:	e2 f7       	brpl	.-8      	; 0x314 <DIO_SetPinValue+0x7a>
     31c:	80 95       	com	r24
     31e:	82 23       	and	r24, r18
     320:	88 bb       	out	0x18, r24	; 24
     322:	08 95       	ret
     324:	41 30       	cpi	r20, 0x01	; 1
     326:	59 f4       	brne	.+22     	; 0x33e <DIO_SetPinValue+0xa4>
     328:	25 b3       	in	r18, 0x15	; 21
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	02 c0       	rjmp	.+4      	; 0x334 <DIO_SetPinValue+0x9a>
     330:	88 0f       	add	r24, r24
     332:	99 1f       	adc	r25, r25
     334:	6a 95       	dec	r22
     336:	e2 f7       	brpl	.-8      	; 0x330 <DIO_SetPinValue+0x96>
     338:	82 2b       	or	r24, r18
     33a:	85 bb       	out	0x15, r24	; 21
     33c:	08 95       	ret
     33e:	41 11       	cpse	r20, r1
     340:	26 c0       	rjmp	.+76     	; 0x38e <DIO_SetPinValue+0xf4>
     342:	25 b3       	in	r18, 0x15	; 21
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	02 c0       	rjmp	.+4      	; 0x34e <DIO_SetPinValue+0xb4>
     34a:	88 0f       	add	r24, r24
     34c:	99 1f       	adc	r25, r25
     34e:	6a 95       	dec	r22
     350:	e2 f7       	brpl	.-8      	; 0x34a <DIO_SetPinValue+0xb0>
     352:	80 95       	com	r24
     354:	82 23       	and	r24, r18
     356:	85 bb       	out	0x15, r24	; 21
     358:	08 95       	ret
     35a:	41 30       	cpi	r20, 0x01	; 1
     35c:	59 f4       	brne	.+22     	; 0x374 <DIO_SetPinValue+0xda>
     35e:	22 b3       	in	r18, 0x12	; 18
     360:	81 e0       	ldi	r24, 0x01	; 1
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	02 c0       	rjmp	.+4      	; 0x36a <DIO_SetPinValue+0xd0>
     366:	88 0f       	add	r24, r24
     368:	99 1f       	adc	r25, r25
     36a:	6a 95       	dec	r22
     36c:	e2 f7       	brpl	.-8      	; 0x366 <DIO_SetPinValue+0xcc>
     36e:	82 2b       	or	r24, r18
     370:	82 bb       	out	0x12, r24	; 18
     372:	08 95       	ret
     374:	41 11       	cpse	r20, r1
     376:	0b c0       	rjmp	.+22     	; 0x38e <DIO_SetPinValue+0xf4>
     378:	22 b3       	in	r18, 0x12	; 18
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	90 e0       	ldi	r25, 0x00	; 0
     37e:	02 c0       	rjmp	.+4      	; 0x384 <DIO_SetPinValue+0xea>
     380:	88 0f       	add	r24, r24
     382:	99 1f       	adc	r25, r25
     384:	6a 95       	dec	r22
     386:	e2 f7       	brpl	.-8      	; 0x380 <DIO_SetPinValue+0xe6>
     388:	80 95       	com	r24
     38a:	82 23       	and	r24, r18
     38c:	82 bb       	out	0x12, r24	; 18
     38e:	08 95       	ret

00000390 <DIO_ReadPinValue>:
     390:	41 15       	cp	r20, r1
     392:	51 05       	cpc	r21, r1
     394:	09 f4       	brne	.+2      	; 0x398 <DIO_ReadPinValue+0x8>
     396:	76 c0       	rjmp	.+236    	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
     398:	84 30       	cpi	r24, 0x04	; 4
     39a:	08 f0       	brcs	.+2      	; 0x39e <DIO_ReadPinValue+0xe>
     39c:	73 c0       	rjmp	.+230    	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
     39e:	68 30       	cpi	r22, 0x08	; 8
     3a0:	08 f0       	brcs	.+2      	; 0x3a4 <DIO_ReadPinValue+0x14>
     3a2:	70 c0       	rjmp	.+224    	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
     3a4:	81 30       	cpi	r24, 0x01	; 1
     3a6:	09 f1       	breq	.+66     	; 0x3ea <DIO_ReadPinValue+0x5a>
     3a8:	30 f0       	brcs	.+12     	; 0x3b6 <DIO_ReadPinValue+0x26>
     3aa:	82 30       	cpi	r24, 0x02	; 2
     3ac:	c1 f1       	breq	.+112    	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
     3ae:	83 30       	cpi	r24, 0x03	; 3
     3b0:	09 f4       	brne	.+2      	; 0x3b4 <DIO_ReadPinValue+0x24>
     3b2:	4f c0       	rjmp	.+158    	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
     3b4:	08 95       	ret
     3b6:	89 b3       	in	r24, 0x19	; 25
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	06 2e       	mov	r0, r22
     3bc:	02 c0       	rjmp	.+4      	; 0x3c2 <DIO_ReadPinValue+0x32>
     3be:	95 95       	asr	r25
     3c0:	87 95       	ror	r24
     3c2:	0a 94       	dec	r0
     3c4:	e2 f7       	brpl	.-8      	; 0x3be <DIO_ReadPinValue+0x2e>
     3c6:	80 ff       	sbrs	r24, 0
     3c8:	04 c0       	rjmp	.+8      	; 0x3d2 <DIO_ReadPinValue+0x42>
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	fa 01       	movw	r30, r20
     3ce:	80 83       	st	Z, r24
     3d0:	08 95       	ret
     3d2:	89 b3       	in	r24, 0x19	; 25
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	02 c0       	rjmp	.+4      	; 0x3dc <DIO_ReadPinValue+0x4c>
     3d8:	95 95       	asr	r25
     3da:	87 95       	ror	r24
     3dc:	6a 95       	dec	r22
     3de:	e2 f7       	brpl	.-8      	; 0x3d8 <DIO_ReadPinValue+0x48>
     3e0:	80 fd       	sbrc	r24, 0
     3e2:	50 c0       	rjmp	.+160    	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
     3e4:	fa 01       	movw	r30, r20
     3e6:	10 82       	st	Z, r1
     3e8:	08 95       	ret
     3ea:	86 b3       	in	r24, 0x16	; 22
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	06 2e       	mov	r0, r22
     3f0:	02 c0       	rjmp	.+4      	; 0x3f6 <DIO_ReadPinValue+0x66>
     3f2:	95 95       	asr	r25
     3f4:	87 95       	ror	r24
     3f6:	0a 94       	dec	r0
     3f8:	e2 f7       	brpl	.-8      	; 0x3f2 <DIO_ReadPinValue+0x62>
     3fa:	80 ff       	sbrs	r24, 0
     3fc:	04 c0       	rjmp	.+8      	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
     3fe:	81 e0       	ldi	r24, 0x01	; 1
     400:	fa 01       	movw	r30, r20
     402:	80 83       	st	Z, r24
     404:	08 95       	ret
     406:	86 b3       	in	r24, 0x16	; 22
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	02 c0       	rjmp	.+4      	; 0x410 <__EEPROM_REGION_LENGTH__+0x10>
     40c:	95 95       	asr	r25
     40e:	87 95       	ror	r24
     410:	6a 95       	dec	r22
     412:	e2 f7       	brpl	.-8      	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
     414:	80 fd       	sbrc	r24, 0
     416:	36 c0       	rjmp	.+108    	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
     418:	fa 01       	movw	r30, r20
     41a:	10 82       	st	Z, r1
     41c:	08 95       	ret
     41e:	83 b3       	in	r24, 0x13	; 19
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	06 2e       	mov	r0, r22
     424:	02 c0       	rjmp	.+4      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
     426:	95 95       	asr	r25
     428:	87 95       	ror	r24
     42a:	0a 94       	dec	r0
     42c:	e2 f7       	brpl	.-8      	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
     42e:	80 ff       	sbrs	r24, 0
     430:	04 c0       	rjmp	.+8      	; 0x43a <__EEPROM_REGION_LENGTH__+0x3a>
     432:	81 e0       	ldi	r24, 0x01	; 1
     434:	fa 01       	movw	r30, r20
     436:	80 83       	st	Z, r24
     438:	08 95       	ret
     43a:	83 b3       	in	r24, 0x13	; 19
     43c:	90 e0       	ldi	r25, 0x00	; 0
     43e:	02 c0       	rjmp	.+4      	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
     440:	95 95       	asr	r25
     442:	87 95       	ror	r24
     444:	6a 95       	dec	r22
     446:	e2 f7       	brpl	.-8      	; 0x440 <__EEPROM_REGION_LENGTH__+0x40>
     448:	80 fd       	sbrc	r24, 0
     44a:	1c c0       	rjmp	.+56     	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
     44c:	fa 01       	movw	r30, r20
     44e:	10 82       	st	Z, r1
     450:	08 95       	ret
     452:	80 b3       	in	r24, 0x10	; 16
     454:	90 e0       	ldi	r25, 0x00	; 0
     456:	06 2e       	mov	r0, r22
     458:	02 c0       	rjmp	.+4      	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
     45a:	95 95       	asr	r25
     45c:	87 95       	ror	r24
     45e:	0a 94       	dec	r0
     460:	e2 f7       	brpl	.-8      	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
     462:	80 ff       	sbrs	r24, 0
     464:	04 c0       	rjmp	.+8      	; 0x46e <__EEPROM_REGION_LENGTH__+0x6e>
     466:	81 e0       	ldi	r24, 0x01	; 1
     468:	fa 01       	movw	r30, r20
     46a:	80 83       	st	Z, r24
     46c:	08 95       	ret
     46e:	80 b3       	in	r24, 0x10	; 16
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	02 c0       	rjmp	.+4      	; 0x478 <__EEPROM_REGION_LENGTH__+0x78>
     474:	95 95       	asr	r25
     476:	87 95       	ror	r24
     478:	6a 95       	dec	r22
     47a:	e2 f7       	brpl	.-8      	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     47c:	80 fd       	sbrc	r24, 0
     47e:	02 c0       	rjmp	.+4      	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
     480:	fa 01       	movw	r30, r20
     482:	10 82       	st	Z, r1
     484:	08 95       	ret

00000486 <DIO_ReadOutputPinValue>:
     486:	41 15       	cp	r20, r1
     488:	51 05       	cpc	r21, r1
     48a:	09 f4       	brne	.+2      	; 0x48e <DIO_ReadOutputPinValue+0x8>
     48c:	76 c0       	rjmp	.+236    	; 0x57a <DIO_ReadOutputPinValue+0xf4>
     48e:	84 30       	cpi	r24, 0x04	; 4
     490:	08 f0       	brcs	.+2      	; 0x494 <DIO_ReadOutputPinValue+0xe>
     492:	73 c0       	rjmp	.+230    	; 0x57a <DIO_ReadOutputPinValue+0xf4>
     494:	68 30       	cpi	r22, 0x08	; 8
     496:	08 f0       	brcs	.+2      	; 0x49a <DIO_ReadOutputPinValue+0x14>
     498:	70 c0       	rjmp	.+224    	; 0x57a <DIO_ReadOutputPinValue+0xf4>
     49a:	81 30       	cpi	r24, 0x01	; 1
     49c:	09 f1       	breq	.+66     	; 0x4e0 <DIO_ReadOutputPinValue+0x5a>
     49e:	30 f0       	brcs	.+12     	; 0x4ac <DIO_ReadOutputPinValue+0x26>
     4a0:	82 30       	cpi	r24, 0x02	; 2
     4a2:	c1 f1       	breq	.+112    	; 0x514 <DIO_ReadOutputPinValue+0x8e>
     4a4:	83 30       	cpi	r24, 0x03	; 3
     4a6:	09 f4       	brne	.+2      	; 0x4aa <DIO_ReadOutputPinValue+0x24>
     4a8:	4f c0       	rjmp	.+158    	; 0x548 <DIO_ReadOutputPinValue+0xc2>
     4aa:	08 95       	ret
     4ac:	8b b3       	in	r24, 0x1b	; 27
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	06 2e       	mov	r0, r22
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <DIO_ReadOutputPinValue+0x32>
     4b4:	95 95       	asr	r25
     4b6:	87 95       	ror	r24
     4b8:	0a 94       	dec	r0
     4ba:	e2 f7       	brpl	.-8      	; 0x4b4 <DIO_ReadOutputPinValue+0x2e>
     4bc:	80 ff       	sbrs	r24, 0
     4be:	04 c0       	rjmp	.+8      	; 0x4c8 <DIO_ReadOutputPinValue+0x42>
     4c0:	81 e0       	ldi	r24, 0x01	; 1
     4c2:	fa 01       	movw	r30, r20
     4c4:	80 83       	st	Z, r24
     4c6:	08 95       	ret
     4c8:	8b b3       	in	r24, 0x1b	; 27
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <DIO_ReadOutputPinValue+0x4c>
     4ce:	95 95       	asr	r25
     4d0:	87 95       	ror	r24
     4d2:	6a 95       	dec	r22
     4d4:	e2 f7       	brpl	.-8      	; 0x4ce <DIO_ReadOutputPinValue+0x48>
     4d6:	80 fd       	sbrc	r24, 0
     4d8:	50 c0       	rjmp	.+160    	; 0x57a <DIO_ReadOutputPinValue+0xf4>
     4da:	fa 01       	movw	r30, r20
     4dc:	10 82       	st	Z, r1
     4de:	08 95       	ret
     4e0:	88 b3       	in	r24, 0x18	; 24
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	06 2e       	mov	r0, r22
     4e6:	02 c0       	rjmp	.+4      	; 0x4ec <DIO_ReadOutputPinValue+0x66>
     4e8:	95 95       	asr	r25
     4ea:	87 95       	ror	r24
     4ec:	0a 94       	dec	r0
     4ee:	e2 f7       	brpl	.-8      	; 0x4e8 <DIO_ReadOutputPinValue+0x62>
     4f0:	80 ff       	sbrs	r24, 0
     4f2:	04 c0       	rjmp	.+8      	; 0x4fc <DIO_ReadOutputPinValue+0x76>
     4f4:	81 e0       	ldi	r24, 0x01	; 1
     4f6:	fa 01       	movw	r30, r20
     4f8:	80 83       	st	Z, r24
     4fa:	08 95       	ret
     4fc:	88 b3       	in	r24, 0x18	; 24
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	02 c0       	rjmp	.+4      	; 0x506 <DIO_ReadOutputPinValue+0x80>
     502:	95 95       	asr	r25
     504:	87 95       	ror	r24
     506:	6a 95       	dec	r22
     508:	e2 f7       	brpl	.-8      	; 0x502 <DIO_ReadOutputPinValue+0x7c>
     50a:	80 fd       	sbrc	r24, 0
     50c:	36 c0       	rjmp	.+108    	; 0x57a <DIO_ReadOutputPinValue+0xf4>
     50e:	fa 01       	movw	r30, r20
     510:	10 82       	st	Z, r1
     512:	08 95       	ret
     514:	85 b3       	in	r24, 0x15	; 21
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	06 2e       	mov	r0, r22
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_ReadOutputPinValue+0x9a>
     51c:	95 95       	asr	r25
     51e:	87 95       	ror	r24
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_ReadOutputPinValue+0x96>
     524:	80 ff       	sbrs	r24, 0
     526:	04 c0       	rjmp	.+8      	; 0x530 <DIO_ReadOutputPinValue+0xaa>
     528:	81 e0       	ldi	r24, 0x01	; 1
     52a:	fa 01       	movw	r30, r20
     52c:	80 83       	st	Z, r24
     52e:	08 95       	ret
     530:	85 b3       	in	r24, 0x15	; 21
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	02 c0       	rjmp	.+4      	; 0x53a <DIO_ReadOutputPinValue+0xb4>
     536:	95 95       	asr	r25
     538:	87 95       	ror	r24
     53a:	6a 95       	dec	r22
     53c:	e2 f7       	brpl	.-8      	; 0x536 <DIO_ReadOutputPinValue+0xb0>
     53e:	80 fd       	sbrc	r24, 0
     540:	1c c0       	rjmp	.+56     	; 0x57a <DIO_ReadOutputPinValue+0xf4>
     542:	fa 01       	movw	r30, r20
     544:	10 82       	st	Z, r1
     546:	08 95       	ret
     548:	82 b3       	in	r24, 0x12	; 18
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	06 2e       	mov	r0, r22
     54e:	02 c0       	rjmp	.+4      	; 0x554 <DIO_ReadOutputPinValue+0xce>
     550:	95 95       	asr	r25
     552:	87 95       	ror	r24
     554:	0a 94       	dec	r0
     556:	e2 f7       	brpl	.-8      	; 0x550 <DIO_ReadOutputPinValue+0xca>
     558:	80 ff       	sbrs	r24, 0
     55a:	04 c0       	rjmp	.+8      	; 0x564 <DIO_ReadOutputPinValue+0xde>
     55c:	81 e0       	ldi	r24, 0x01	; 1
     55e:	fa 01       	movw	r30, r20
     560:	80 83       	st	Z, r24
     562:	08 95       	ret
     564:	82 b3       	in	r24, 0x12	; 18
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	02 c0       	rjmp	.+4      	; 0x56e <DIO_ReadOutputPinValue+0xe8>
     56a:	95 95       	asr	r25
     56c:	87 95       	ror	r24
     56e:	6a 95       	dec	r22
     570:	e2 f7       	brpl	.-8      	; 0x56a <DIO_ReadOutputPinValue+0xe4>
     572:	80 fd       	sbrc	r24, 0
     574:	02 c0       	rjmp	.+4      	; 0x57a <DIO_ReadOutputPinValue+0xf4>
     576:	fa 01       	movw	r30, r20
     578:	10 82       	st	Z, r1
     57a:	08 95       	ret

0000057c <DIO_WriteHalfPort>:
     57c:	0f 93       	push	r16
     57e:	1f 93       	push	r17
     580:	cf 93       	push	r28
     582:	df 93       	push	r29
     584:	84 30       	cpi	r24, 0x04	; 4
     586:	20 f5       	brcc	.+72     	; 0x5d0 <DIO_WriteHalfPort+0x54>
     588:	65 30       	cpi	r22, 0x05	; 5
     58a:	10 f5       	brcc	.+68     	; 0x5d0 <DIO_WriteHalfPort+0x54>
     58c:	40 31       	cpi	r20, 0x10	; 16
     58e:	d0 f0       	brcs	.+52     	; 0x5c4 <DIO_WriteHalfPort+0x48>
     590:	1f c0       	rjmp	.+62     	; 0x5d0 <DIO_WriteHalfPort+0x54>
     592:	20 2f       	mov	r18, r16
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	0c 2e       	mov	r0, r28
     598:	02 c0       	rjmp	.+4      	; 0x59e <DIO_WriteHalfPort+0x22>
     59a:	35 95       	asr	r19
     59c:	27 95       	ror	r18
     59e:	0a 94       	dec	r0
     5a0:	e2 f7       	brpl	.-8      	; 0x59a <DIO_WriteHalfPort+0x1e>
     5a2:	20 ff       	sbrs	r18, 0
     5a4:	07 c0       	rjmp	.+14     	; 0x5b4 <DIO_WriteHalfPort+0x38>
     5a6:	41 e0       	ldi	r20, 0x01	; 1
     5a8:	6c 2f       	mov	r22, r28
     5aa:	61 0f       	add	r22, r17
     5ac:	8d 2f       	mov	r24, r29
     5ae:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
     5b2:	06 c0       	rjmp	.+12     	; 0x5c0 <DIO_WriteHalfPort+0x44>
     5b4:	40 e0       	ldi	r20, 0x00	; 0
     5b6:	6c 2f       	mov	r22, r28
     5b8:	61 0f       	add	r22, r17
     5ba:	8d 2f       	mov	r24, r29
     5bc:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
     5c0:	cf 5f       	subi	r28, 0xFF	; 255
     5c2:	04 c0       	rjmp	.+8      	; 0x5cc <DIO_WriteHalfPort+0x50>
     5c4:	04 2f       	mov	r16, r20
     5c6:	16 2f       	mov	r17, r22
     5c8:	d8 2f       	mov	r29, r24
     5ca:	c0 e0       	ldi	r28, 0x00	; 0
     5cc:	c4 30       	cpi	r28, 0x04	; 4
     5ce:	08 f3       	brcs	.-62     	; 0x592 <DIO_WriteHalfPort+0x16>
     5d0:	df 91       	pop	r29
     5d2:	cf 91       	pop	r28
     5d4:	1f 91       	pop	r17
     5d6:	0f 91       	pop	r16
     5d8:	08 95       	ret

000005da <DIO_ActivatePullUp>:
 * @param Copy_u8PortID: The ID of the Port containing the desired pin
 * @param Copy_u8PinID: The pin for its pull-up resistor to be activated
 */
void DIO_ActivatePullUp     (u8 Copy_u8PortID, u8 Copy_u8PinID)
{
	if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
     5da:	84 30       	cpi	r24, 0x04	; 4
     5dc:	08 f0       	brcs	.+2      	; 0x5e0 <DIO_ActivatePullUp+0x6>
     5de:	5f c0       	rjmp	.+190    	; 0x69e <DIO_ActivatePullUp+0xc4>
	{
		if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
     5e0:	68 30       	cpi	r22, 0x08	; 8
     5e2:	08 f0       	brcs	.+2      	; 0x5e6 <DIO_ActivatePullUp+0xc>
     5e4:	5c c0       	rjmp	.+184    	; 0x69e <DIO_ActivatePullUp+0xc4>
		{
			switch(Copy_u8PortID)
     5e6:	81 30       	cpi	r24, 0x01	; 1
     5e8:	e1 f0       	breq	.+56     	; 0x622 <DIO_ActivatePullUp+0x48>
     5ea:	30 f0       	brcs	.+12     	; 0x5f8 <DIO_ActivatePullUp+0x1e>
     5ec:	82 30       	cpi	r24, 0x02	; 2
     5ee:	71 f1       	breq	.+92     	; 0x64c <DIO_ActivatePullUp+0x72>
     5f0:	83 30       	cpi	r24, 0x03	; 3
     5f2:	09 f4       	brne	.+2      	; 0x5f6 <DIO_ActivatePullUp+0x1c>
     5f4:	40 c0       	rjmp	.+128    	; 0x676 <DIO_ActivatePullUp+0x9c>
     5f6:	08 95       	ret
			{
				case DIO_PORTA:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRA, Copy_u8PinID))
     5f8:	8a b3       	in	r24, 0x1a	; 26
     5fa:	90 e0       	ldi	r25, 0x00	; 0
     5fc:	06 2e       	mov	r0, r22
     5fe:	02 c0       	rjmp	.+4      	; 0x604 <DIO_ActivatePullUp+0x2a>
     600:	95 95       	asr	r25
     602:	87 95       	ror	r24
     604:	0a 94       	dec	r0
     606:	e2 f7       	brpl	.-8      	; 0x600 <DIO_ActivatePullUp+0x26>
     608:	80 fd       	sbrc	r24, 0
     60a:	49 c0       	rjmp	.+146    	; 0x69e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTA, Copy_u8PinID);
     60c:	2b b3       	in	r18, 0x1b	; 27
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	90 e0       	ldi	r25, 0x00	; 0
     612:	02 c0       	rjmp	.+4      	; 0x618 <DIO_ActivatePullUp+0x3e>
     614:	88 0f       	add	r24, r24
     616:	99 1f       	adc	r25, r25
     618:	6a 95       	dec	r22
     61a:	e2 f7       	brpl	.-8      	; 0x614 <DIO_ActivatePullUp+0x3a>
     61c:	82 2b       	or	r24, r18
     61e:	8b bb       	out	0x1b, r24	; 27
     620:	08 95       	ret
					}
					break;
				}
				case DIO_PORTB:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRB, Copy_u8PinID))
     622:	87 b3       	in	r24, 0x17	; 23
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	06 2e       	mov	r0, r22
     628:	02 c0       	rjmp	.+4      	; 0x62e <DIO_ActivatePullUp+0x54>
     62a:	95 95       	asr	r25
     62c:	87 95       	ror	r24
     62e:	0a 94       	dec	r0
     630:	e2 f7       	brpl	.-8      	; 0x62a <DIO_ActivatePullUp+0x50>
     632:	80 fd       	sbrc	r24, 0
     634:	34 c0       	rjmp	.+104    	; 0x69e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTB, Copy_u8PinID);
     636:	28 b3       	in	r18, 0x18	; 24
     638:	81 e0       	ldi	r24, 0x01	; 1
     63a:	90 e0       	ldi	r25, 0x00	; 0
     63c:	02 c0       	rjmp	.+4      	; 0x642 <DIO_ActivatePullUp+0x68>
     63e:	88 0f       	add	r24, r24
     640:	99 1f       	adc	r25, r25
     642:	6a 95       	dec	r22
     644:	e2 f7       	brpl	.-8      	; 0x63e <DIO_ActivatePullUp+0x64>
     646:	82 2b       	or	r24, r18
     648:	88 bb       	out	0x18, r24	; 24
     64a:	08 95       	ret
					}
					break;
				}
				case DIO_PORTC:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRC, Copy_u8PinID))
     64c:	84 b3       	in	r24, 0x14	; 20
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	06 2e       	mov	r0, r22
     652:	02 c0       	rjmp	.+4      	; 0x658 <DIO_ActivatePullUp+0x7e>
     654:	95 95       	asr	r25
     656:	87 95       	ror	r24
     658:	0a 94       	dec	r0
     65a:	e2 f7       	brpl	.-8      	; 0x654 <DIO_ActivatePullUp+0x7a>
     65c:	80 fd       	sbrc	r24, 0
     65e:	1f c0       	rjmp	.+62     	; 0x69e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTC, Copy_u8PinID);
     660:	25 b3       	in	r18, 0x15	; 21
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	02 c0       	rjmp	.+4      	; 0x66c <DIO_ActivatePullUp+0x92>
     668:	88 0f       	add	r24, r24
     66a:	99 1f       	adc	r25, r25
     66c:	6a 95       	dec	r22
     66e:	e2 f7       	brpl	.-8      	; 0x668 <DIO_ActivatePullUp+0x8e>
     670:	82 2b       	or	r24, r18
     672:	85 bb       	out	0x15, r24	; 21
     674:	08 95       	ret
					}
					break;
				}
				case DIO_PORTD:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRD, Copy_u8PinID))
     676:	81 b3       	in	r24, 0x11	; 17
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	06 2e       	mov	r0, r22
     67c:	02 c0       	rjmp	.+4      	; 0x682 <DIO_ActivatePullUp+0xa8>
     67e:	95 95       	asr	r25
     680:	87 95       	ror	r24
     682:	0a 94       	dec	r0
     684:	e2 f7       	brpl	.-8      	; 0x67e <DIO_ActivatePullUp+0xa4>
     686:	80 fd       	sbrc	r24, 0
     688:	0a c0       	rjmp	.+20     	; 0x69e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTD, Copy_u8PinID);
     68a:	22 b3       	in	r18, 0x12	; 18
     68c:	81 e0       	ldi	r24, 0x01	; 1
     68e:	90 e0       	ldi	r25, 0x00	; 0
     690:	02 c0       	rjmp	.+4      	; 0x696 <DIO_ActivatePullUp+0xbc>
     692:	88 0f       	add	r24, r24
     694:	99 1f       	adc	r25, r25
     696:	6a 95       	dec	r22
     698:	e2 f7       	brpl	.-8      	; 0x692 <DIO_ActivatePullUp+0xb8>
     69a:	82 2b       	or	r24, r18
     69c:	82 bb       	out	0x12, r24	; 18
     69e:	08 95       	ret

000006a0 <DIO_ReadDDRPinValue>:
 * @param Copy_u8PinID: The ID of the desired pin 
 * @param P_u8DDRPinValue: Pointer in which we save the desired value
 */
void DIO_ReadDDRPinValue    (u8 Copy_u8PortID, u8 Copy_u8PinID, u8* P_u8DDRPinValue)
{
	if(P_u8DDRPinValue != NULL)
     6a0:	41 15       	cp	r20, r1
     6a2:	51 05       	cpc	r21, r1
     6a4:	09 f4       	brne	.+2      	; 0x6a8 <DIO_ReadDDRPinValue+0x8>
     6a6:	76 c0       	rjmp	.+236    	; 0x794 <DIO_ReadDDRPinValue+0xf4>
	{
		if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
     6a8:	84 30       	cpi	r24, 0x04	; 4
     6aa:	08 f0       	brcs	.+2      	; 0x6ae <DIO_ReadDDRPinValue+0xe>
     6ac:	73 c0       	rjmp	.+230    	; 0x794 <DIO_ReadDDRPinValue+0xf4>
		{
			if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
     6ae:	68 30       	cpi	r22, 0x08	; 8
     6b0:	08 f0       	brcs	.+2      	; 0x6b4 <DIO_ReadDDRPinValue+0x14>
     6b2:	70 c0       	rjmp	.+224    	; 0x794 <DIO_ReadDDRPinValue+0xf4>
			{
				switch (Copy_u8PortID)
     6b4:	81 30       	cpi	r24, 0x01	; 1
     6b6:	09 f1       	breq	.+66     	; 0x6fa <DIO_ReadDDRPinValue+0x5a>
     6b8:	30 f0       	brcs	.+12     	; 0x6c6 <DIO_ReadDDRPinValue+0x26>
     6ba:	82 30       	cpi	r24, 0x02	; 2
     6bc:	c1 f1       	breq	.+112    	; 0x72e <DIO_ReadDDRPinValue+0x8e>
     6be:	83 30       	cpi	r24, 0x03	; 3
     6c0:	09 f4       	brne	.+2      	; 0x6c4 <DIO_ReadDDRPinValue+0x24>
     6c2:	4f c0       	rjmp	.+158    	; 0x762 <DIO_ReadDDRPinValue+0xc2>
     6c4:	08 95       	ret
				{
					case DIO_PORTA:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRA, Copy_u8PinID))
     6c6:	8a b3       	in	r24, 0x1a	; 26
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	06 2e       	mov	r0, r22
     6cc:	02 c0       	rjmp	.+4      	; 0x6d2 <DIO_ReadDDRPinValue+0x32>
     6ce:	95 95       	asr	r25
     6d0:	87 95       	ror	r24
     6d2:	0a 94       	dec	r0
     6d4:	e2 f7       	brpl	.-8      	; 0x6ce <DIO_ReadDDRPinValue+0x2e>
     6d6:	80 ff       	sbrs	r24, 0
     6d8:	04 c0       	rjmp	.+8      	; 0x6e2 <DIO_ReadDDRPinValue+0x42>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     6da:	81 e0       	ldi	r24, 0x01	; 1
     6dc:	fa 01       	movw	r30, r20
     6de:	80 83       	st	Z, r24
     6e0:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRA, Copy_u8PinID))
     6e2:	8a b3       	in	r24, 0x1a	; 26
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	02 c0       	rjmp	.+4      	; 0x6ec <DIO_ReadDDRPinValue+0x4c>
     6e8:	95 95       	asr	r25
     6ea:	87 95       	ror	r24
     6ec:	6a 95       	dec	r22
     6ee:	e2 f7       	brpl	.-8      	; 0x6e8 <DIO_ReadDDRPinValue+0x48>
     6f0:	80 fd       	sbrc	r24, 0
     6f2:	50 c0       	rjmp	.+160    	; 0x794 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     6f4:	fa 01       	movw	r30, r20
     6f6:	10 82       	st	Z, r1
     6f8:	08 95       	ret
						}
						break;
					}
					case DIO_PORTB:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRB, Copy_u8PinID))
     6fa:	87 b3       	in	r24, 0x17	; 23
     6fc:	90 e0       	ldi	r25, 0x00	; 0
     6fe:	06 2e       	mov	r0, r22
     700:	02 c0       	rjmp	.+4      	; 0x706 <DIO_ReadDDRPinValue+0x66>
     702:	95 95       	asr	r25
     704:	87 95       	ror	r24
     706:	0a 94       	dec	r0
     708:	e2 f7       	brpl	.-8      	; 0x702 <DIO_ReadDDRPinValue+0x62>
     70a:	80 ff       	sbrs	r24, 0
     70c:	04 c0       	rjmp	.+8      	; 0x716 <DIO_ReadDDRPinValue+0x76>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	fa 01       	movw	r30, r20
     712:	80 83       	st	Z, r24
     714:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRB, Copy_u8PinID))
     716:	87 b3       	in	r24, 0x17	; 23
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	02 c0       	rjmp	.+4      	; 0x720 <DIO_ReadDDRPinValue+0x80>
     71c:	95 95       	asr	r25
     71e:	87 95       	ror	r24
     720:	6a 95       	dec	r22
     722:	e2 f7       	brpl	.-8      	; 0x71c <DIO_ReadDDRPinValue+0x7c>
     724:	80 fd       	sbrc	r24, 0
     726:	36 c0       	rjmp	.+108    	; 0x794 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     728:	fa 01       	movw	r30, r20
     72a:	10 82       	st	Z, r1
     72c:	08 95       	ret
						}
						break;
					}
					case DIO_PORTC:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRC, Copy_u8PinID))
     72e:	84 b3       	in	r24, 0x14	; 20
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	06 2e       	mov	r0, r22
     734:	02 c0       	rjmp	.+4      	; 0x73a <DIO_ReadDDRPinValue+0x9a>
     736:	95 95       	asr	r25
     738:	87 95       	ror	r24
     73a:	0a 94       	dec	r0
     73c:	e2 f7       	brpl	.-8      	; 0x736 <DIO_ReadDDRPinValue+0x96>
     73e:	80 ff       	sbrs	r24, 0
     740:	04 c0       	rjmp	.+8      	; 0x74a <DIO_ReadDDRPinValue+0xaa>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     742:	81 e0       	ldi	r24, 0x01	; 1
     744:	fa 01       	movw	r30, r20
     746:	80 83       	st	Z, r24
     748:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRC, Copy_u8PinID))
     74a:	84 b3       	in	r24, 0x14	; 20
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	02 c0       	rjmp	.+4      	; 0x754 <DIO_ReadDDRPinValue+0xb4>
     750:	95 95       	asr	r25
     752:	87 95       	ror	r24
     754:	6a 95       	dec	r22
     756:	e2 f7       	brpl	.-8      	; 0x750 <DIO_ReadDDRPinValue+0xb0>
     758:	80 fd       	sbrc	r24, 0
     75a:	1c c0       	rjmp	.+56     	; 0x794 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     75c:	fa 01       	movw	r30, r20
     75e:	10 82       	st	Z, r1
     760:	08 95       	ret
						}
						break;
					}
					case DIO_PORTD:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRD, Copy_u8PinID))
     762:	81 b3       	in	r24, 0x11	; 17
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	06 2e       	mov	r0, r22
     768:	02 c0       	rjmp	.+4      	; 0x76e <DIO_ReadDDRPinValue+0xce>
     76a:	95 95       	asr	r25
     76c:	87 95       	ror	r24
     76e:	0a 94       	dec	r0
     770:	e2 f7       	brpl	.-8      	; 0x76a <DIO_ReadDDRPinValue+0xca>
     772:	80 ff       	sbrs	r24, 0
     774:	04 c0       	rjmp	.+8      	; 0x77e <DIO_ReadDDRPinValue+0xde>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	fa 01       	movw	r30, r20
     77a:	80 83       	st	Z, r24
     77c:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRD, Copy_u8PinID))
     77e:	81 b3       	in	r24, 0x11	; 17
     780:	90 e0       	ldi	r25, 0x00	; 0
     782:	02 c0       	rjmp	.+4      	; 0x788 <DIO_ReadDDRPinValue+0xe8>
     784:	95 95       	asr	r25
     786:	87 95       	ror	r24
     788:	6a 95       	dec	r22
     78a:	e2 f7       	brpl	.-8      	; 0x784 <DIO_ReadDDRPinValue+0xe4>
     78c:	80 fd       	sbrc	r24, 0
     78e:	02 c0       	rjmp	.+4      	; 0x794 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     790:	fa 01       	movw	r30, r20
     792:	10 82       	st	Z, r1
     794:	08 95       	ret

00000796 <GI_Enable>:
 * @brief: Function to enable the global interrupt
 * 
 */
void GI_Enable(void)
{
    SET_BIT(SREG, 7);
     796:	8f b7       	in	r24, 0x3f	; 63
     798:	80 68       	ori	r24, 0x80	; 128
     79a:	8f bf       	out	0x3f, r24	; 63
     79c:	08 95       	ret

0000079e <HC05_WelcomeMessage>:
 * @brief: Function to send a welcome message to the user/admin
 * 
 */
void HC05_WelcomeMessage(void)
{
    UART_TxString("Hello! Welcome to Smart Home");
     79e:	81 e7       	ldi	r24, 0x71	; 113
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("Please enter whether you are admin or a user");
     7a6:	8e e8       	ldi	r24, 0x8E	; 142
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("1:Admin    2: User");
     7ae:	8b eb       	ldi	r24, 0xBB	; 187
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    glbl_u8CurrentScreen = HC05_WELCOME_SCREEN;
     7b6:	81 e0       	ldi	r24, 0x01	; 1
     7b8:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     7bc:	08 95       	ret

000007be <HC05_AdminUsernamePasswordSaver>:
/**
 * @brief: Function to set the admin username and password for the first time
 * 
 */
void HC05_AdminUsernamePasswordSaver(void)
{
     7be:	cf 93       	push	r28
    /*Write Admin UserName "2" to the specified Admin EEPROM Memory address "50"*/
    Internal_EEPROM_WriteByte(HC05_ADMIN_MEM_ADDRESS, HC05_ADMIN_USERNAME);
     7c0:	62 e3       	ldi	r22, 0x32	; 50
     7c2:	82 e3       	ldi	r24, 0x32	; 50
     7c4:	90 e0       	ldi	r25, 0x00	; 0
     7c6:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>

    u8 Loc_u8Index = 0; 
	u16 Loc_u8Address = 0;

    /*Save Admin Password in the EEPROM "123" */
    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     7ca:	c0 e0       	ldi	r28, 0x00	; 0
     7cc:	0a c0       	rjmp	.+20     	; 0x7e2 <HC05_AdminUsernamePasswordSaver+0x24>
    {
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + Loc_u8Index + 1;
     7ce:	8c 2f       	mov	r24, r28
     7d0:	90 e0       	ldi	r25, 0x00	; 0
        Internal_EEPROM_WriteByte(Loc_u8Address, HC05_ADMIN_PASSWRD[Loc_u8Index]);
     7d2:	fc 01       	movw	r30, r24
     7d4:	ed 50       	subi	r30, 0x0D	; 13
     7d6:	fa 4f       	sbci	r31, 0xFA	; 250
     7d8:	60 81       	ld	r22, Z
     7da:	c3 96       	adiw	r24, 0x33	; 51
     7dc:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>

    u8 Loc_u8Index = 0; 
	u16 Loc_u8Address = 0;

    /*Save Admin Password in the EEPROM "123" */
    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     7e0:	cf 5f       	subi	r28, 0xFF	; 255
     7e2:	c3 30       	cpi	r28, 0x03	; 3
     7e4:	a0 f3       	brcs	.-24     	; 0x7ce <HC05_AdminUsernamePasswordSaver+0x10>
    {
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + Loc_u8Index + 1;
        Internal_EEPROM_WriteByte(Loc_u8Address, HC05_ADMIN_PASSWRD[Loc_u8Index]);
    }
    /*Set number of users to be 1 and save it in EEPROM*/
	Internal_EEPROM_WriteByte(HC05_NO_USERS_MEM_ADDRESS, 1);
     7e6:	61 e0       	ldi	r22, 0x01	; 1
     7e8:	8a e0       	ldi	r24, 0x0A	; 10
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>

    /*We save this status in EEPROM to show that the Admin username and password is successfully*/
    /*Saved in EEPROM*/
	Internal_EEPROM_WriteByte(HC05_ADMIN_SAVED_STATUS_MEM_ADDRESS, 1);
     7f0:	61 e0       	ldi	r22, 0x01	; 1
     7f2:	80 e5       	ldi	r24, 0x50	; 80
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>
}
     7fa:	cf 91       	pop	r28
     7fc:	08 95       	ret

000007fe <HC05_UsernamePasswordCheck>:
 * @brief: Function to check if the password is correct or not
 * 
 * @return u8: The result of the check
 */
u8 HC05_UsernamePasswordCheck(void)
{
     7fe:	df 92       	push	r13
     800:	ef 92       	push	r14
     802:	ff 92       	push	r15
     804:	0f 93       	push	r16
     806:	1f 93       	push	r17
     808:	cf 93       	push	r28
     80a:	df 93       	push	r29
     80c:	00 d0       	rcall	.+0      	; 0x80e <__DATA_REGION_LENGTH__+0xe>
     80e:	1f 92       	push	r1
     810:	cd b7       	in	r28, 0x3d	; 61
     812:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8Index = 0;
    u8 Loc_u8Username = 0; 
     814:	19 82       	std	Y+1, r1	; 0x01
    u8 Loc_u8Pass = 0;
     816:	1a 82       	std	Y+2, r1	; 0x02

    if(glbl_u8AdminMode == ADMIN_MODE_ON) //Check if the User chose admin mode
     818:	00 91 93 07 	lds	r16, 0x0793	; 0x800793 <glbl_u8AdminMode>
     81c:	01 30       	cpi	r16, 0x01	; 1
     81e:	79 f5       	brne	.+94     	; 0x87e <__stack+0x1f>
    {
        /*Read Admin Username from EEPROM and save it in this variable*/
        Internal_EEPROM_ReadByte(HC05_ADMIN_MEM_ADDRESS, &Loc_u8Username);
     820:	be 01       	movw	r22, r28
     822:	6f 5f       	subi	r22, 0xFF	; 255
     824:	7f 4f       	sbci	r23, 0xFF	; 255
     826:	82 e3       	ldi	r24, 0x32	; 50
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>

        /*Check if the username read from memory equals the username entered by user/admin*/
        if(glbl_u8AdminUserUsername == Loc_u8Username)
     82e:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
     832:	89 81       	ldd	r24, Y+1	; 0x01
     834:	98 13       	cpse	r25, r24
     836:	1d c0       	rjmp	.+58     	; 0x872 <__stack+0x13>
     838:	18 c0       	rjmp	.+48     	; 0x86a <__stack+0xb>
        {
            /*Username is correct*/
            for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
            {
                /*Read Admin Password from memory to check if the entered password is correct or not*/
                Internal_EEPROM_ReadByte((HC05_ADMIN_MEM_ADDRESS + Loc_u8Index + 1), &Loc_u8Pass);
     83a:	e1 2e       	mov	r14, r17
     83c:	f1 2c       	mov	r15, r1
     83e:	be 01       	movw	r22, r28
     840:	6e 5f       	subi	r22, 0xFE	; 254
     842:	7f 4f       	sbci	r23, 0xFF	; 255
     844:	c7 01       	movw	r24, r14
     846:	c3 96       	adiw	r24, 0x33	; 51
     848:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>

                if(Loc_u8Pass != glbl_u8AdminUserPassword[Loc_u8Index])
     84c:	f7 01       	movw	r30, r14
     84e:	e2 57       	subi	r30, 0x72	; 114
     850:	f8 4f       	sbci	r31, 0xF8	; 248
     852:	90 81       	ld	r25, Z
     854:	8a 81       	ldd	r24, Y+2	; 0x02
     856:	98 17       	cp	r25, r24
     858:	31 f0       	breq	.+12     	; 0x866 <__stack+0x7>
                {
                    /*Means that the entered password is not correct*/
                    UART_TxString("Sorry, Invalid Password");
     85a:	8e ec       	ldi	r24, 0xCE	; 206
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    return HC05_USERNAME_PASSOWRD_INCORRECT;
     862:	02 e0       	ldi	r16, 0x02	; 2
     864:	65 c0       	rjmp	.+202    	; 0x930 <__stack+0xd1>

        /*Check if the username read from memory equals the username entered by user/admin*/
        if(glbl_u8AdminUserUsername == Loc_u8Username)
        {
            /*Username is correct*/
            for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     866:	1f 5f       	subi	r17, 0xFF	; 255
     868:	01 c0       	rjmp	.+2      	; 0x86c <__stack+0xd>
     86a:	10 e0       	ldi	r17, 0x00	; 0
     86c:	13 30       	cpi	r17, 0x03	; 3
     86e:	28 f3       	brcs	.-54     	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
     870:	5f c0       	rjmp	.+190    	; 0x930 <__stack+0xd1>
            return HC05_USERNAME_PASSOWRD_CORRECT;
        }
        else
        {
            /*Username is incorrect*/
            UART_TxString("Sorry, Invalid username");
     872:	86 ee       	ldi	r24, 0xE6	; 230
     874:	90 e0       	ldi	r25, 0x00	; 0
     876:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
            return HC05_USERNAME_PASSOWRD_INCORRECT;
     87a:	02 e0       	ldi	r16, 0x02	; 2
     87c:	59 c0       	rjmp	.+178    	; 0x930 <__stack+0xd1>
        }
    }
    else if(glbl_u8UserMode == USER_MODE_ON) //User has chosen user mode
     87e:	00 91 92 07 	lds	r16, 0x0792	; 0x800792 <glbl_u8UserMode>
     882:	01 30       	cpi	r16, 0x01	; 1
     884:	09 f0       	breq	.+2      	; 0x888 <__stack+0x29>
     886:	4f c0       	rjmp	.+158    	; 0x926 <__stack+0xc7>
    {
        u8 Loc_u8NoOfUsers = 0;
     888:	1b 82       	std	Y+3, r1	; 0x03
        u8 Loc_u8CorrectUserAddress = 0;

        /*Save the current number of users/admin*/
        Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     88a:	be 01       	movw	r22, r28
     88c:	6d 5f       	subi	r22, 0xFD	; 253
     88e:	7f 4f       	sbci	r23, 0xFF	; 255
     890:	8a e0       	ldi	r24, 0x0A	; 10
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
        }
    }
    else if(glbl_u8UserMode == USER_MODE_ON) //User has chosen user mode
    {
        u8 Loc_u8NoOfUsers = 0;
        u8 Loc_u8CorrectUserAddress = 0;
     898:	d1 2c       	mov	r13, r1

        /*Save the current number of users/admin*/
        Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);

        for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     89a:	11 e0       	ldi	r17, 0x01	; 1
     89c:	1a c0       	rjmp	.+52     	; 0x8d2 <__stack+0x73>
        {
            /*Read the existing Usernames of users saved and check if the entered username matches one of them*/
            /*or not*/
            Internal_EEPROM_ReadByte((HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index)) , &Loc_u8Username);
     89e:	81 2f       	mov	r24, r17
     8a0:	90 e0       	ldi	r25, 0x00	; 0
     8a2:	88 0f       	add	r24, r24
     8a4:	99 1f       	adc	r25, r25
     8a6:	88 0f       	add	r24, r24
     8a8:	99 1f       	adc	r25, r25
     8aa:	be 01       	movw	r22, r28
     8ac:	6f 5f       	subi	r22, 0xFF	; 255
     8ae:	7f 4f       	sbci	r23, 0xFF	; 255
     8b0:	c2 96       	adiw	r24, 0x32	; 50
     8b2:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
            if(glbl_u8AdminUserUsername == Loc_u8Username)
     8b6:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
     8ba:	89 81       	ldd	r24, Y+1	; 0x01
     8bc:	98 13       	cpse	r25, r24
     8be:	08 c0       	rjmp	.+16     	; 0x8d0 <__stack+0x71>
            {
                /*means that the username exists in EEPROM*/
                /*We save this username address in order to check its password*/
                Loc_u8CorrectUserAddress = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index);
     8c0:	81 2f       	mov	r24, r17
     8c2:	88 0f       	add	r24, r24
     8c4:	88 0f       	add	r24, r24
     8c6:	0f 2e       	mov	r0, r31
     8c8:	f2 e3       	ldi	r31, 0x32	; 50
     8ca:	df 2e       	mov	r13, r31
     8cc:	f0 2d       	mov	r31, r0
     8ce:	d8 0e       	add	r13, r24
        u8 Loc_u8CorrectUserAddress = 0;

        /*Save the current number of users/admin*/
        Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);

        for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     8d0:	1f 5f       	subi	r17, 0xFF	; 255
     8d2:	8b 81       	ldd	r24, Y+3	; 0x03
     8d4:	18 17       	cp	r17, r24
     8d6:	18 f3       	brcs	.-58     	; 0x89e <__stack+0x3f>
                /*means that the username exists in EEPROM*/
                /*We save this username address in order to check its password*/
                Loc_u8CorrectUserAddress = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index);
            }
        }
        if(Loc_u8CorrectUserAddress == 0)
     8d8:	d1 10       	cpse	r13, r1
     8da:	21 c0       	rjmp	.+66     	; 0x91e <__stack+0xbf>
        {
            /*Means that the username does not exist*/
            UART_TxString("Sorry, Invalid username");
     8dc:	86 ee       	ldi	r24, 0xE6	; 230
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
            return HC05_USERNAME_PASSOWRD_INCORRECT;
     8e4:	02 e0       	ldi	r16, 0x02	; 2
     8e6:	24 c0       	rjmp	.+72     	; 0x930 <__stack+0xd1>

        for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
        {
            /*Read the user ,whose username matches the entered username, password and check if it matches the*/
            /*entered password*/
            Internal_EEPROM_ReadByte((Loc_u8CorrectUserAddress + 1 + Loc_u8Index),&Loc_u8Pass);
     8e8:	8d 2d       	mov	r24, r13
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	01 96       	adiw	r24, 0x01	; 1
     8ee:	e1 2e       	mov	r14, r17
     8f0:	f1 2c       	mov	r15, r1
     8f2:	be 01       	movw	r22, r28
     8f4:	6e 5f       	subi	r22, 0xFE	; 254
     8f6:	7f 4f       	sbci	r23, 0xFF	; 255
     8f8:	8e 0d       	add	r24, r14
     8fa:	9f 1d       	adc	r25, r15
     8fc:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
            if(Loc_u8Pass != glbl_u8AdminUserPassword[Loc_u8Index])
     900:	f7 01       	movw	r30, r14
     902:	e2 57       	subi	r30, 0x72	; 114
     904:	f8 4f       	sbci	r31, 0xF8	; 248
     906:	90 81       	ld	r25, Z
     908:	8a 81       	ldd	r24, Y+2	; 0x02
     90a:	98 17       	cp	r25, r24
     90c:	31 f0       	breq	.+12     	; 0x91a <__stack+0xbb>
            {
                /*Means that the password entered is incorrect*/
                UART_TxString("Sorry, Invalid password");
     90e:	8e ef       	ldi	r24, 0xFE	; 254
     910:	90 e0       	ldi	r25, 0x00	; 0
     912:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                return HC05_USERNAME_PASSOWRD_INCORRECT;
     916:	02 e0       	ldi	r16, 0x02	; 2
     918:	0b c0       	rjmp	.+22     	; 0x930 <__stack+0xd1>
            /*Means that the username does not exist*/
            UART_TxString("Sorry, Invalid username");
            return HC05_USERNAME_PASSOWRD_INCORRECT;
        }

        for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     91a:	1f 5f       	subi	r17, 0xFF	; 255
     91c:	01 c0       	rjmp	.+2      	; 0x920 <__stack+0xc1>
     91e:	10 e0       	ldi	r17, 0x00	; 0
     920:	13 30       	cpi	r17, 0x03	; 3
     922:	10 f3       	brcs	.-60     	; 0x8e8 <__stack+0x89>
     924:	05 c0       	rjmp	.+10     	; 0x930 <__stack+0xd1>
        return HC05_USERNAME_PASSOWRD_CORRECT;
    }
    else
    {
        /*Means that the user input is wrong*/
        UART_TxString("Sorry, Wrong Input");
     926:	86 e1       	ldi	r24, 0x16	; 22
     928:	91 e0       	ldi	r25, 0x01	; 1
     92a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
        return HC05_USERNAME_PASSOWRD_INCORRECT;
     92e:	02 e0       	ldi	r16, 0x02	; 2
    }
}
     930:	80 2f       	mov	r24, r16
     932:	0f 90       	pop	r0
     934:	0f 90       	pop	r0
     936:	0f 90       	pop	r0
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	1f 91       	pop	r17
     93e:	0f 91       	pop	r16
     940:	ff 90       	pop	r15
     942:	ef 90       	pop	r14
     944:	df 90       	pop	r13
     946:	08 95       	ret

00000948 <HC05_AdminLoginCheck>:
 */
u8 HC05_AdminLoginCheck(void)
{
    /*Return the status of admin mode to check if admin is currently using the system or not*/
    return glbl_u8AdminMode;
}
     948:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <glbl_u8AdminMode>
     94c:	08 95       	ret

0000094e <HC05_AdminUserChoiceList>:
 * @brief: Function to show the admin/user choice list after logging in
 * 
 */
void HC05_AdminUserChoiceList(void)
{ /*AC Automatic*/
    UART_TxString("Welcome");
     94e:	89 e2       	ldi	r24, 0x29	; 41
     950:	91 e0       	ldi	r25, 0x01	; 1
     952:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("Choose the service you wish to do");
     956:	81 e3       	ldi	r24, 0x31	; 49
     958:	91 e0       	ldi	r25, 0x01	; 1
     95a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("1: Door");
     95e:	83 e5       	ldi	r24, 0x53	; 83
     960:	91 e0       	ldi	r25, 0x01	; 1
     962:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("2: LEDs");
     966:	8b e5       	ldi	r24, 0x5B	; 91
     968:	91 e0       	ldi	r25, 0x01	; 1
     96a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
	UART_TxString("3: Add User");
     96e:	83 e6       	ldi	r24, 0x63	; 99
     970:	91 e0       	ldi	r25, 0x01	; 1
     972:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
	UART_TxString("4: Delete User");
     976:	8f e6       	ldi	r24, 0x6F	; 111
     978:	91 e0       	ldi	r25, 0x01	; 1
     97a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("5: Log Out");
     97e:	8e e7       	ldi	r24, 0x7E	; 126
     980:	91 e0       	ldi	r25, 0x01	; 1
     982:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
     986:	08 95       	ret

00000988 <HC05_AdminUserLEDChoice>:
 * @brief: Function to show the admin/user LED Choice list
 * 
 */
void HC05_AdminUserLEDChoice(void)
{
    UART_TxString("Please select the LED you wish to control");
     988:	89 e8       	ldi	r24, 0x89	; 137
     98a:	91 e0       	ldi	r25, 0x01	; 1
     98c:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("1: LED 1");
     990:	83 eb       	ldi	r24, 0xB3	; 179
     992:	91 e0       	ldi	r25, 0x01	; 1
     994:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("2: LED 2");
     998:	8c eb       	ldi	r24, 0xBC	; 188
     99a:	91 e0       	ldi	r25, 0x01	; 1
     99c:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    UART_TxString("3: Dimming LED");
     9a0:	85 ec       	ldi	r24, 0xC5	; 197
     9a2:	91 e0       	ldi	r25, 0x01	; 1
     9a4:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
     9a8:	08 95       	ret

000009aa <HC05_UserNamePasswordExist>:
 * @brief: Function to check if the username entered exists in EEPROM or not
 * 
 * @return u8: Check if this user exists or not
 */
u8 HC05_UserNamePasswordExist(void)
{
     9aa:	1f 93       	push	r17
     9ac:	cf 93       	push	r28
     9ae:	df 93       	push	r29
     9b0:	00 d0       	rcall	.+0      	; 0x9b2 <HC05_UserNamePasswordExist+0x8>
     9b2:	cd b7       	in	r28, 0x3d	; 61
     9b4:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8NoOfUsers = 0;
     9b6:	19 82       	std	Y+1, r1	; 0x01
    /*Read the current number of users/admin in the system*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     9b8:	be 01       	movw	r22, r28
     9ba:	6f 5f       	subi	r22, 0xFF	; 255
     9bc:	7f 4f       	sbci	r23, 0xFF	; 255
     9be:	8a e0       	ldi	r24, 0x0A	; 10
     9c0:	90 e0       	ldi	r25, 0x00	; 0
     9c2:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>

    u8 Loc_u8Index = 0;
    u8 Loc_u8Username = 0;
     9c6:	1a 82       	std	Y+2, r1	; 0x02
    
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     9c8:	11 e0       	ldi	r17, 0x01	; 1
     9ca:	18 c0       	rjmp	.+48     	; 0x9fc <HC05_UserNamePasswordExist+0x52>
    {
        /*Read the users' usernames currently in EEPROM and check if entered username matches one of them*/
        Internal_EEPROM_ReadByte((HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index)) , &Loc_u8Username);
     9cc:	81 2f       	mov	r24, r17
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	88 0f       	add	r24, r24
     9d2:	99 1f       	adc	r25, r25
     9d4:	88 0f       	add	r24, r24
     9d6:	99 1f       	adc	r25, r25
     9d8:	be 01       	movw	r22, r28
     9da:	6e 5f       	subi	r22, 0xFE	; 254
     9dc:	7f 4f       	sbci	r23, 0xFF	; 255
     9de:	c2 96       	adiw	r24, 0x32	; 50
     9e0:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
        if(glbl_u8AdminUserUsername == Loc_u8Username)
     9e4:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
     9e8:	8a 81       	ldd	r24, Y+2	; 0x02
     9ea:	98 13       	cpse	r25, r24
     9ec:	06 c0       	rjmp	.+12     	; 0x9fa <HC05_UserNamePasswordExist+0x50>
        {
            /*User entered already exists in EEPROM*/
            UART_TxString("Sorry, User Already Exists");
     9ee:	84 ed       	ldi	r24, 0xD4	; 212
     9f0:	91 e0       	ldi	r25, 0x01	; 1
     9f2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
            return HC05_USER_EXIST;
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	05 c0       	rjmp	.+10     	; 0xa04 <HC05_UserNamePasswordExist+0x5a>
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);

    u8 Loc_u8Index = 0;
    u8 Loc_u8Username = 0;
    
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     9fa:	1f 5f       	subi	r17, 0xFF	; 255
     9fc:	89 81       	ldd	r24, Y+1	; 0x01
     9fe:	18 17       	cp	r17, r24
     a00:	28 f3       	brcs	.-54     	; 0x9cc <HC05_UserNamePasswordExist+0x22>
            UART_TxString("Sorry, User Already Exists");
            return HC05_USER_EXIST;
        }
    }
    /*Means that the username entered is not found in EEPROM*/
    return HC05_USER_NOT_EXIST;
     a02:	82 e0       	ldi	r24, 0x02	; 2
}
     a04:	0f 90       	pop	r0
     a06:	0f 90       	pop	r0
     a08:	df 91       	pop	r29
     a0a:	cf 91       	pop	r28
     a0c:	1f 91       	pop	r17
     a0e:	08 95       	ret

00000a10 <HC05_AddNewUser>:
/**
 * @brief: Function to add new user to EEPROM
 * 
 */
void HC05_AddNewUser(void)
{
     a10:	0f 93       	push	r16
     a12:	1f 93       	push	r17
     a14:	cf 93       	push	r28
     a16:	df 93       	push	r29
     a18:	1f 92       	push	r1
     a1a:	cd b7       	in	r28, 0x3d	; 61
     a1c:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8NoOfUsers = 0;
     a1e:	19 82       	std	Y+1, r1	; 0x01
    /*Read number of users/admin from the EEPROM*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     a20:	be 01       	movw	r22, r28
     a22:	6f 5f       	subi	r22, 0xFF	; 255
     a24:	7f 4f       	sbci	r23, 0xFF	; 255
     a26:	8a e0       	ldi	r24, 0x0A	; 10
     a28:	90 e0       	ldi	r25, 0x00	; 0
     a2a:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>

    /*Set the address to be the last address not accessed by system*/
    /*We add the user at the end*/
    u8 Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8NoOfUsers);
     a2e:	09 81       	ldd	r16, Y+1	; 0x01
     a30:	00 0f       	add	r16, r16
     a32:	00 0f       	add	r16, r16
     a34:	82 e3       	ldi	r24, 0x32	; 50
     a36:	80 0f       	add	r24, r16
    
    /*we enter the new username in the empty place in EEPROM*/
    Internal_EEPROM_WriteByte((Loc_u8Address), glbl_u8AdminUserUsername);
     a38:	60 91 91 07 	lds	r22, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>
    
    u8 Loc_u8Index = 0;

    /*We increment the address so that it points to the new user password address*/
    Loc_u8Address ++;
     a42:	0d 5c       	subi	r16, 0xCD	; 205

    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     a44:	10 e0       	ldi	r17, 0x00	; 0
     a46:	0b c0       	rjmp	.+22     	; 0xa5e <HC05_AddNewUser+0x4e>
    {
        /*We enter the new user password in memory*/
        Internal_EEPROM_WriteByte((Loc_u8Address + Loc_u8Index), glbl_u8AdminUserPassword[Loc_u8Index]);
     a48:	81 2f       	mov	r24, r17
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	fc 01       	movw	r30, r24
     a4e:	e2 57       	subi	r30, 0x72	; 114
     a50:	f8 4f       	sbci	r31, 0xF8	; 248
     a52:	60 81       	ld	r22, Z
     a54:	80 0f       	add	r24, r16
     a56:	91 1d       	adc	r25, r1
     a58:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>
    u8 Loc_u8Index = 0;

    /*We increment the address so that it points to the new user password address*/
    Loc_u8Address ++;

    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     a5c:	1f 5f       	subi	r17, 0xFF	; 255
     a5e:	13 30       	cpi	r17, 0x03	; 3
     a60:	98 f3       	brcs	.-26     	; 0xa48 <HC05_AddNewUser+0x38>
        /*We enter the new user password in memory*/
        Internal_EEPROM_WriteByte((Loc_u8Address + Loc_u8Index), glbl_u8AdminUserPassword[Loc_u8Index]);
    }

    /*Increase the number of users by one and saving the new number of users*/
    Loc_u8NoOfUsers++;
     a62:	69 81       	ldd	r22, Y+1	; 0x01
     a64:	6f 5f       	subi	r22, 0xFF	; 255
     a66:	69 83       	std	Y+1, r22	; 0x01
    Internal_EEPROM_WriteByte(HC05_NO_USERS_MEM_ADDRESS, Loc_u8NoOfUsers);
     a68:	8a e0       	ldi	r24, 0x0A	; 10
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>
    UART_TxString("User Successfully added");
     a70:	8f ee       	ldi	r24, 0xEF	; 239
     a72:	91 e0       	ldi	r25, 0x01	; 1
     a74:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
}
     a78:	0f 90       	pop	r0
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	1f 91       	pop	r17
     a80:	0f 91       	pop	r16
     a82:	08 95       	ret

00000a84 <HC05_DeleteUser>:
/**
 * @brief: Function to delete a user from the EEPROM
 * 
 */
void HC05_DeleteUser(void)
{
     a84:	ef 92       	push	r14
     a86:	ff 92       	push	r15
     a88:	0f 93       	push	r16
     a8a:	1f 93       	push	r17
     a8c:	cf 93       	push	r28
     a8e:	df 93       	push	r29
     a90:	00 d0       	rcall	.+0      	; 0xa92 <HC05_DeleteUser+0xe>
     a92:	1f 92       	push	r1
     a94:	cd b7       	in	r28, 0x3d	; 61
     a96:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8NoOfUsers = 0;
     a98:	19 82       	std	Y+1, r1	; 0x01
    u8 Loc_u8Index = 0;
    u8 Loc_u8UserIndex = 0;
    u8 Loc_u8UserName = 0;
     a9a:	1a 82       	std	Y+2, r1	; 0x02
    u8 Loc_u8Address = 0;

    /*Read the number of users/admin from EEPROM*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     a9c:	be 01       	movw	r22, r28
     a9e:	6f 5f       	subi	r22, 0xFF	; 255
     aa0:	7f 4f       	sbci	r23, 0xFF	; 255
     aa2:	8a e0       	ldi	r24, 0x0A	; 10
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
    
    /*Check to see if the username entered exists or not*/
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     aaa:	11 e0       	ldi	r17, 0x01	; 1
     aac:	10 c0       	rjmp	.+32     	; 0xace <HC05_DeleteUser+0x4a>
    {
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index);
     aae:	81 2f       	mov	r24, r17
     ab0:	88 0f       	add	r24, r24
     ab2:	88 0f       	add	r24, r24
     ab4:	8e 5c       	subi	r24, 0xCE	; 206
        Internal_EEPROM_ReadByte(Loc_u8Address, &Loc_u8UserName);
     ab6:	be 01       	movw	r22, r28
     ab8:	6e 5f       	subi	r22, 0xFE	; 254
     aba:	7f 4f       	sbci	r23, 0xFF	; 255
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
        if(Loc_u8UserName == glbl_u8AdminUserUsername)
     ac2:	9a 81       	ldd	r25, Y+2	; 0x02
     ac4:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
     ac8:	98 17       	cp	r25, r24
     aca:	29 f0       	breq	.+10     	; 0xad6 <HC05_DeleteUser+0x52>

    /*Read the number of users/admin from EEPROM*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
    
    /*Check to see if the username entered exists or not*/
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     acc:	1f 5f       	subi	r17, 0xFF	; 255
     ace:	89 81       	ldd	r24, Y+1	; 0x01
     ad0:	18 17       	cp	r17, r24
     ad2:	68 f3       	brcs	.-38     	; 0xaae <HC05_DeleteUser+0x2a>
 */
void HC05_DeleteUser(void)
{
    u8 Loc_u8NoOfUsers = 0;
    u8 Loc_u8Index = 0;
    u8 Loc_u8UserIndex = 0;
     ad4:	10 e0       	ldi	r17, 0x00	; 0
            /*We take the user index and save it to be used in the delete operation*/
            Loc_u8UserIndex = Loc_u8Index; 
            break;
        }
    }
    if(Loc_u8UserIndex != 0)
     ad6:	11 23       	and	r17, r17
     ad8:	29 f1       	breq	.+74     	; 0xb24 <HC05_DeleteUser+0xa0>
    {
        /*User is found in EEPROM*/
        u8 Loc_u8SwapVariable = 0;
     ada:	1b 82       	std	Y+3, r1	; 0x03
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8UserIndex); //Address of user to be deleted
     adc:	01 2f       	mov	r16, r17
     ade:	00 0f       	add	r16, r16
     ae0:	00 0f       	add	r16, r16
     ae2:	0e 5c       	subi	r16, 0xCE	; 206

        /*Here, we don't literally delete the user from memory, we just overwrite on it with the next in line user's 
        data and we repeat that until all the data are in line and the user to be deleted data is removed*/ 
        for(Loc_u8Index = Loc_u8UserIndex; Loc_u8Index < (Loc_u8NoOfUsers * 4); Loc_u8Index++)
     ae4:	0f c0       	rjmp	.+30     	; 0xb04 <HC05_DeleteUser+0x80>
        {
            /*We here get the data from the address + 4 'user size + password size'  and put it in the address*/
            Internal_EEPROM_ReadByte((Loc_u8Address + 4), &Loc_u8SwapVariable);
     ae6:	e0 2e       	mov	r14, r16
     ae8:	f1 2c       	mov	r15, r1
     aea:	be 01       	movw	r22, r28
     aec:	6d 5f       	subi	r22, 0xFD	; 253
     aee:	7f 4f       	sbci	r23, 0xFF	; 255
     af0:	c7 01       	movw	r24, r14
     af2:	04 96       	adiw	r24, 0x04	; 4
     af4:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
            Internal_EEPROM_WriteByte(Loc_u8Address, Loc_u8SwapVariable);
     af8:	6b 81       	ldd	r22, Y+3	; 0x03
     afa:	c7 01       	movw	r24, r14
     afc:	0e 94 92 09 	call	0x1324	; 0x1324 <Internal_EEPROM_WriteByte>
            Loc_u8Address++;
     b00:	0f 5f       	subi	r16, 0xFF	; 255
        u8 Loc_u8SwapVariable = 0;
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8UserIndex); //Address of user to be deleted

        /*Here, we don't literally delete the user from memory, we just overwrite on it with the next in line user's 
        data and we repeat that until all the data are in line and the user to be deleted data is removed*/ 
        for(Loc_u8Index = Loc_u8UserIndex; Loc_u8Index < (Loc_u8NoOfUsers * 4); Loc_u8Index++)
     b02:	1f 5f       	subi	r17, 0xFF	; 255
     b04:	21 2f       	mov	r18, r17
     b06:	30 e0       	ldi	r19, 0x00	; 0
     b08:	89 81       	ldd	r24, Y+1	; 0x01
     b0a:	90 e0       	ldi	r25, 0x00	; 0
     b0c:	88 0f       	add	r24, r24
     b0e:	99 1f       	adc	r25, r25
     b10:	88 0f       	add	r24, r24
     b12:	99 1f       	adc	r25, r25
     b14:	28 17       	cp	r18, r24
     b16:	39 07       	cpc	r19, r25
     b18:	34 f3       	brlt	.-52     	; 0xae6 <HC05_DeleteUser+0x62>
            /*We here get the data from the address + 4 'user size + password size'  and put it in the address*/
            Internal_EEPROM_ReadByte((Loc_u8Address + 4), &Loc_u8SwapVariable);
            Internal_EEPROM_WriteByte(Loc_u8Address, Loc_u8SwapVariable);
            Loc_u8Address++;
        }
        UART_TxString("User Successfully Deleted");
     b1a:	87 e0       	ldi	r24, 0x07	; 7
     b1c:	92 e0       	ldi	r25, 0x02	; 2
     b1e:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
     b22:	04 c0       	rjmp	.+8      	; 0xb2c <HC05_DeleteUser+0xa8>
    }
    else
    {
        /*User is not found in EEPROM*/
        UART_TxString("Sorry. User Not Found");
     b24:	81 e2       	ldi	r24, 0x21	; 33
     b26:	92 e0       	ldi	r25, 0x02	; 2
     b28:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    }
}
     b2c:	0f 90       	pop	r0
     b2e:	0f 90       	pop	r0
     b30:	0f 90       	pop	r0
     b32:	df 91       	pop	r29
     b34:	cf 91       	pop	r28
     b36:	1f 91       	pop	r17
     b38:	0f 91       	pop	r16
     b3a:	ff 90       	pop	r15
     b3c:	ef 90       	pop	r14
     b3e:	08 95       	ret

00000b40 <HC05_AdminUserInterface>:
/**
 * @brief: Function to organize the operation of user/admin
 * 
 */
void HC05_AdminUserInterface(void)
{
     b40:	1f 93       	push	r17
     b42:	cf 93       	push	r28
     b44:	df 93       	push	r29
     b46:	1f 92       	push	r1
     b48:	cd b7       	in	r28, 0x3d	; 61
     b4a:	de b7       	in	r29, 0x3e	; 62
    /*Here is the main function of HC05 Bluetooth module. It organizes the operations in the form of states*/
    switch(glbl_u8CurrentScreen)
     b4c:	e0 91 8c 07 	lds	r30, 0x078C	; 0x80078c <glbl_u8CurrentScreen>
     b50:	8e 2f       	mov	r24, r30
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	fc 01       	movw	r30, r24
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	ed 30       	cpi	r30, 0x0D	; 13
     b5a:	f1 05       	cpc	r31, r1
     b5c:	08 f0       	brcs	.+2      	; 0xb60 <HC05_AdminUserInterface+0x20>
     b5e:	36 c3       	rjmp	.+1644   	; 0x11cc <HC05_AdminUserInterface+0x68c>
     b60:	e6 5d       	subi	r30, 0xD6	; 214
     b62:	ff 4f       	sbci	r31, 0xFF	; 255
     b64:	0c 94 f0 12 	jmp	0x25e0	; 0x25e0 <__tablejump2__>
    {
        case HC05_WELCOME_SCREEN:
        {
            /*Here, We get the user choice whether it is an admin or a user and save it*/
            //UART_RxString(glbl_u8AdminUserChoice);
            u8 Loc_u8AdminUserChoice = 0;
     b68:	19 82       	std	Y+1, r1	; 0x01
            UART_RxCharAsynchronous(&Loc_u8AdminUserChoice);
     b6a:	ce 01       	movw	r24, r28
     b6c:	01 96       	adiw	r24, 0x01	; 1
     b6e:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(Loc_u8AdminUserChoice);
     b72:	89 81       	ldd	r24, Y+1	; 0x01
     b74:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
     b78:	8d e0       	ldi	r24, 0x0D	; 13
     b7a:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            /*Then, we check for the user's input*/
			if('1' == Loc_u8AdminUserChoice)
     b7e:	89 81       	ldd	r24, Y+1	; 0x01
     b80:	81 33       	cpi	r24, 0x31	; 49
     b82:	79 f4       	brne	.+30     	; 0xba2 <HC05_AdminUserInterface+0x62>
			{
                /*Means that the user has chosen to enter as an admin*/
				glbl_u8AdminMode = ADMIN_MODE_ON;
     b84:	81 e0       	ldi	r24, 0x01	; 1
     b86:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <glbl_u8AdminMode>
				UART_TxString("Hello Admin");
     b8a:	87 e3       	ldi	r24, 0x37	; 55
     b8c:	92 e0       	ldi	r25, 0x02	; 2
     b8e:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
				UART_TxString("Please enter your username: ");
     b92:	83 e4       	ldi	r24, 0x43	; 67
     b94:	92 e0       	ldi	r25, 0x02	; 2
     b96:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>

                /*We here switch the state to be login username screen*/
				glbl_u8CurrentScreen = HC05_LOGIN_USERNAME_SCREEN;
     b9a:	82 e0       	ldi	r24, 0x02	; 2
     b9c:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     ba0:	15 c3       	rjmp	.+1578   	; 0x11cc <HC05_AdminUserInterface+0x68c>
			}
			else if('2' == Loc_u8AdminUserChoice)
     ba2:	82 33       	cpi	r24, 0x32	; 50
     ba4:	79 f4       	brne	.+30     	; 0xbc4 <HC05_AdminUserInterface+0x84>
			{
                /*Means that the user has chosen to enter as an admin*/
				glbl_u8UserMode = USER_MODE_ON;
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <glbl_u8UserMode>
				UART_TxString("Hello User");
     bac:	80 e6       	ldi	r24, 0x60	; 96
     bae:	92 e0       	ldi	r25, 0x02	; 2
     bb0:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
				UART_TxString("Please enter your username: ");
     bb4:	83 e4       	ldi	r24, 0x43	; 67
     bb6:	92 e0       	ldi	r25, 0x02	; 2
     bb8:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>

                /*We here switch the state to be login username screen*/
				glbl_u8CurrentScreen = HC05_LOGIN_USERNAME_SCREEN;
     bbc:	82 e0       	ldi	r24, 0x02	; 2
     bbe:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     bc2:	04 c3       	rjmp	.+1544   	; 0x11cc <HC05_AdminUserInterface+0x68c>
			}
			else
			{
                /*User has entered a wrong input*/
                UART_TxString("Sorry, Wrong Input");
     bc4:	86 e1       	ldi	r24, 0x16	; 22
     bc6:	91 e0       	ldi	r25, 0x01	; 1
     bc8:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                HC05_WelcomeMessage();
     bcc:	0e 94 cf 03 	call	0x79e	; 0x79e <HC05_WelcomeMessage>
     bd0:	fd c2       	rjmp	.+1530   	; 0x11cc <HC05_AdminUserInterface+0x68c>
			break;
		}
        case HC05_LOGIN_USERNAME_SCREEN:
        {
            /*Here, we receive the entered login username*/
            UART_RxCharAsynchronous(&glbl_u8AdminUserUsername);
     bd2:	81 e9       	ldi	r24, 0x91	; 145
     bd4:	97 e0       	ldi	r25, 0x07	; 7
     bd6:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(glbl_u8AdminUserUsername);
     bda:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
     bde:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
     be2:	8d e0       	ldi	r24, 0x0D	; 13
     be4:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
			UART_TxString("Please enter your password");
     be8:	8b e6       	ldi	r24, 0x6B	; 107
     bea:	92 e0       	ldi	r25, 0x02	; 2
     bec:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>

            /*Then, we switch the state to be the login password screen*/
            glbl_u8CurrentScreen = HC05_LOGIN_PASSWORD_SCREEN;
     bf0:	83 e0       	ldi	r24, 0x03	; 3
     bf2:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
            break;
     bf6:	ea c2       	rjmp	.+1492   	; 0x11cc <HC05_AdminUserInterface+0x68c>
        }
        case HC05_LOGIN_PASSWORD_SCREEN:
        {
            static u8 Loc_u8PasswordIndex = 0;
            /*Here, we receive the entered login password*/
            UART_RxCharAsynchronous(&glbl_u8AdminUserPassword[Loc_u8PasswordIndex]);
     bf8:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <Loc_u8PasswordIndex.1997>
     bfc:	90 e0       	ldi	r25, 0x00	; 0
     bfe:	82 57       	subi	r24, 0x72	; 114
     c00:	98 4f       	sbci	r25, 0xF8	; 248
     c02:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(glbl_u8AdminUserPassword[Loc_u8PasswordIndex]);
     c06:	e0 91 87 07 	lds	r30, 0x0787	; 0x800787 <Loc_u8PasswordIndex.1997>
     c0a:	f0 e0       	ldi	r31, 0x00	; 0
     c0c:	e2 57       	subi	r30, 0x72	; 114
     c0e:	f8 4f       	sbci	r31, 0xF8	; 248
     c10:	80 81       	ld	r24, Z
     c12:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            Loc_u8PasswordIndex++;
     c16:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <Loc_u8PasswordIndex.1997>
     c1a:	8f 5f       	subi	r24, 0xFF	; 255
     c1c:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <Loc_u8PasswordIndex.1997>
            if(Loc_u8PasswordIndex == HC05_PASSWD_SIZE)
     c20:	83 30       	cpi	r24, 0x03	; 3
     c22:	09 f0       	breq	.+2      	; 0xc26 <HC05_AdminUserInterface+0xe6>
     c24:	d3 c2       	rjmp	.+1446   	; 0x11cc <HC05_AdminUserInterface+0x68c>
            {
                UART_TxChar(HC05_NEW_LINE_CHAR);
     c26:	8d e0       	ldi	r24, 0x0D	; 13
     c28:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
                /*We check if the entered username and password are correct or not*/
                u8 Loc_u8UserPassCheck = HC05_UsernamePasswordCheck();
     c2c:	0e 94 ff 03 	call	0x7fe	; 0x7fe <HC05_UsernamePasswordCheck>

                if(Loc_u8UserPassCheck == HC05_USERNAME_PASSOWRD_CORRECT)
     c30:	81 30       	cpi	r24, 0x01	; 1
     c32:	b9 f4       	brne	.+46     	; 0xc62 <HC05_AdminUserInterface+0x122>
                {
                    /*Means that the entered username and password are correct*/
                    if(glbl_u8AdminMode == ADMIN_MODE_ON)
     c34:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <glbl_u8AdminMode>
     c38:	81 30       	cpi	r24, 0x01	; 1
     c3a:	21 f4       	brne	.+8      	; 0xc44 <HC05_AdminUserInterface+0x104>
                    {
                        glbl_u8AdminMode = ADMIN_LOGGED_ON;
     c3c:	87 e0       	ldi	r24, 0x07	; 7
     c3e:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <glbl_u8AdminMode>
     c42:	07 c0       	rjmp	.+14     	; 0xc52 <HC05_AdminUserInterface+0x112>
                    }
                    else if(glbl_u8UserMode == USER_MODE_ON)
     c44:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <glbl_u8UserMode>
     c48:	81 30       	cpi	r24, 0x01	; 1
     c4a:	19 f4       	brne	.+6      	; 0xc52 <HC05_AdminUserInterface+0x112>
                    {
                        glbl_u8UserMode = USER_LOGGED_ON;
     c4c:	87 e0       	ldi	r24, 0x07	; 7
     c4e:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <glbl_u8UserMode>
                    else
                    {
                        /*Do nothing*/
                    }
                    /*Here, we show the user/admin the list of choices to choose from*/
                    HC05_AdminUserChoiceList();
     c52:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                    /*Then, we switch the state*/
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     c56:	84 e0       	ldi	r24, 0x04	; 4
     c58:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                    Loc_u8PasswordIndex = 0;
     c5c:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <Loc_u8PasswordIndex.1997>
     c60:	10 c0       	rjmp	.+32     	; 0xc82 <HC05_AdminUserInterface+0x142>
			    else
			    {
                    /*Means that the entered username or password or both is incorrect*/
                    /*We count the number of failed trials so that if the number of failed trials is 3*/
                    /*We fire an alarm and reset the whole operation*/
			    	Loc_u8PasswordIndex = 0;
     c62:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <Loc_u8PasswordIndex.1997>
                    glbl_u8UserPasswordWrongCount++;
     c66:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <glbl_u8UserPasswordWrongCount>
     c6a:	8f 5f       	subi	r24, 0xFF	; 255
     c6c:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <glbl_u8UserPasswordWrongCount>
			    	if (glbl_u8UserPasswordWrongCount != 3)
     c70:	83 30       	cpi	r24, 0x03	; 3
     c72:	21 f0       	breq	.+8      	; 0xc7c <HC05_AdminUserInterface+0x13c>
			    	{
			    		UART_TxString("Please enter your username");
     c74:	86 e8       	ldi	r24, 0x86	; 134
     c76:	92 e0       	ldi	r25, 0x02	; 2
     c78:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
			    	}
                    glbl_u8CurrentScreen = HC05_LOGIN_USERNAME_SCREEN;
     c7c:	82 e0       	ldi	r24, 0x02	; 2
     c7e:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
			    }
			    if(glbl_u8UserPasswordWrongCount == 3)
     c82:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <glbl_u8UserPasswordWrongCount>
     c86:	83 30       	cpi	r24, 0x03	; 3
     c88:	09 f0       	breq	.+2      	; 0xc8c <HC05_AdminUserInterface+0x14c>
     c8a:	a0 c2       	rjmp	.+1344   	; 0x11cc <HC05_AdminUserInterface+0x68c>
			    {
                    /*number of failed trials = 3*/
                    /*Fire Alarm*/
			    	BUZZER_On();
     c8c:	0e 94 c6 00 	call	0x18c	; 0x18c <BUZZER_On>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c90:	2f ef       	ldi	r18, 0xFF	; 255
     c92:	8b e7       	ldi	r24, 0x7B	; 123
     c94:	92 e9       	ldi	r25, 0x92	; 146
     c96:	21 50       	subi	r18, 0x01	; 1
     c98:	80 40       	sbci	r24, 0x00	; 0
     c9a:	90 40       	sbci	r25, 0x00	; 0
     c9c:	e1 f7       	brne	.-8      	; 0xc96 <HC05_AdminUserInterface+0x156>
     c9e:	00 c0       	rjmp	.+0      	; 0xca0 <HC05_AdminUserInterface+0x160>
     ca0:	00 00       	nop
			    	_delay_ms(3000);
			    	BUZZER_Off();
     ca2:	0e 94 cc 00 	call	0x198	; 0x198 <BUZZER_Off>

                    /*Reset System ---------------------------------->*/
			    	HC05_WelcomeMessage();
     ca6:	0e 94 cf 03 	call	0x79e	; 0x79e <HC05_WelcomeMessage>
                    glbl_u8AdminMode = ADMIN_MODE_OFF;
     caa:	10 92 93 07 	sts	0x0793, r1	; 0x800793 <glbl_u8AdminMode>
                    glbl_u8UserMode = USER_MODE_OFF;
     cae:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <glbl_u8UserMode>
			    	glbl_u8UserPasswordWrongCount = 0;
     cb2:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <glbl_u8UserPasswordWrongCount>
     cb6:	8a c2       	rjmp	.+1300   	; 0x11cc <HC05_AdminUserInterface+0x68c>
            break;
        }
		case HC05_SERVICES_SCREEN:
		{
            /*We receive the user/Admin service choice*/
            u8 Loc_u8AdminUserChoice = 0;
     cb8:	19 82       	std	Y+1, r1	; 0x01
			UART_RxCharAsynchronous(&Loc_u8AdminUserChoice);
     cba:	ce 01       	movw	r24, r28
     cbc:	01 96       	adiw	r24, 0x01	; 1
     cbe:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(Loc_u8AdminUserChoice);
     cc2:	89 81       	ldd	r24, Y+1	; 0x01
     cc4:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
     cc8:	8d e0       	ldi	r24, 0x0D	; 13
     cca:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            if('1' == Loc_u8AdminUserChoice)
     cce:	89 81       	ldd	r24, Y+1	; 0x01
     cd0:	81 33       	cpi	r24, 0x31	; 49
     cd2:	01 f5       	brne	.+64     	; 0xd14 <HC05_AdminUserInterface+0x1d4>
            {
                /*Means the User or admin wants to control door but only admin can control it*/
                if(glbl_u8AdminMode == ADMIN_LOGGED_ON)
     cd4:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <glbl_u8AdminMode>
     cd8:	87 30       	cpi	r24, 0x07	; 7
     cda:	81 f4       	brne	.+32     	; 0xcfc <HC05_AdminUserInterface+0x1bc>
                {
                    UART_TxString("Please select the type of operation you wish to do:");
     cdc:	81 ea       	ldi	r24, 0xA1	; 161
     cde:	92 e0       	ldi	r25, 0x02	; 2
     ce0:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
					UART_TxString("1: Open Door");
     ce4:	85 ed       	ldi	r24, 0xD5	; 213
     ce6:	92 e0       	ldi	r25, 0x02	; 2
     ce8:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("2: Close Door");
     cec:	82 ee       	ldi	r24, 0xE2	; 226
     cee:	92 e0       	ldi	r25, 0x02	; 2
     cf0:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    glbl_u8CurrentScreen = HC05_DOOR_CONTROL;
     cf4:	88 e0       	ldi	r24, 0x08	; 8
     cf6:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     cfa:	68 c2       	rjmp	.+1232   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if(glbl_u8UserMode == USER_LOGGED_ON)
     cfc:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <glbl_u8UserMode>
     d00:	87 30       	cpi	r24, 0x07	; 7
     d02:	09 f0       	breq	.+2      	; 0xd06 <HC05_AdminUserInterface+0x1c6>
     d04:	63 c2       	rjmp	.+1222   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                {
                    UART_TxString("Sorry. Only Admin is allowed to control door");
     d06:	80 ef       	ldi	r24, 0xF0	; 240
     d08:	92 e0       	ldi	r25, 0x02	; 2
     d0a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    HC05_AdminUserChoiceList();
     d0e:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
     d12:	5c c2       	rjmp	.+1208   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                else
                {
                    /*Do nothing*/
                }
            }
            else if('2' == Loc_u8AdminUserChoice) 
     d14:	82 33       	cpi	r24, 0x32	; 50
     d16:	31 f4       	brne	.+12     	; 0xd24 <HC05_AdminUserInterface+0x1e4>
            {
                /*Means that the user/admin wants to control LEDs*/
                HC05_AdminUserLEDChoice();
     d18:	0e 94 c4 04 	call	0x988	; 0x988 <HC05_AdminUserLEDChoice>
                glbl_u8CurrentScreen = HC05_LEDS_CHOICE;
     d1c:	85 e0       	ldi	r24, 0x05	; 5
     d1e:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     d22:	54 c2       	rjmp	.+1192   	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            else if('3' == Loc_u8AdminUserChoice)
     d24:	83 33       	cpi	r24, 0x33	; 51
     d26:	c1 f4       	brne	.+48     	; 0xd58 <HC05_AdminUserInterface+0x218>
            {
                /*Means that the user/admin wants to add a new user*/
                if(glbl_u8AdminMode == ADMIN_LOGGED_ON)
     d28:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <glbl_u8AdminMode>
     d2c:	87 30       	cpi	r24, 0x07	; 7
     d2e:	41 f4       	brne	.+16     	; 0xd40 <HC05_AdminUserInterface+0x200>
                {
                    /*Admin wants to add a new user "Allowed"*/
					UART_TxString("Please Enter the new user's ID(max.9)");
     d30:	8d e1       	ldi	r24, 0x1D	; 29
     d32:	93 e0       	ldi	r25, 0x03	; 3
     d34:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    glbl_u8CurrentScreen = HC05_ADD_USER_USERNAME_SCREEN;
     d38:	89 e0       	ldi	r24, 0x09	; 9
     d3a:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     d3e:	46 c2       	rjmp	.+1164   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if(glbl_u8UserMode == USER_LOGGED_ON)
     d40:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <glbl_u8UserMode>
     d44:	87 30       	cpi	r24, 0x07	; 7
     d46:	09 f0       	breq	.+2      	; 0xd4a <HC05_AdminUserInterface+0x20a>
     d48:	41 c2       	rjmp	.+1154   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                {
                    /*Admin wants to add a new user "NOT Allowed"*/
                    UART_TxString("Sorry. Only Admin is allowed to create new user");
     d4a:	83 e4       	ldi	r24, 0x43	; 67
     d4c:	93 e0       	ldi	r25, 0x03	; 3
     d4e:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    HC05_AdminUserChoiceList();
     d52:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
     d56:	3a c2       	rjmp	.+1140   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                else
                {
                    /*Do nothing*/
                }
            }
            else if('4' == Loc_u8AdminUserChoice)
     d58:	84 33       	cpi	r24, 0x34	; 52
     d5a:	c1 f4       	brne	.+48     	; 0xd8c <HC05_AdminUserInterface+0x24c>
            {
                /*Means that the user/admin wants to delete a user*/
                if(glbl_u8AdminMode == ADMIN_LOGGED_ON)
     d5c:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <glbl_u8AdminMode>
     d60:	87 30       	cpi	r24, 0x07	; 7
     d62:	41 f4       	brne	.+16     	; 0xd74 <HC05_AdminUserInterface+0x234>
                {
                    /*Admin wants to delete a user "Allowed"*/
					UART_TxString("Please enter the user's ID that you wish to delete");
     d64:	83 e7       	ldi	r24, 0x73	; 115
     d66:	93 e0       	ldi	r25, 0x03	; 3
     d68:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    glbl_u8CurrentScreen = HC05_DELETE_USER_SCREEN;
     d6c:	8b e0       	ldi	r24, 0x0B	; 11
     d6e:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     d72:	2c c2       	rjmp	.+1112   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if(glbl_u8UserMode == USER_LOGGED_ON)
     d74:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <glbl_u8UserMode>
     d78:	87 30       	cpi	r24, 0x07	; 7
     d7a:	09 f0       	breq	.+2      	; 0xd7e <HC05_AdminUserInterface+0x23e>
     d7c:	27 c2       	rjmp	.+1102   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                {
                    /*User wants to delete a  user "NOT Allowed"*/
                    UART_TxString("Sorry. Only Admin is allowed to delete a user");
     d7e:	86 ea       	ldi	r24, 0xA6	; 166
     d80:	93 e0       	ldi	r25, 0x03	; 3
     d82:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    HC05_AdminUserChoiceList();
     d86:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
     d8a:	20 c2       	rjmp	.+1088   	; 0x11cc <HC05_AdminUserInterface+0x68c>
                else
                {
                    /*Do nothing*/
                }
            }
            else if('5' == Loc_u8AdminUserChoice)
     d8c:	85 33       	cpi	r24, 0x35	; 53
     d8e:	79 f4       	brne	.+30     	; 0xdae <HC05_AdminUserInterface+0x26e>
            {
                /*Means that the user/admin wants to log out*/
                glbl_u8AdminMode = ADMIN_MODE_OFF;
     d90:	10 92 93 07 	sts	0x0793, r1	; 0x800793 <glbl_u8AdminMode>
                glbl_u8UserMode = USER_MODE_OFF;
     d94:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <glbl_u8UserMode>
                glbl_u8PreviousScreen = 0;
     d98:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <glbl_u8PreviousScreen>
                glbl_u8LEDChoice = 0;
     d9c:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <glbl_u8LEDChoice>
                UART_TxString("Logged Out Successfully");
     da0:	84 ed       	ldi	r24, 0xD4	; 212
     da2:	93 e0       	ldi	r25, 0x03	; 3
     da4:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                HC05_WelcomeMessage();
     da8:	0e 94 cf 03 	call	0x79e	; 0x79e <HC05_WelcomeMessage>
     dac:	0f c2       	rjmp	.+1054   	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            else
            {
                UART_TxString("Sorry,Wrong Input");
     dae:	8c ee       	ldi	r24, 0xEC	; 236
     db0:	93 e0       	ldi	r25, 0x03	; 3
     db2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                HC05_AdminUserChoiceList();
     db6:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
     dba:	08 c2       	rjmp	.+1040   	; 0x11cc <HC05_AdminUserInterface+0x68c>
		}
        case HC05_DOOR_CONTROL:
        {
            /*The Admin wants to control door*/
            /*We receive the admin response whether he wants to open or close the door*/
            u8 Loc_u8AdminUserChoice = 0;
     dbc:	19 82       	std	Y+1, r1	; 0x01
            UART_RxCharAsynchronous(&Loc_u8AdminUserChoice);
     dbe:	ce 01       	movw	r24, r28
     dc0:	01 96       	adiw	r24, 0x01	; 1
     dc2:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(Loc_u8AdminUserChoice);
     dc6:	89 81       	ldd	r24, Y+1	; 0x01
     dc8:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
     dcc:	8d e0       	ldi	r24, 0x0D	; 13
     dce:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            if('1' == Loc_u8AdminUserChoice)
     dd2:	89 81       	ldd	r24, Y+1	; 0x01
     dd4:	81 33       	cpi	r24, 0x31	; 49
     dd6:	a9 f4       	brne	.+42     	; 0xe02 <HC05_AdminUserInterface+0x2c2>
            {
                /*Admin wants to open door "Set the angle of the servo motor to be 0 degrees"*/
                TMR_Timer1Stop();
     dd8:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <TMR_Timer1Stop>
                SRVM_SetRotationAngle(SRVM_ANGLE_POSITIVE, 0);
     ddc:	60 e0       	ldi	r22, 0x00	; 0
     dde:	81 e0       	ldi	r24, 0x01	; 1
     de0:	0e 94 a6 0c 	call	0x194c	; 0x194c <SRVM_SetRotationAngle>
                TMR_Timer1Start();
     de4:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <TMR_Timer1Start>
                UART_TxString("Door Opened Successfully");
     de8:	8e ef       	ldi	r24, 0xFE	; 254
     dea:	93 e0       	ldi	r25, 0x03	; 3
     dec:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                HC05_AdminUserChoiceList();
     df0:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     df4:	84 e0       	ldi	r24, 0x04	; 4
     df6:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                glbl_u8DoorStatus = DOOR_OPENED;
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	80 93 88 07 	sts	0x0788, r24	; 0x800788 <glbl_u8DoorStatus>
     e00:	e5 c1       	rjmp	.+970    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            else if('2' == Loc_u8AdminUserChoice) //Close Door
     e02:	82 33       	cpi	r24, 0x32	; 50
     e04:	a1 f4       	brne	.+40     	; 0xe2e <HC05_AdminUserInterface+0x2ee>
            {
                /*Admin wants to close door "Set the angle of the servo motor to be -90 degrees"*/
                TMR_Timer1Stop();
     e06:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <TMR_Timer1Stop>
                SRVM_SetRotationAngle(SRVM_ANGLE_NEGATIVE, 90);
     e0a:	6a e5       	ldi	r22, 0x5A	; 90
     e0c:	82 e0       	ldi	r24, 0x02	; 2
     e0e:	0e 94 a6 0c 	call	0x194c	; 0x194c <SRVM_SetRotationAngle>
                TMR_Timer1Start();
     e12:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <TMR_Timer1Start>
                UART_TxString("Door Closed Successfully");
     e16:	87 e1       	ldi	r24, 0x17	; 23
     e18:	94 e0       	ldi	r25, 0x04	; 4
     e1a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                HC05_AdminUserChoiceList();
     e1e:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     e22:	84 e0       	ldi	r24, 0x04	; 4
     e24:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                glbl_u8DoorStatus = DOOR_CLOSED;
     e28:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <glbl_u8DoorStatus>
     e2c:	cf c1       	rjmp	.+926    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            else
            {
                /*Admin has entered wrong input*/
                UART_TxString("Sorry, Wrong Input");
     e2e:	86 e1       	ldi	r24, 0x16	; 22
     e30:	91 e0       	ldi	r25, 0x01	; 1
     e32:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("Please select the type of operation you wish to do:");
     e36:	81 ea       	ldi	r24, 0xA1	; 161
     e38:	92 e0       	ldi	r25, 0x02	; 2
     e3a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
				UART_TxString("1: Open Door");
     e3e:	85 ed       	ldi	r24, 0xD5	; 213
     e40:	92 e0       	ldi	r25, 0x02	; 2
     e42:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("2: Close Door");
     e46:	82 ee       	ldi	r24, 0xE2	; 226
     e48:	92 e0       	ldi	r25, 0x02	; 2
     e4a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
     e4e:	be c1       	rjmp	.+892    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            break;
        }
        case HC05_LEDS_CHOICE:
        {
            /*User/Admin wants to control leds*/
            u8 Loc_u8AdminUserChoice = 0;
     e50:	19 82       	std	Y+1, r1	; 0x01
            UART_RxCharAsynchronous(&Loc_u8AdminUserChoice);
     e52:	ce 01       	movw	r24, r28
     e54:	01 96       	adiw	r24, 0x01	; 1
     e56:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(Loc_u8AdminUserChoice);
     e5a:	89 81       	ldd	r24, Y+1	; 0x01
     e5c:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
     e60:	8d e0       	ldi	r24, 0x0D	; 13
     e62:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            if('1' == Loc_u8AdminUserChoice)
     e66:	89 81       	ldd	r24, Y+1	; 0x01
     e68:	81 33       	cpi	r24, 0x31	; 49
     e6a:	79 f4       	brne	.+30     	; 0xe8a <HC05_AdminUserInterface+0x34a>
            {
                /*User/Admin wants to control LED 1*/
                glbl_u8LEDChoice = HC05_LED_1_CHOICE;
     e6c:	81 e0       	ldi	r24, 0x01	; 1
     e6e:	80 93 8b 07 	sts	0x078B, r24	; 0x80078b <glbl_u8LEDChoice>
                UART_TxString("1: LED 1 On");
     e72:	80 e3       	ldi	r24, 0x30	; 48
     e74:	94 e0       	ldi	r25, 0x04	; 4
     e76:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("2: LED 1 Off");
     e7a:	8c e3       	ldi	r24, 0x3C	; 60
     e7c:	94 e0       	ldi	r25, 0x04	; 4
     e7e:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                glbl_u8CurrentScreen = HC05_LEDS_CONTROL;
     e82:	86 e0       	ldi	r24, 0x06	; 6
     e84:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     e88:	a1 c1       	rjmp	.+834    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            else if('2' == Loc_u8AdminUserChoice)
     e8a:	82 33       	cpi	r24, 0x32	; 50
     e8c:	79 f4       	brne	.+30     	; 0xeac <HC05_AdminUserInterface+0x36c>
            {
                /*User/Admin wants to control LED 2*/
                glbl_u8LEDChoice = HC05_LED_2_CHOICE;
     e8e:	82 e0       	ldi	r24, 0x02	; 2
     e90:	80 93 8b 07 	sts	0x078B, r24	; 0x80078b <glbl_u8LEDChoice>
                UART_TxString("1: LED 2 On");
     e94:	89 e4       	ldi	r24, 0x49	; 73
     e96:	94 e0       	ldi	r25, 0x04	; 4
     e98:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("2: LED 2 Off");
     e9c:	85 e5       	ldi	r24, 0x55	; 85
     e9e:	94 e0       	ldi	r25, 0x04	; 4
     ea0:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                glbl_u8CurrentScreen = HC05_LEDS_CONTROL;
     ea4:	86 e0       	ldi	r24, 0x06	; 6
     ea6:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     eaa:	90 c1       	rjmp	.+800    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            else if('3' == Loc_u8AdminUserChoice)
     eac:	83 33       	cpi	r24, 0x33	; 51
     eae:	11 f5       	brne	.+68     	; 0xef4 <HC05_AdminUserInterface+0x3b4>
            {
                /*User/Admin wants to control Dimming LED*/
                glbl_u8LEDChoice = HC05_DIMMING_LED_CHOICE;
     eb0:	16 e0       	ldi	r17, 0x06	; 6
     eb2:	10 93 8b 07 	sts	0x078B, r17	; 0x80078b <glbl_u8LEDChoice>
                UART_TxString("Please Choose the brightness of LED");
     eb6:	82 e6       	ldi	r24, 0x62	; 98
     eb8:	94 e0       	ldi	r25, 0x04	; 4
     eba:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("1: 0%");
     ebe:	86 e8       	ldi	r24, 0x86	; 134
     ec0:	94 e0       	ldi	r25, 0x04	; 4
     ec2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("2: 20%");
     ec6:	8c e8       	ldi	r24, 0x8C	; 140
     ec8:	94 e0       	ldi	r25, 0x04	; 4
     eca:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("3: 40%");
     ece:	83 e9       	ldi	r24, 0x93	; 147
     ed0:	94 e0       	ldi	r25, 0x04	; 4
     ed2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("4: 60%");
     ed6:	8a e9       	ldi	r24, 0x9A	; 154
     ed8:	94 e0       	ldi	r25, 0x04	; 4
     eda:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("5: 80%");
     ede:	81 ea       	ldi	r24, 0xA1	; 161
     ee0:	94 e0       	ldi	r25, 0x04	; 4
     ee2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                UART_TxString("6: 100%");
     ee6:	88 ea       	ldi	r24, 0xA8	; 168
     ee8:	94 e0       	ldi	r25, 0x04	; 4
     eea:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                glbl_u8CurrentScreen = HC05_LEDS_CONTROL;
     eee:	10 93 8c 07 	sts	0x078C, r17	; 0x80078c <glbl_u8CurrentScreen>
     ef2:	6c c1       	rjmp	.+728    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            else
            {
                /*Admin/User has entered wrong input*/
                UART_TxString("Sorry, Wrong Input");
     ef4:	86 e1       	ldi	r24, 0x16	; 22
     ef6:	91 e0       	ldi	r25, 0x01	; 1
     ef8:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                HC05_AdminUserLEDChoice();
     efc:	0e 94 c4 04 	call	0x988	; 0x988 <HC05_AdminUserLEDChoice>
     f00:	65 c1       	rjmp	.+714    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            }
            break;
        }
        case HC05_LEDS_CONTROL:
        {
            u8 Loc_u8AdminUserChoice = 0;
     f02:	19 82       	std	Y+1, r1	; 0x01
            UART_RxCharAsynchronous(&Loc_u8AdminUserChoice);
     f04:	ce 01       	movw	r24, r28
     f06:	01 96       	adiw	r24, 0x01	; 1
     f08:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(Loc_u8AdminUserChoice);
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
     f12:	8d e0       	ldi	r24, 0x0D	; 13
     f14:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            if(HC05_LED_1_CHOICE == glbl_u8LEDChoice)
     f18:	80 91 8b 07 	lds	r24, 0x078B	; 0x80078b <glbl_u8LEDChoice>
     f1c:	81 30       	cpi	r24, 0x01	; 1
     f1e:	71 f5       	brne	.+92     	; 0xf7c <HC05_AdminUserInterface+0x43c>
            {
                if('1' == Loc_u8AdminUserChoice)
     f20:	89 81       	ldd	r24, Y+1	; 0x01
     f22:	81 33       	cpi	r24, 0x31	; 49
     f24:	71 f4       	brne	.+28     	; 0xf42 <HC05_AdminUserInterface+0x402>
                {
                    /*Admin/User wants to turn on LED 1*/
                    LED_On(HC05_LED_1_PORT_ID, HC05_LED_1_PIN_ID);
     f26:	62 e0       	ldi	r22, 0x02	; 2
     f28:	82 e0       	ldi	r24, 0x02	; 2
     f2a:	0e 94 96 0b 	call	0x172c	; 0x172c <LED_On>
                    UART_TxString("LED 1 Turned On Successfully");
     f2e:	80 eb       	ldi	r24, 0xB0	; 176
     f30:	94 e0       	ldi	r25, 0x04	; 4
     f32:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    HC05_AdminUserChoiceList();
     f36:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     f3a:	84 e0       	ldi	r24, 0x04	; 4
     f3c:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     f40:	45 c1       	rjmp	.+650    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if('2' == Loc_u8AdminUserChoice)
     f42:	82 33       	cpi	r24, 0x32	; 50
     f44:	71 f4       	brne	.+28     	; 0xf62 <HC05_AdminUserInterface+0x422>
                {
                    /*Admin/User wants to turn off LED 1*/
                    LED_Off(HC05_LED_1_PORT_ID, HC05_LED_1_PIN_ID);
     f46:	62 e0       	ldi	r22, 0x02	; 2
     f48:	82 e0       	ldi	r24, 0x02	; 2
     f4a:	0e 94 c0 0b 	call	0x1780	; 0x1780 <LED_Off>
                    UART_TxString("LED 1 Turned Off Successfully");
     f4e:	8d ec       	ldi	r24, 0xCD	; 205
     f50:	94 e0       	ldi	r25, 0x04	; 4
     f52:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    HC05_AdminUserChoiceList();
     f56:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     f5a:	84 e0       	ldi	r24, 0x04	; 4
     f5c:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     f60:	35 c1       	rjmp	.+618    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else
                {
                    /*Admin/User has entered wrong input*/
                    UART_TxString("Sorry, Wrong Input");
     f62:	86 e1       	ldi	r24, 0x16	; 22
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("1: LED 1 On");
     f6a:	80 e3       	ldi	r24, 0x30	; 48
     f6c:	94 e0       	ldi	r25, 0x04	; 4
     f6e:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("2: LED 1 Off");
     f72:	8c e3       	ldi	r24, 0x3C	; 60
     f74:	94 e0       	ldi	r25, 0x04	; 4
     f76:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
     f7a:	28 c1       	rjmp	.+592    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
            }
            else if(HC05_LED_2_CHOICE == glbl_u8LEDChoice)
     f7c:	82 30       	cpi	r24, 0x02	; 2
     f7e:	71 f5       	brne	.+92     	; 0xfdc <HC05_AdminUserInterface+0x49c>
            {
                if('1' == Loc_u8AdminUserChoice)
     f80:	89 81       	ldd	r24, Y+1	; 0x01
     f82:	81 33       	cpi	r24, 0x31	; 49
     f84:	71 f4       	brne	.+28     	; 0xfa2 <HC05_AdminUserInterface+0x462>
                {
                    /*Admin/User wants to turn on LED 2*/
                    LED_On(HC05_LED_2_PORT_ID, HC05_LED_2_PIN_ID);
     f86:	67 e0       	ldi	r22, 0x07	; 7
     f88:	82 e0       	ldi	r24, 0x02	; 2
     f8a:	0e 94 96 0b 	call	0x172c	; 0x172c <LED_On>
                    UART_TxString("LED 2 Turned On Successfully");
     f8e:	8b ee       	ldi	r24, 0xEB	; 235
     f90:	94 e0       	ldi	r25, 0x04	; 4
     f92:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    HC05_AdminUserChoiceList();
     f96:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     f9a:	84 e0       	ldi	r24, 0x04	; 4
     f9c:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     fa0:	15 c1       	rjmp	.+554    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if('2' == Loc_u8AdminUserChoice)
     fa2:	82 33       	cpi	r24, 0x32	; 50
     fa4:	71 f4       	brne	.+28     	; 0xfc2 <HC05_AdminUserInterface+0x482>
                {
                    /*Admin/User wants to turn off LED 2*/
                    LED_Off(HC05_LED_2_PORT_ID, HC05_LED_2_PIN_ID);
     fa6:	67 e0       	ldi	r22, 0x07	; 7
     fa8:	82 e0       	ldi	r24, 0x02	; 2
     faa:	0e 94 c0 0b 	call	0x1780	; 0x1780 <LED_Off>
                    UART_TxString("LED 2 Turned Off Successfully");
     fae:	88 e0       	ldi	r24, 0x08	; 8
     fb0:	95 e0       	ldi	r25, 0x05	; 5
     fb2:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    HC05_AdminUserChoiceList();
     fb6:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     fba:	84 e0       	ldi	r24, 0x04	; 4
     fbc:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
     fc0:	05 c1       	rjmp	.+522    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else
                {
                    /*Admin/User has entered wrong input*/
                    UART_TxString("Sorry, Wrong Input");
     fc2:	86 e1       	ldi	r24, 0x16	; 22
     fc4:	91 e0       	ldi	r25, 0x01	; 1
     fc6:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("1: LED 2 On");
     fca:	89 e4       	ldi	r24, 0x49	; 73
     fcc:	94 e0       	ldi	r25, 0x04	; 4
     fce:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("2: LED 2 Off");
     fd2:	85 e5       	ldi	r24, 0x55	; 85
     fd4:	94 e0       	ldi	r25, 0x04	; 4
     fd6:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
     fda:	f8 c0       	rjmp	.+496    	; 0x11cc <HC05_AdminUserInterface+0x68c>
				}
            }
            else if(HC05_DIMMING_LED_CHOICE == glbl_u8LEDChoice)
     fdc:	86 30       	cpi	r24, 0x06	; 6
     fde:	09 f0       	breq	.+2      	; 0xfe2 <HC05_AdminUserInterface+0x4a2>
     fe0:	f5 c0       	rjmp	.+490    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            {
                if('1' == Loc_u8AdminUserChoice)
     fe2:	89 81       	ldd	r24, Y+1	; 0x01
     fe4:	81 33       	cpi	r24, 0x31	; 49
     fe6:	79 f4       	brne	.+30     	; 0x1006 <HC05_AdminUserInterface+0x4c6>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 0*/
                    TMR_Timer2Stop();
     fe8:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(0);
     fec:	80 e0       	ldi	r24, 0x00	; 0
     fee:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
                    TMR_Timer2Start();
     ff2:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
					HC05_AdminUserChoiceList();
     ff6:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     ffa:	84 e0       	ldi	r24, 0x04	; 4
     ffc:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                    glbl_u8DimmingLEDStatus = HC05_DIMMING_LED_0;
    1000:	10 92 89 07 	sts	0x0789, r1	; 0x800789 <glbl_u8DimmingLEDStatus>
    1004:	e3 c0       	rjmp	.+454    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if('2' == Loc_u8AdminUserChoice)
    1006:	82 33       	cpi	r24, 0x32	; 50
    1008:	81 f4       	brne	.+32     	; 0x102a <HC05_AdminUserInterface+0x4ea>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 20%*/
                    TMR_Timer2Stop();
    100a:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(20);
    100e:	84 e1       	ldi	r24, 0x14	; 20
    1010:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
                    TMR_Timer2Start();
    1014:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
					HC05_AdminUserChoiceList();
    1018:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    101c:	84 e0       	ldi	r24, 0x04	; 4
    101e:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                    glbl_u8DimmingLEDStatus = HC05_DIMMING_LED_20;
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <glbl_u8DimmingLEDStatus>
    1028:	d1 c0       	rjmp	.+418    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if('3' == Loc_u8AdminUserChoice)
    102a:	83 33       	cpi	r24, 0x33	; 51
    102c:	81 f4       	brne	.+32     	; 0x104e <HC05_AdminUserInterface+0x50e>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 40%*/
                    TMR_Timer2Stop();
    102e:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(40);
    1032:	88 e2       	ldi	r24, 0x28	; 40
    1034:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
                    TMR_Timer2Start();
    1038:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
					HC05_AdminUserChoiceList();
    103c:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    1040:	84 e0       	ldi	r24, 0x04	; 4
    1042:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                    glbl_u8DimmingLEDStatus = HC05_DIMMING_LED_40;
    1046:	82 e0       	ldi	r24, 0x02	; 2
    1048:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <glbl_u8DimmingLEDStatus>
    104c:	bf c0       	rjmp	.+382    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if('4' == Loc_u8AdminUserChoice)
    104e:	84 33       	cpi	r24, 0x34	; 52
    1050:	81 f4       	brne	.+32     	; 0x1072 <HC05_AdminUserInterface+0x532>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 60%*/
                    TMR_Timer2Stop();
    1052:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(60);
    1056:	8c e3       	ldi	r24, 0x3C	; 60
    1058:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
					TMR_Timer2Start();
    105c:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
                    HC05_AdminUserChoiceList();
    1060:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    1064:	84 e0       	ldi	r24, 0x04	; 4
    1066:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                    glbl_u8DimmingLEDStatus = HC05_DIMMING_LED_60;
    106a:	83 e0       	ldi	r24, 0x03	; 3
    106c:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <glbl_u8DimmingLEDStatus>
    1070:	ad c0       	rjmp	.+346    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if('5' == Loc_u8AdminUserChoice)
    1072:	85 33       	cpi	r24, 0x35	; 53
    1074:	79 f4       	brne	.+30     	; 0x1094 <HC05_AdminUserInterface+0x554>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 80%*/
                    TMR_Timer2Stop();
    1076:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(80);
    107a:	80 e5       	ldi	r24, 0x50	; 80
    107c:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
					TMR_Timer2Start();
    1080:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
                    HC05_AdminUserChoiceList();
    1084:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    1088:	84 e0       	ldi	r24, 0x04	; 4
    108a:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                    glbl_u8DimmingLEDStatus = HC05_DIMMING_LED_80;
    108e:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <glbl_u8DimmingLEDStatus>
    1092:	9c c0       	rjmp	.+312    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else if('6' == Loc_u8AdminUserChoice)
    1094:	86 33       	cpi	r24, 0x36	; 54
    1096:	81 f4       	brne	.+32     	; 0x10b8 <HC05_AdminUserInterface+0x578>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 100%*/
                    TMR_Timer2Stop();
    1098:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(100);
    109c:	84 e6       	ldi	r24, 0x64	; 100
    109e:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
                    TMR_Timer2Start();
    10a2:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
                    HC05_AdminUserChoiceList();
    10a6:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    10aa:	84 e0       	ldi	r24, 0x04	; 4
    10ac:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
                    glbl_u8DimmingLEDStatus = HC05_DIMMING_LED_100;
    10b0:	85 e0       	ldi	r24, 0x05	; 5
    10b2:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <glbl_u8DimmingLEDStatus>
    10b6:	8a c0       	rjmp	.+276    	; 0x11cc <HC05_AdminUserInterface+0x68c>
                }
                else
                {
                    UART_TxString("Sorry, Wrong Input");
    10b8:	86 e1       	ldi	r24, 0x16	; 22
    10ba:	91 e0       	ldi	r25, 0x01	; 1
    10bc:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("Please Choose the brightness of LED");
    10c0:	82 e6       	ldi	r24, 0x62	; 98
    10c2:	94 e0       	ldi	r25, 0x04	; 4
    10c4:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("1: 0%");
    10c8:	86 e8       	ldi	r24, 0x86	; 134
    10ca:	94 e0       	ldi	r25, 0x04	; 4
    10cc:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("2: 20%");
    10d0:	8c e8       	ldi	r24, 0x8C	; 140
    10d2:	94 e0       	ldi	r25, 0x04	; 4
    10d4:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("3: 40%");
    10d8:	83 e9       	ldi	r24, 0x93	; 147
    10da:	94 e0       	ldi	r25, 0x04	; 4
    10dc:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("4: 60%");
    10e0:	8a e9       	ldi	r24, 0x9A	; 154
    10e2:	94 e0       	ldi	r25, 0x04	; 4
    10e4:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("5: 80%");
    10e8:	81 ea       	ldi	r24, 0xA1	; 161
    10ea:	94 e0       	ldi	r25, 0x04	; 4
    10ec:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
                    UART_TxString("6: 100%");
    10f0:	88 ea       	ldi	r24, 0xA8	; 168
    10f2:	94 e0       	ldi	r25, 0x04	; 4
    10f4:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    10f8:	69 c0       	rjmp	.+210    	; 0x11cc <HC05_AdminUserInterface+0x68c>
        }
        case HC05_ADD_USER_USERNAME_SCREEN:
        {
            /*Admin wants to add new user*/
            /*First, we take the new user username from admin*/
            UART_RxCharAsynchronous(&glbl_u8AdminUserUsername);
    10fa:	81 e9       	ldi	r24, 0x91	; 145
    10fc:	97 e0       	ldi	r25, 0x07	; 7
    10fe:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(glbl_u8AdminUserUsername);
    1102:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
    1106:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
    110a:	8d e0       	ldi	r24, 0x0D	; 13
    110c:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxString("Please enter the new user's password:");
    1110:	86 e2       	ldi	r24, 0x26	; 38
    1112:	95 e0       	ldi	r25, 0x05	; 5
    1114:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
            glbl_u8CurrentScreen = HC05_ADD_USER_PASSWORD_SCREEN;
    1118:	8a e0       	ldi	r24, 0x0A	; 10
    111a:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
            break;
    111e:	56 c0       	rjmp	.+172    	; 0x11cc <HC05_AdminUserInterface+0x68c>
        }
        case HC05_ADD_USER_PASSWORD_SCREEN:
        {
            static u8 Loc_u8PasswordIndex = 0;
            /*Second, We take the new user password*/
            UART_RxCharAsynchronous(&glbl_u8AdminUserPassword[Loc_u8PasswordIndex]);
    1120:	80 91 86 07 	lds	r24, 0x0786	; 0x800786 <Loc_u8PasswordIndex.2009>
    1124:	90 e0       	ldi	r25, 0x00	; 0
    1126:	82 57       	subi	r24, 0x72	; 114
    1128:	98 4f       	sbci	r25, 0xF8	; 248
    112a:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(glbl_u8AdminUserPassword[Loc_u8PasswordIndex]);
    112e:	e0 91 86 07 	lds	r30, 0x0786	; 0x800786 <Loc_u8PasswordIndex.2009>
    1132:	f0 e0       	ldi	r31, 0x00	; 0
    1134:	e2 57       	subi	r30, 0x72	; 114
    1136:	f8 4f       	sbci	r31, 0xF8	; 248
    1138:	80 81       	ld	r24, Z
    113a:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            Loc_u8PasswordIndex++;
    113e:	80 91 86 07 	lds	r24, 0x0786	; 0x800786 <Loc_u8PasswordIndex.2009>
    1142:	8f 5f       	subi	r24, 0xFF	; 255
    1144:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <Loc_u8PasswordIndex.2009>
            if(Loc_u8PasswordIndex == HC05_PASSWD_SIZE)
    1148:	83 30       	cpi	r24, 0x03	; 3
    114a:	09 f0       	breq	.+2      	; 0x114e <HC05_AdminUserInterface+0x60e>
    114c:	3f c0       	rjmp	.+126    	; 0x11cc <HC05_AdminUserInterface+0x68c>
            {
                UART_TxChar(HC05_NEW_LINE_CHAR);
    114e:	8d e0       	ldi	r24, 0x0D	; 13
    1150:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
                /*Before we add the new user, we have to check if the user already exists or not*/
                u8 Loc_u8UserExistCheck = HC05_UserNamePasswordExist();
    1154:	0e 94 d5 04 	call	0x9aa	; 0x9aa <HC05_UserNamePasswordExist>
                if(Loc_u8UserExistCheck == HC05_USER_NOT_EXIST)
    1158:	82 30       	cpi	r24, 0x02	; 2
    115a:	11 f4       	brne	.+4      	; 0x1160 <HC05_AdminUserInterface+0x620>
                {
                    /*Means that the user doesn't exist in the EEPROM and we are ready to add it*/
                    HC05_AddNewUser();
    115c:	0e 94 08 05 	call	0xa10	; 0xa10 <HC05_AddNewUser>
                {
                    /*Means that the user already exists in the EEPROM and as a result, the new user will not be added*/
                    /*Already Handled in AddNewUser Function*/
                    /*Do nothing*/
                }
                HC05_AdminUserChoiceList();
    1160:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
                Loc_u8PasswordIndex = 0;
    1164:	10 92 86 07 	sts	0x0786, r1	; 0x800786 <Loc_u8PasswordIndex.2009>
                glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;            
    1168:	84 e0       	ldi	r24, 0x04	; 4
    116a:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
    116e:	2e c0       	rjmp	.+92     	; 0x11cc <HC05_AdminUserInterface+0x68c>
        }
        case HC05_DELETE_USER_SCREEN:
        {
            /*Admin wants to delete a user*/
            /*We take the user to be deleted username*/
            UART_RxCharAsynchronous(&glbl_u8AdminUserUsername);
    1170:	81 e9       	ldi	r24, 0x91	; 145
    1172:	97 e0       	ldi	r25, 0x07	; 7
    1174:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(glbl_u8AdminUserUsername);
    1178:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <glbl_u8AdminUserUsername>
    117c:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
    1180:	8d e0       	ldi	r24, 0x0D	; 13
    1182:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            /*And then delete it*/
            HC05_DeleteUser();
    1186:	0e 94 42 05 	call	0xa84	; 0xa84 <HC05_DeleteUser>
            HC05_AdminUserChoiceList();
    118a:	0e 94 a7 04 	call	0x94e	; 0x94e <HC05_AdminUserChoiceList>
            glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    118e:	84 e0       	ldi	r24, 0x04	; 4
    1190:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
            break;
    1194:	1b c0       	rjmp	.+54     	; 0x11cc <HC05_AdminUserInterface+0x68c>
        case HC05_LCD_KPD_SYS_REQUEST_SCREEN:
        {
            /*If User in the LCD/Keypad System wants to do something while admin is logged in, Admin must approve
            First 
            */
            u8 Loc_u8AdminUserChoice = 0;
    1196:	19 82       	std	Y+1, r1	; 0x01
            UART_RxCharAsynchronous(&Loc_u8AdminUserChoice);
    1198:	ce 01       	movw	r24, r28
    119a:	01 96       	adiw	r24, 0x01	; 1
    119c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <UART_RxCharAsynchronous>
            UART_TxChar(Loc_u8AdminUserChoice);
    11a0:	89 81       	ldd	r24, Y+1	; 0x01
    11a2:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            UART_TxChar(HC05_NEW_LINE_CHAR);
    11a6:	8d e0       	ldi	r24, 0x0D	; 13
    11a8:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
            if('1' == Loc_u8AdminUserChoice)
    11ac:	89 81       	ldd	r24, Y+1	; 0x01
    11ae:	81 33       	cpi	r24, 0x31	; 49
    11b0:	21 f4       	brne	.+8      	; 0x11ba <HC05_AdminUserInterface+0x67a>
            {
                /*Means that the admin approves*/
                glbl_u8AdminApproval = ADMIN_APPROVE;
    11b2:	81 e0       	ldi	r24, 0x01	; 1
    11b4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    11b8:	05 c0       	rjmp	.+10     	; 0x11c4 <HC05_AdminUserInterface+0x684>
            }
            else if('2' == Loc_u8AdminUserChoice)
    11ba:	82 33       	cpi	r24, 0x32	; 50
    11bc:	19 f4       	brne	.+6      	; 0x11c4 <HC05_AdminUserInterface+0x684>
            {
                /*Means that the admin disapproves*/
                glbl_u8AdminApproval = ADMIN_REFUSE;
    11be:	82 e0       	ldi	r24, 0x02	; 2
    11c0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
            }
            glbl_u8CurrentScreen = glbl_u8PreviousScreen;
    11c4:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <glbl_u8PreviousScreen>
    11c8:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
        {
            /*Do nothing*/
            break;
        }
    }
}
    11cc:	0f 90       	pop	r0
    11ce:	df 91       	pop	r29
    11d0:	cf 91       	pop	r28
    11d2:	1f 91       	pop	r17
    11d4:	08 95       	ret

000011d6 <HC05_ShowRunningDevices>:
/**
 * @brief: Function to show the running devices on LCD if the LCD-Keypad System is not used
 * 
 */
void HC05_ShowRunningDevices(void)
{
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	1f 92       	push	r1
    11dc:	cd b7       	in	r28, 0x3d	; 61
    11de:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8LEDStatus = 0;
    11e0:	19 82       	std	Y+1, r1	; 0x01
    DIO_ReadOutputPinValue(HC05_LED_1_PORT_ID, HC05_LED_1_PIN_ID, &Loc_u8LEDStatus);
    11e2:	ae 01       	movw	r20, r28
    11e4:	4f 5f       	subi	r20, 0xFF	; 255
    11e6:	5f 4f       	sbci	r21, 0xFF	; 255
    11e8:	62 e0       	ldi	r22, 0x02	; 2
    11ea:	82 e0       	ldi	r24, 0x02	; 2
    11ec:	0e 94 43 02 	call	0x486	; 0x486 <DIO_ReadOutputPinValue>
    if(Loc_u8LEDStatus == DIO_PIN_HIGH)
    11f0:	89 81       	ldd	r24, Y+1	; 0x01
    11f2:	81 30       	cpi	r24, 0x01	; 1
    11f4:	29 f4       	brne	.+10     	; 0x1200 <HC05_ShowRunningDevices+0x2a>
    {
        LCD_WriteString("LED 1: On");
    11f6:	8c e4       	ldi	r24, 0x4C	; 76
    11f8:	95 e0       	ldi	r25, 0x05	; 5
    11fa:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    11fe:	06 c0       	rjmp	.+12     	; 0x120c <HC05_ShowRunningDevices+0x36>
    }
    else if(Loc_u8LEDStatus == DIO_PIN_LOW)
    1200:	81 11       	cpse	r24, r1
    1202:	04 c0       	rjmp	.+8      	; 0x120c <HC05_ShowRunningDevices+0x36>
    {
        LCD_WriteString("LED 1: Off");
    1204:	86 e5       	ldi	r24, 0x56	; 86
    1206:	95 e0       	ldi	r25, 0x05	; 5
    1208:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    else
    {
        /*Do nothing*/
    }

    LCD_SetCursorPosition(LCD_SECOND_ROW, 0);
    120c:	60 e0       	ldi	r22, 0x00	; 0
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    
    DIO_ReadOutputPinValue(HC05_LED_2_PORT_ID, HC05_LED_2_PIN_ID, &Loc_u8LEDStatus);
    1214:	ae 01       	movw	r20, r28
    1216:	4f 5f       	subi	r20, 0xFF	; 255
    1218:	5f 4f       	sbci	r21, 0xFF	; 255
    121a:	67 e0       	ldi	r22, 0x07	; 7
    121c:	82 e0       	ldi	r24, 0x02	; 2
    121e:	0e 94 43 02 	call	0x486	; 0x486 <DIO_ReadOutputPinValue>
    if(Loc_u8LEDStatus == DIO_PIN_HIGH)
    1222:	89 81       	ldd	r24, Y+1	; 0x01
    1224:	81 30       	cpi	r24, 0x01	; 1
    1226:	29 f4       	brne	.+10     	; 0x1232 <HC05_ShowRunningDevices+0x5c>
    {
        LCD_WriteString("LED 2: On");
    1228:	81 e6       	ldi	r24, 0x61	; 97
    122a:	95 e0       	ldi	r25, 0x05	; 5
    122c:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    1230:	06 c0       	rjmp	.+12     	; 0x123e <HC05_ShowRunningDevices+0x68>
    }
    else if(Loc_u8LEDStatus == DIO_PIN_LOW)
    1232:	81 11       	cpse	r24, r1
    1234:	04 c0       	rjmp	.+8      	; 0x123e <HC05_ShowRunningDevices+0x68>
    {
        LCD_WriteString("LED 2: Off");
    1236:	8b e6       	ldi	r24, 0x6B	; 107
    1238:	95 e0       	ldi	r25, 0x05	; 5
    123a:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    123e:	2f ef       	ldi	r18, 0xFF	; 255
    1240:	83 ed       	ldi	r24, 0xD3	; 211
    1242:	90 e3       	ldi	r25, 0x30	; 48
    1244:	21 50       	subi	r18, 0x01	; 1
    1246:	80 40       	sbci	r24, 0x00	; 0
    1248:	90 40       	sbci	r25, 0x00	; 0
    124a:	e1 f7       	brne	.-8      	; 0x1244 <HC05_ShowRunningDevices+0x6e>
    124c:	00 c0       	rjmp	.+0      	; 0x124e <HC05_ShowRunningDevices+0x78>
    124e:	00 00       	nop
    {
        /*Do nothing*/
    }

    _delay_ms(1000);
    LCD_ClearDisplay();
    1250:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>


    switch(glbl_u8DimmingLEDStatus)
    1254:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <glbl_u8DimmingLEDStatus>
    1258:	82 30       	cpi	r24, 0x02	; 2
    125a:	b1 f0       	breq	.+44     	; 0x1288 <HC05_ShowRunningDevices+0xb2>
    125c:	28 f4       	brcc	.+10     	; 0x1268 <HC05_ShowRunningDevices+0x92>
    125e:	88 23       	and	r24, r24
    1260:	49 f0       	breq	.+18     	; 0x1274 <HC05_ShowRunningDevices+0x9e>
    1262:	81 30       	cpi	r24, 0x01	; 1
    1264:	61 f0       	breq	.+24     	; 0x127e <HC05_ShowRunningDevices+0xa8>
    1266:	23 c0       	rjmp	.+70     	; 0x12ae <HC05_ShowRunningDevices+0xd8>
    1268:	84 30       	cpi	r24, 0x04	; 4
    126a:	c1 f0       	breq	.+48     	; 0x129c <HC05_ShowRunningDevices+0xc6>
    126c:	90 f0       	brcs	.+36     	; 0x1292 <HC05_ShowRunningDevices+0xbc>
    126e:	85 30       	cpi	r24, 0x05	; 5
    1270:	d1 f0       	breq	.+52     	; 0x12a6 <HC05_ShowRunningDevices+0xd0>
    1272:	1d c0       	rjmp	.+58     	; 0x12ae <HC05_ShowRunningDevices+0xd8>
    {
        case HC05_DIMMING_LED_0:
        {
            LCD_WriteString("Dimming LED: 0%");
    1274:	86 e7       	ldi	r24, 0x76	; 118
    1276:	95 e0       	ldi	r25, 0x05	; 5
    1278:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
            break;
    127c:	18 c0       	rjmp	.+48     	; 0x12ae <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_20:
        {
            LCD_WriteString("Dimming LED: 20%");
    127e:	86 e8       	ldi	r24, 0x86	; 134
    1280:	95 e0       	ldi	r25, 0x05	; 5
    1282:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
            break;
    1286:	13 c0       	rjmp	.+38     	; 0x12ae <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_40:
        {
            LCD_WriteString("Dimming LED: 40%");
    1288:	87 e9       	ldi	r24, 0x97	; 151
    128a:	95 e0       	ldi	r25, 0x05	; 5
    128c:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
            break;
    1290:	0e c0       	rjmp	.+28     	; 0x12ae <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_60:
        {
            LCD_WriteString("Dimming LED: 60%");
    1292:	88 ea       	ldi	r24, 0xA8	; 168
    1294:	95 e0       	ldi	r25, 0x05	; 5
    1296:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
            break;
    129a:	09 c0       	rjmp	.+18     	; 0x12ae <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_80:
        {
            LCD_WriteString("Dimming LED: 80%");
    129c:	89 eb       	ldi	r24, 0xB9	; 185
    129e:	95 e0       	ldi	r25, 0x05	; 5
    12a0:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
            break;
    12a4:	04 c0       	rjmp	.+8      	; 0x12ae <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_100:
        {
            LCD_WriteString("Dimming LED:100%");
    12a6:	8a ec       	ldi	r24, 0xCA	; 202
    12a8:	95 e0       	ldi	r25, 0x05	; 5
    12aa:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
            /*Do nothing*/
            break;
        }
    }

    LCD_SetCursorPosition(LCD_SECOND_ROW, 0);
    12ae:	60 e0       	ldi	r22, 0x00	; 0
    12b0:	81 e0       	ldi	r24, 0x01	; 1
    12b2:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    
    if(glbl_u8DoorStatus == DOOR_CLOSED)
    12b6:	80 91 88 07 	lds	r24, 0x0788	; 0x800788 <glbl_u8DoorStatus>
    12ba:	81 11       	cpse	r24, r1
    12bc:	05 c0       	rjmp	.+10     	; 0x12c8 <HC05_ShowRunningDevices+0xf2>
    {
        LCD_WriteString("Door Closed");
    12be:	8b ed       	ldi	r24, 0xDB	; 219
    12c0:	95 e0       	ldi	r25, 0x05	; 5
    12c2:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    12c6:	06 c0       	rjmp	.+12     	; 0x12d4 <HC05_ShowRunningDevices+0xfe>
    }
    else if(glbl_u8DoorStatus == DOOR_OPENED)
    12c8:	81 30       	cpi	r24, 0x01	; 1
    12ca:	21 f4       	brne	.+8      	; 0x12d4 <HC05_ShowRunningDevices+0xfe>
    {
        LCD_WriteString("Door Opened");
    12cc:	87 ee       	ldi	r24, 0xE7	; 231
    12ce:	95 e0       	ldi	r25, 0x05	; 5
    12d0:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    12d4:	2f ef       	ldi	r18, 0xFF	; 255
    12d6:	83 ed       	ldi	r24, 0xD3	; 211
    12d8:	90 e3       	ldi	r25, 0x30	; 48
    12da:	21 50       	subi	r18, 0x01	; 1
    12dc:	80 40       	sbci	r24, 0x00	; 0
    12de:	90 40       	sbci	r25, 0x00	; 0
    12e0:	e1 f7       	brne	.-8      	; 0x12da <HC05_ShowRunningDevices+0x104>
    12e2:	00 c0       	rjmp	.+0      	; 0x12e4 <HC05_ShowRunningDevices+0x10e>
    12e4:	00 00       	nop
    else
    {
        /*Do nothing*/
    }
    _delay_ms(1000);
    LCD_ClearDisplay();
    12e6:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
}
    12ea:	0f 90       	pop	r0
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	08 95       	ret

000012f2 <HC05_AdminApproval>:
 * 
 * @return u8: Approval or Refuse 
 */
u8 HC05_AdminApproval(void)
{
    switch (glbl_u8AdminApproval)
    12f2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    12f6:	81 30       	cpi	r24, 0x01	; 1
    12f8:	19 f0       	breq	.+6      	; 0x1300 <HC05_AdminApproval+0xe>
    12fa:	82 30       	cpi	r24, 0x02	; 2
    12fc:	29 f0       	breq	.+10     	; 0x1308 <HC05_AdminApproval+0x16>
    12fe:	08 c0       	rjmp	.+16     	; 0x1310 <HC05_AdminApproval+0x1e>
    {
    case ADMIN_APPROVE:
        {
            glbl_u8AdminApproval = ADMIN_NOT_REPLIED;
    1300:	93 e0       	ldi	r25, 0x03	; 3
    1302:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
            return ADMIN_APPROVE;
    1306:	08 95       	ret
            break;
        }
    case ADMIN_REFUSE:
        {
            glbl_u8AdminApproval = ADMIN_NOT_REPLIED;
    1308:	93 e0       	ldi	r25, 0x03	; 3
    130a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
            return ADMIN_REFUSE;
    130e:	08 95       	ret
            break;
        }
    default:
        {
            return ADMIN_NOT_REPLIED;
    1310:	83 e0       	ldi	r24, 0x03	; 3
            break;
        }
    }
}
    1312:	08 95       	ret

00001314 <HC05_ScreenChangeToAdminResponse>:
 * @brief: Function to change the screen to admin response screen so that admin can choose to approve or disapprove
 * 
 */
void HC05_ScreenChangeToAdminResponse(void)
{
    glbl_u8PreviousScreen = glbl_u8CurrentScreen;
    1314:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <glbl_u8CurrentScreen>
    1318:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <glbl_u8PreviousScreen>
    glbl_u8CurrentScreen = HC05_LCD_KPD_SYS_REQUEST_SCREEN;
    131c:	8d e0       	ldi	r24, 0x0D	; 13
    131e:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <glbl_u8CurrentScreen>
    1322:	08 95       	ret

00001324 <Internal_EEPROM_WriteByte>:
 * @param Copy_u16ByteAddress: The EEPROM Byte Address in which the data byte will be stored
 * @param Copy_u8DataByte: The Data byte to be stored
 */
void Internal_EEPROM_WriteByte(u16 Copy_u16ByteAddress, u8 Copy_u8DataByte)
{
    if((Copy_u16ByteAddress >= 0) && (Copy_u16ByteAddress <= INTERNAL_EEPROM_MAX_ADDRESS))
    1324:	81 15       	cp	r24, r1
    1326:	24 e0       	ldi	r18, 0x04	; 4
    1328:	92 07       	cpc	r25, r18
    132a:	58 f4       	brcc	.+22     	; 0x1342 <Internal_EEPROM_WriteByte+0x1e>
    {
        /*Waiting for the previous write to be completed*/
        while(1 == GET_BIT(EECR, EEWE));
    132c:	e1 99       	sbic	0x1c, 1	; 28
    132e:	fe cf       	rjmp	.-4      	; 0x132c <Internal_EEPROM_WriteByte+0x8>

        /*Writing EEPROM Address in which we want to write the byte*/
        EEAR_u16 = Copy_u16ByteAddress;
    1330:	9f bb       	out	0x1f, r25	; 31
    1332:	8e bb       	out	0x1e, r24	; 30

        /*Writing the byte which we want to write*/
        EEDR = Copy_u8DataByte;
    1334:	6d bb       	out	0x1d, r22	; 29
        
        /*Setting EEMWE Bit in EECR Register to allow me to write in EEPROM*/
        /*By setting EEWE Bit in the EECR register*/
        EECR |= (1 << EEMWE);
    1336:	8c b3       	in	r24, 0x1c	; 28
    1338:	84 60       	ori	r24, 0x04	; 4
    133a:	8c bb       	out	0x1c, r24	; 28
		EECR |= (1 << EEWE); 
    133c:	8c b3       	in	r24, 0x1c	; 28
    133e:	82 60       	ori	r24, 0x02	; 2
    1340:	8c bb       	out	0x1c, r24	; 28
    1342:	08 95       	ret

00001344 <Internal_EEPROM_ReadByte>:
 * @param Copy_u16ByteAddress: The EEPROM Byte Address from which the data byte will be read
 * @param P_u8DataByte: Pointer to store the data byte read from EEPROM 
 */
void Internal_EEPROM_ReadByte(u16 Copy_u16ByteAddress, u8* P_u8DataByte)
{
    if(P_u8DataByte != NULL)
    1344:	61 15       	cp	r22, r1
    1346:	71 05       	cpc	r23, r1
    1348:	71 f0       	breq	.+28     	; 0x1366 <Internal_EEPROM_ReadByte+0x22>
    {
        if((Copy_u16ByteAddress >= 0) && (Copy_u16ByteAddress <= INTERNAL_EEPROM_MAX_ADDRESS))
    134a:	81 15       	cp	r24, r1
    134c:	24 e0       	ldi	r18, 0x04	; 4
    134e:	92 07       	cpc	r25, r18
    1350:	50 f4       	brcc	.+20     	; 0x1366 <Internal_EEPROM_ReadByte+0x22>
        {
            /*As we can't read from EEPROM while writing into it*/
            /*We have to wait for the previous write to be completed*/
            while(1 == GET_BIT(EECR, EEWE));
    1352:	e1 99       	sbic	0x1c, 1	; 28
    1354:	fe cf       	rjmp	.-4      	; 0x1352 <Internal_EEPROM_ReadByte+0xe>

            /*Writing EEPROM Address in which we want to read the byte stored*/
            EEAR_u16 = Copy_u16ByteAddress;
    1356:	9f bb       	out	0x1f, r25	; 31
    1358:	8e bb       	out	0x1e, r24	; 30
            
            /*Setting this bit will start the EEPROM Read operation*/
            EECR |= (1 << EERE);
    135a:	8c b3       	in	r24, 0x1c	; 28
    135c:	81 60       	ori	r24, 0x01	; 1
    135e:	8c bb       	out	0x1c, r24	; 28

            *P_u8DataByte = EEDR;
    1360:	8d b3       	in	r24, 0x1d	; 29
    1362:	fb 01       	movw	r30, r22
    1364:	80 83       	st	Z, r24
    1366:	08 95       	ret

00001368 <KPD_Init>:
 *         (Set the directions and the initial values of the pins connected to the keypad)
 * 
 */
void KPD_Init(void)
{
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL0_PIN, DIO_PIN_OUTPUT);
    1368:	41 e0       	ldi	r20, 0x01	; 1
    136a:	64 e0       	ldi	r22, 0x04	; 4
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL1_PIN, DIO_PIN_OUTPUT);
    1372:	41 e0       	ldi	r20, 0x01	; 1
    1374:	65 e0       	ldi	r22, 0x05	; 5
    1376:	81 e0       	ldi	r24, 0x01	; 1
    1378:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL2_PIN, DIO_PIN_OUTPUT);
    137c:	41 e0       	ldi	r20, 0x01	; 1
    137e:	66 e0       	ldi	r22, 0x06	; 6
    1380:	81 e0       	ldi	r24, 0x01	; 1
    1382:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL3_PIN, DIO_PIN_OUTPUT);
    1386:	41 e0       	ldi	r20, 0x01	; 1
    1388:	67 e0       	ldi	r22, 0x07	; 7
    138a:	81 e0       	ldi	r24, 0x01	; 1
    138c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>

    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW0_PIN, DIO_PIN_INPUT);
    1390:	40 e0       	ldi	r20, 0x00	; 0
    1392:	63 e0       	ldi	r22, 0x03	; 3
    1394:	82 e0       	ldi	r24, 0x02	; 2
    1396:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW1_PIN, DIO_PIN_INPUT);
    139a:	40 e0       	ldi	r20, 0x00	; 0
    139c:	64 e0       	ldi	r22, 0x04	; 4
    139e:	82 e0       	ldi	r24, 0x02	; 2
    13a0:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW2_PIN, DIO_PIN_INPUT);
    13a4:	40 e0       	ldi	r20, 0x00	; 0
    13a6:	65 e0       	ldi	r22, 0x05	; 5
    13a8:	82 e0       	ldi	r24, 0x02	; 2
    13aa:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW3_PIN, DIO_PIN_INPUT);
    13ae:	40 e0       	ldi	r20, 0x00	; 0
    13b0:	66 e0       	ldi	r22, 0x06	; 6
    13b2:	82 e0       	ldi	r24, 0x02	; 2
    13b4:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>

    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL0_PIN, DIO_PIN_HIGH);
    13b8:	41 e0       	ldi	r20, 0x01	; 1
    13ba:	64 e0       	ldi	r22, 0x04	; 4
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL1_PIN, DIO_PIN_HIGH);
    13c2:	41 e0       	ldi	r20, 0x01	; 1
    13c4:	65 e0       	ldi	r22, 0x05	; 5
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL2_PIN, DIO_PIN_HIGH);
    13cc:	41 e0       	ldi	r20, 0x01	; 1
    13ce:	66 e0       	ldi	r22, 0x06	; 6
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL3_PIN, DIO_PIN_HIGH);
    13d6:	41 e0       	ldi	r20, 0x01	; 1
    13d8:	67 e0       	ldi	r22, 0x07	; 7
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>

    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW0_PIN);
    13e0:	63 e0       	ldi	r22, 0x03	; 3
    13e2:	82 e0       	ldi	r24, 0x02	; 2
    13e4:	0e 94 ed 02 	call	0x5da	; 0x5da <DIO_ActivatePullUp>
    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW1_PIN);
    13e8:	64 e0       	ldi	r22, 0x04	; 4
    13ea:	82 e0       	ldi	r24, 0x02	; 2
    13ec:	0e 94 ed 02 	call	0x5da	; 0x5da <DIO_ActivatePullUp>
    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW2_PIN);
    13f0:	65 e0       	ldi	r22, 0x05	; 5
    13f2:	82 e0       	ldi	r24, 0x02	; 2
    13f4:	0e 94 ed 02 	call	0x5da	; 0x5da <DIO_ActivatePullUp>
    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW3_PIN);
    13f8:	66 e0       	ldi	r22, 0x06	; 6
    13fa:	82 e0       	ldi	r24, 0x02	; 2
    13fc:	0e 94 ed 02 	call	0x5da	; 0x5da <DIO_ActivatePullUp>
    1400:	08 95       	ret

00001402 <KPD_GetValue>:
 * @brief: Function to get the pressed button in the keypad
 * 
 * @param P_u8ReturnedValue: Pointer to put the pressed button in it 
 */
void KPD_GetValue(u8* P_u8ReturnedValue)
{
    1402:	9f 92       	push	r9
    1404:	af 92       	push	r10
    1406:	bf 92       	push	r11
    1408:	cf 92       	push	r12
    140a:	df 92       	push	r13
    140c:	ef 92       	push	r14
    140e:	ff 92       	push	r15
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	cf 93       	push	r28
    1416:	df 93       	push	r29
    1418:	cd b7       	in	r28, 0x3d	; 61
    141a:	de b7       	in	r29, 0x3e	; 62
    141c:	61 97       	sbiw	r28, 0x11	; 17
    141e:	0f b6       	in	r0, 0x3f	; 63
    1420:	f8 94       	cli
    1422:	de bf       	out	0x3e, r29	; 62
    1424:	0f be       	out	0x3f, r0	; 63
    1426:	cd bf       	out	0x3d, r28	; 61
    if(P_u8ReturnedValue != NULL)
    1428:	00 97       	sbiw	r24, 0x00	; 0
    142a:	09 f4       	brne	.+2      	; 0x142e <KPD_GetValue+0x2c>
    142c:	5e c0       	rjmp	.+188    	; 0x14ea <KPD_GetValue+0xe8>
    142e:	5c 01       	movw	r10, r24
    {
        u8 Loc_u8KPD_Keys[NO_COLUMNS][NO_ROWS] = {
    1430:	80 e1       	ldi	r24, 0x10	; 16
    1432:	e1 e6       	ldi	r30, 0x61	; 97
    1434:	f0 e0       	ldi	r31, 0x00	; 0
    1436:	de 01       	movw	r26, r28
    1438:	11 96       	adiw	r26, 0x01	; 1
    143a:	01 90       	ld	r0, Z+
    143c:	0d 92       	st	X+, r0
    143e:	8a 95       	dec	r24
    1440:	e1 f7       	brne	.-8      	; 0x143a <KPD_GetValue+0x38>
                                                    {'1', '2', '3', 'A'},
                                                    {'4', '5', '6', 'B'},
                                                    {'7', '8', '9', 'C'},
                                                    {'*', '0', '#', 'D'}
                                                };
		*P_u8ReturnedValue = KPD_NOT_PRESSED;
    1442:	8f ef       	ldi	r24, 0xFF	; 255
    1444:	f5 01       	movw	r30, r10
    1446:	80 83       	st	Z, r24
        u8 Loc_u8ColsCounter = 0, Loc_u8RowsCounter = 0, Loc_u8PinValue, Loc_u8PinFlag = 0;
    1448:	91 2c       	mov	r9, r1
        for(Loc_u8ColsCounter = 0; Loc_u8ColsCounter < NO_COLUMNS; Loc_u8ColsCounter++)
    144a:	00 e0       	ldi	r16, 0x00	; 0
    144c:	4b c0       	rjmp	.+150    	; 0x14e4 <KPD_GetValue+0xe2>
        {
            //Activate column
            DIO_SetPinValue(KPD_COLS_PORT, KPD_ColumnsPins[Loc_u8ColsCounter], DIO_PIN_LOW);
    144e:	c0 2e       	mov	r12, r16
    1450:	d1 2c       	mov	r13, r1
    1452:	f6 01       	movw	r30, r12
    1454:	e6 50       	subi	r30, 0x06	; 6
    1456:	fa 4f       	sbci	r31, 0xFA	; 250
    1458:	40 e0       	ldi	r20, 0x00	; 0
    145a:	60 81       	ld	r22, Z
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>

            /*Read the value of the rows and find the pressed button*/
            for(Loc_u8RowsCounter = 0; Loc_u8RowsCounter < NO_ROWS; Loc_u8RowsCounter++)
    1462:	10 e0       	ldi	r17, 0x00	; 0
    1464:	31 c0       	rjmp	.+98     	; 0x14c8 <KPD_GetValue+0xc6>
            {
                DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
    1466:	e1 2e       	mov	r14, r17
    1468:	f1 2c       	mov	r15, r1
    146a:	f7 01       	movw	r30, r14
    146c:	ea 50       	subi	r30, 0x0A	; 10
    146e:	fa 4f       	sbci	r31, 0xFA	; 250
    1470:	ae 01       	movw	r20, r28
    1472:	4f 5e       	subi	r20, 0xEF	; 239
    1474:	5f 4f       	sbci	r21, 0xFF	; 255
    1476:	60 81       	ld	r22, Z
    1478:	82 e0       	ldi	r24, 0x02	; 2
    147a:	0e 94 c8 01 	call	0x390	; 0x390 <DIO_ReadPinValue>
                if(KPD_PRESSED == Loc_u8PinValue)
    147e:	99 89       	ldd	r25, Y+17	; 0x11
    1480:	91 11       	cpse	r25, r1
    1482:	21 c0       	rjmp	.+66     	; 0x14c6 <KPD_GetValue+0xc4>
                {
                    *P_u8ReturnedValue = Loc_u8KPD_Keys[Loc_u8RowsCounter][Loc_u8ColsCounter];
    1484:	f7 01       	movw	r30, r14
    1486:	ee 0f       	add	r30, r30
    1488:	ff 1f       	adc	r31, r31
    148a:	ee 0f       	add	r30, r30
    148c:	ff 1f       	adc	r31, r31
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	8c 0f       	add	r24, r28
    1494:	9d 1f       	adc	r25, r29
    1496:	e8 0f       	add	r30, r24
    1498:	f9 1f       	adc	r31, r25
    149a:	ec 0d       	add	r30, r12
    149c:	fd 1d       	adc	r31, r13
    149e:	80 81       	ld	r24, Z
    14a0:	f5 01       	movw	r30, r10
    14a2:	80 83       	st	Z, r24
                    while(Loc_u8PinValue == 0)
    14a4:	0a c0       	rjmp	.+20     	; 0x14ba <KPD_GetValue+0xb8>
                    {
                        DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
    14a6:	ae 01       	movw	r20, r28
    14a8:	4f 5e       	subi	r20, 0xEF	; 239
    14aa:	5f 4f       	sbci	r21, 0xFF	; 255
    14ac:	f7 01       	movw	r30, r14
    14ae:	ea 50       	subi	r30, 0x0A	; 10
    14b0:	fa 4f       	sbci	r31, 0xFA	; 250
    14b2:	60 81       	ld	r22, Z
    14b4:	82 e0       	ldi	r24, 0x02	; 2
    14b6:	0e 94 c8 01 	call	0x390	; 0x390 <DIO_ReadPinValue>
            {
                DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
                if(KPD_PRESSED == Loc_u8PinValue)
                {
                    *P_u8ReturnedValue = Loc_u8KPD_Keys[Loc_u8RowsCounter][Loc_u8ColsCounter];
                    while(Loc_u8PinValue == 0)
    14ba:	89 89       	ldd	r24, Y+17	; 0x11
    14bc:	88 23       	and	r24, r24
    14be:	99 f3       	breq	.-26     	; 0x14a6 <KPD_GetValue+0xa4>
                    {
                        DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
                    }
                    Loc_u8PinFlag = 1;
    14c0:	99 24       	eor	r9, r9
    14c2:	93 94       	inc	r9
    14c4:	03 c0       	rjmp	.+6      	; 0x14cc <KPD_GetValue+0xca>
        {
            //Activate column
            DIO_SetPinValue(KPD_COLS_PORT, KPD_ColumnsPins[Loc_u8ColsCounter], DIO_PIN_LOW);

            /*Read the value of the rows and find the pressed button*/
            for(Loc_u8RowsCounter = 0; Loc_u8RowsCounter < NO_ROWS; Loc_u8RowsCounter++)
    14c6:	1f 5f       	subi	r17, 0xFF	; 255
    14c8:	14 30       	cpi	r17, 0x04	; 4
    14ca:	68 f2       	brcs	.-102    	; 0x1466 <KPD_GetValue+0x64>
                {
                    /*Do nothing*/
                }
            }
            //Deactivate column
            DIO_SetPinValue(KPD_COLS_PORT, KPD_ColumnsPins[Loc_u8ColsCounter], DIO_PIN_HIGH);
    14cc:	f6 01       	movw	r30, r12
    14ce:	e6 50       	subi	r30, 0x06	; 6
    14d0:	fa 4f       	sbci	r31, 0xFA	; 250
    14d2:	41 e0       	ldi	r20, 0x01	; 1
    14d4:	60 81       	ld	r22, Z
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>

            if(Loc_u8PinFlag == 1)
    14dc:	f1 e0       	ldi	r31, 0x01	; 1
    14de:	9f 16       	cp	r9, r31
    14e0:	21 f0       	breq	.+8      	; 0x14ea <KPD_GetValue+0xe8>
                                                    {'7', '8', '9', 'C'},
                                                    {'*', '0', '#', 'D'}
                                                };
		*P_u8ReturnedValue = KPD_NOT_PRESSED;
        u8 Loc_u8ColsCounter = 0, Loc_u8RowsCounter = 0, Loc_u8PinValue, Loc_u8PinFlag = 0;
        for(Loc_u8ColsCounter = 0; Loc_u8ColsCounter < NO_COLUMNS; Loc_u8ColsCounter++)
    14e2:	0f 5f       	subi	r16, 0xFF	; 255
    14e4:	04 30       	cpi	r16, 0x04	; 4
    14e6:	08 f4       	brcc	.+2      	; 0x14ea <KPD_GetValue+0xe8>
    14e8:	b2 cf       	rjmp	.-156    	; 0x144e <KPD_GetValue+0x4c>
    }
    else
    {
        /*Do nothing*/
    }
    14ea:	61 96       	adiw	r28, 0x11	; 17
    14ec:	0f b6       	in	r0, 0x3f	; 63
    14ee:	f8 94       	cli
    14f0:	de bf       	out	0x3e, r29	; 62
    14f2:	0f be       	out	0x3f, r0	; 63
    14f4:	cd bf       	out	0x3d, r28	; 61
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	1f 91       	pop	r17
    14fc:	0f 91       	pop	r16
    14fe:	ff 90       	pop	r15
    1500:	ef 90       	pop	r14
    1502:	df 90       	pop	r13
    1504:	cf 90       	pop	r12
    1506:	bf 90       	pop	r11
    1508:	af 90       	pop	r10
    150a:	9f 90       	pop	r9
    150c:	08 95       	ret

0000150e <LCD_Peek>:
        for(Loc_u8Index = 0; Loc_u8Index < Loc_u8Count; Loc_u8Index++)
        {
            LCD_WriteChar4Bit(Loc_u8CharArray[Loc_u8Count - Loc_u8Index - 1]);
        }
    }
}
    150e:	41 e0       	ldi	r20, 0x01	; 1
    1510:	63 e0       	ldi	r22, 0x03	; 3
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    1518:	8f e9       	ldi	r24, 0x9F	; 159
    151a:	9f e0       	ldi	r25, 0x0F	; 15
    151c:	01 97       	sbiw	r24, 0x01	; 1
    151e:	f1 f7       	brne	.-4      	; 0x151c <LCD_Peek+0xe>
    1520:	00 c0       	rjmp	.+0      	; 0x1522 <LCD_Peek+0x14>
    1522:	00 00       	nop
    1524:	40 e0       	ldi	r20, 0x00	; 0
    1526:	63 e0       	ldi	r22, 0x03	; 3
    1528:	81 e0       	ldi	r24, 0x01	; 1
    152a:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    152e:	08 95       	ret

00001530 <LCD_WriteCommand4Bit>:
    1530:	cf 93       	push	r28
    1532:	c8 2f       	mov	r28, r24
    1534:	40 e0       	ldi	r20, 0x00	; 0
    1536:	61 e0       	ldi	r22, 0x01	; 1
    1538:	81 e0       	ldi	r24, 0x01	; 1
    153a:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    153e:	40 e0       	ldi	r20, 0x00	; 0
    1540:	62 e0       	ldi	r22, 0x02	; 2
    1542:	81 e0       	ldi	r24, 0x01	; 1
    1544:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    1548:	8f e3       	ldi	r24, 0x3F	; 63
    154a:	9f e1       	ldi	r25, 0x1F	; 31
    154c:	01 97       	sbiw	r24, 0x01	; 1
    154e:	f1 f7       	brne	.-4      	; 0x154c <LCD_WriteCommand4Bit+0x1c>
    1550:	00 c0       	rjmp	.+0      	; 0x1552 <LCD_WriteCommand4Bit+0x22>
    1552:	00 00       	nop
    1554:	4c 2f       	mov	r20, r28
    1556:	42 95       	swap	r20
    1558:	4f 70       	andi	r20, 0x0F	; 15
    155a:	64 e0       	ldi	r22, 0x04	; 4
    155c:	80 e0       	ldi	r24, 0x00	; 0
    155e:	0e 94 be 02 	call	0x57c	; 0x57c <DIO_WriteHalfPort>
    1562:	8f e3       	ldi	r24, 0x3F	; 63
    1564:	9f e1       	ldi	r25, 0x1F	; 31
    1566:	01 97       	sbiw	r24, 0x01	; 1
    1568:	f1 f7       	brne	.-4      	; 0x1566 <LCD_WriteCommand4Bit+0x36>
    156a:	00 c0       	rjmp	.+0      	; 0x156c <LCD_WriteCommand4Bit+0x3c>
    156c:	00 00       	nop
    156e:	0e 94 87 0a 	call	0x150e	; 0x150e <LCD_Peek>
    1572:	8f e3       	ldi	r24, 0x3F	; 63
    1574:	9f e1       	ldi	r25, 0x1F	; 31
    1576:	01 97       	sbiw	r24, 0x01	; 1
    1578:	f1 f7       	brne	.-4      	; 0x1576 <LCD_WriteCommand4Bit+0x46>
    157a:	00 c0       	rjmp	.+0      	; 0x157c <LCD_WriteCommand4Bit+0x4c>
    157c:	00 00       	nop
    157e:	4c 2f       	mov	r20, r28
    1580:	4f 70       	andi	r20, 0x0F	; 15
    1582:	64 e0       	ldi	r22, 0x04	; 4
    1584:	80 e0       	ldi	r24, 0x00	; 0
    1586:	0e 94 be 02 	call	0x57c	; 0x57c <DIO_WriteHalfPort>
    158a:	8f e3       	ldi	r24, 0x3F	; 63
    158c:	9f e1       	ldi	r25, 0x1F	; 31
    158e:	01 97       	sbiw	r24, 0x01	; 1
    1590:	f1 f7       	brne	.-4      	; 0x158e <LCD_WriteCommand4Bit+0x5e>
    1592:	00 c0       	rjmp	.+0      	; 0x1594 <LCD_WriteCommand4Bit+0x64>
    1594:	00 00       	nop
    1596:	0e 94 87 0a 	call	0x150e	; 0x150e <LCD_Peek>
    159a:	8f e3       	ldi	r24, 0x3F	; 63
    159c:	9f e1       	ldi	r25, 0x1F	; 31
    159e:	01 97       	sbiw	r24, 0x01	; 1
    15a0:	f1 f7       	brne	.-4      	; 0x159e <LCD_WriteCommand4Bit+0x6e>
    15a2:	00 c0       	rjmp	.+0      	; 0x15a4 <LCD_WriteCommand4Bit+0x74>
    15a4:	00 00       	nop
    15a6:	cf 91       	pop	r28
    15a8:	08 95       	ret

000015aa <LCD_SetCursorPosition>:
    15aa:	82 30       	cpi	r24, 0x02	; 2
    15ac:	70 f4       	brcc	.+28     	; 0x15ca <LCD_SetCursorPosition+0x20>
    15ae:	60 31       	cpi	r22, 0x10	; 16
    15b0:	60 f4       	brcc	.+24     	; 0x15ca <LCD_SetCursorPosition+0x20>
    15b2:	88 23       	and	r24, r24
    15b4:	31 f0       	breq	.+12     	; 0x15c2 <LCD_SetCursorPosition+0x18>
    15b6:	81 30       	cpi	r24, 0x01	; 1
    15b8:	11 f0       	breq	.+4      	; 0x15be <LCD_SetCursorPosition+0x14>
    15ba:	80 e0       	ldi	r24, 0x00	; 0
    15bc:	03 c0       	rjmp	.+6      	; 0x15c4 <LCD_SetCursorPosition+0x1a>
    15be:	80 ec       	ldi	r24, 0xC0	; 192
    15c0:	01 c0       	rjmp	.+2      	; 0x15c4 <LCD_SetCursorPosition+0x1a>
    15c2:	80 e8       	ldi	r24, 0x80	; 128
    15c4:	86 0f       	add	r24, r22
    15c6:	0e 94 98 0a 	call	0x1530	; 0x1530 <LCD_WriteCommand4Bit>
    15ca:	08 95       	ret

000015cc <LCD_WriteChar4Bit>:
    15cc:	cf 93       	push	r28
    15ce:	c8 2f       	mov	r28, r24
    15d0:	41 e0       	ldi	r20, 0x01	; 1
    15d2:	61 e0       	ldi	r22, 0x01	; 1
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    15da:	40 e0       	ldi	r20, 0x00	; 0
    15dc:	62 e0       	ldi	r22, 0x02	; 2
    15de:	81 e0       	ldi	r24, 0x01	; 1
    15e0:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    15e4:	8f e3       	ldi	r24, 0x3F	; 63
    15e6:	9f e1       	ldi	r25, 0x1F	; 31
    15e8:	01 97       	sbiw	r24, 0x01	; 1
    15ea:	f1 f7       	brne	.-4      	; 0x15e8 <LCD_WriteChar4Bit+0x1c>
    15ec:	00 c0       	rjmp	.+0      	; 0x15ee <LCD_WriteChar4Bit+0x22>
    15ee:	00 00       	nop
    15f0:	4c 2f       	mov	r20, r28
    15f2:	42 95       	swap	r20
    15f4:	4f 70       	andi	r20, 0x0F	; 15
    15f6:	64 e0       	ldi	r22, 0x04	; 4
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	0e 94 be 02 	call	0x57c	; 0x57c <DIO_WriteHalfPort>
    15fe:	8f e3       	ldi	r24, 0x3F	; 63
    1600:	9f e1       	ldi	r25, 0x1F	; 31
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	f1 f7       	brne	.-4      	; 0x1602 <LCD_WriteChar4Bit+0x36>
    1606:	00 c0       	rjmp	.+0      	; 0x1608 <LCD_WriteChar4Bit+0x3c>
    1608:	00 00       	nop
    160a:	0e 94 87 0a 	call	0x150e	; 0x150e <LCD_Peek>
    160e:	8f e3       	ldi	r24, 0x3F	; 63
    1610:	9f e1       	ldi	r25, 0x1F	; 31
    1612:	01 97       	sbiw	r24, 0x01	; 1
    1614:	f1 f7       	brne	.-4      	; 0x1612 <LCD_WriteChar4Bit+0x46>
    1616:	00 c0       	rjmp	.+0      	; 0x1618 <LCD_WriteChar4Bit+0x4c>
    1618:	00 00       	nop
    161a:	4c 2f       	mov	r20, r28
    161c:	4f 70       	andi	r20, 0x0F	; 15
    161e:	64 e0       	ldi	r22, 0x04	; 4
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	0e 94 be 02 	call	0x57c	; 0x57c <DIO_WriteHalfPort>
    1626:	8f e3       	ldi	r24, 0x3F	; 63
    1628:	9f e1       	ldi	r25, 0x1F	; 31
    162a:	01 97       	sbiw	r24, 0x01	; 1
    162c:	f1 f7       	brne	.-4      	; 0x162a <LCD_WriteChar4Bit+0x5e>
    162e:	00 c0       	rjmp	.+0      	; 0x1630 <LCD_WriteChar4Bit+0x64>
    1630:	00 00       	nop
    1632:	0e 94 87 0a 	call	0x150e	; 0x150e <LCD_Peek>
    1636:	8f e3       	ldi	r24, 0x3F	; 63
    1638:	9f e1       	ldi	r25, 0x1F	; 31
    163a:	01 97       	sbiw	r24, 0x01	; 1
    163c:	f1 f7       	brne	.-4      	; 0x163a <LCD_WriteChar4Bit+0x6e>
    163e:	00 c0       	rjmp	.+0      	; 0x1640 <LCD_WriteChar4Bit+0x74>
    1640:	00 00       	nop
    1642:	cf 91       	pop	r28
    1644:	08 95       	ret

00001646 <LCD_WriteString>:
    1646:	0f 93       	push	r16
    1648:	1f 93       	push	r17
    164a:	cf 93       	push	r28
    164c:	00 97       	sbiw	r24, 0x00	; 0
    164e:	29 f4       	brne	.+10     	; 0x165a <LCD_WriteString+0x14>
    1650:	0c c0       	rjmp	.+24     	; 0x166a <LCD_WriteString+0x24>
    1652:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <LCD_WriteChar4Bit>
    1656:	cf 5f       	subi	r28, 0xFF	; 255
    1658:	02 c0       	rjmp	.+4      	; 0x165e <LCD_WriteString+0x18>
    165a:	8c 01       	movw	r16, r24
    165c:	c0 e0       	ldi	r28, 0x00	; 0
    165e:	f8 01       	movw	r30, r16
    1660:	ec 0f       	add	r30, r28
    1662:	f1 1d       	adc	r31, r1
    1664:	80 81       	ld	r24, Z
    1666:	81 11       	cpse	r24, r1
    1668:	f4 cf       	rjmp	.-24     	; 0x1652 <LCD_WriteString+0xc>
    166a:	cf 91       	pop	r28
    166c:	1f 91       	pop	r17
    166e:	0f 91       	pop	r16
    1670:	08 95       	ret

00001672 <LCD_ClearDisplay>:
 * @brief: Function to clear the LCD display
 * 
 */
void LCD_ClearDisplay(void)
{
    LCD_WriteCommand4Bit(CLEAR_DISPLAY);
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	0e 94 98 0a 	call	0x1530	; 0x1530 <LCD_WriteCommand4Bit>
    1678:	08 95       	ret

0000167a <LCD_Init>:
 * @brief: Function to initialize the LCD
 * 
 */
void LCD_Init(void)
{
    DIO_SetPinDirection(LCD_RS_PORT_ID, LCD_RS_PIN_ID, DIO_PIN_OUTPUT);
    167a:	41 e0       	ldi	r20, 0x01	; 1
    167c:	61 e0       	ldi	r22, 0x01	; 1
    167e:	81 e0       	ldi	r24, 0x01	; 1
    1680:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_RW_PORT_ID, LCD_RW_PIN_ID, DIO_PIN_OUTPUT);
    1684:	41 e0       	ldi	r20, 0x01	; 1
    1686:	62 e0       	ldi	r22, 0x02	; 2
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_E_PORT_ID, LCD_E_PIN_ID, DIO_PIN_OUTPUT);
    168e:	41 e0       	ldi	r20, 0x01	; 1
    1690:	63 e0       	ldi	r22, 0x03	; 3
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D4_PIN_ID, DIO_PIN_OUTPUT);
    1698:	41 e0       	ldi	r20, 0x01	; 1
    169a:	64 e0       	ldi	r22, 0x04	; 4
    169c:	80 e0       	ldi	r24, 0x00	; 0
    169e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D5_PIN_ID, DIO_PIN_OUTPUT);
    16a2:	41 e0       	ldi	r20, 0x01	; 1
    16a4:	65 e0       	ldi	r22, 0x05	; 5
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D6_PIN_ID, DIO_PIN_OUTPUT);
    16ac:	41 e0       	ldi	r20, 0x01	; 1
    16ae:	66 e0       	ldi	r22, 0x06	; 6
    16b0:	80 e0       	ldi	r24, 0x00	; 0
    16b2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D7_PIN_ID, DIO_PIN_OUTPUT);
    16b6:	41 e0       	ldi	r20, 0x01	; 1
    16b8:	67 e0       	ldi	r22, 0x07	; 7
    16ba:	80 e0       	ldi	r24, 0x00	; 0
    16bc:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    16c0:	2f e7       	ldi	r18, 0x7F	; 127
    16c2:	85 eb       	ldi	r24, 0xB5	; 181
    16c4:	91 e0       	ldi	r25, 0x01	; 1
    16c6:	21 50       	subi	r18, 0x01	; 1
    16c8:	80 40       	sbci	r24, 0x00	; 0
    16ca:	90 40       	sbci	r25, 0x00	; 0
    16cc:	e1 f7       	brne	.-8      	; 0x16c6 <LCD_Init+0x4c>
    16ce:	00 c0       	rjmp	.+0      	; 0x16d0 <LCD_Init+0x56>
    16d0:	00 00       	nop
    _delay_ms(35);

    LCD_WriteCommand4Bit(MODE_4_BIT);
    16d2:	82 e0       	ldi	r24, 0x02	; 2
    16d4:	0e 94 98 0a 	call	0x1530	; 0x1530 <LCD_WriteCommand4Bit>
    16d8:	8f e9       	ldi	r24, 0x9F	; 159
    16da:	9f e0       	ldi	r25, 0x0F	; 15
    16dc:	01 97       	sbiw	r24, 0x01	; 1
    16de:	f1 f7       	brne	.-4      	; 0x16dc <LCD_Init+0x62>
    16e0:	00 c0       	rjmp	.+0      	; 0x16e2 <LCD_Init+0x68>
    16e2:	00 00       	nop
    _delay_ms(1);
    
    LCD_WriteCommand4Bit(FUNCTION_SET_COMMAND);
    16e4:	88 e2       	ldi	r24, 0x28	; 40
    16e6:	0e 94 98 0a 	call	0x1530	; 0x1530 <LCD_WriteCommand4Bit>
    16ea:	8f e9       	ldi	r24, 0x9F	; 159
    16ec:	9f e0       	ldi	r25, 0x0F	; 15
    16ee:	01 97       	sbiw	r24, 0x01	; 1
    16f0:	f1 f7       	brne	.-4      	; 0x16ee <LCD_Init+0x74>
    16f2:	00 c0       	rjmp	.+0      	; 0x16f4 <LCD_Init+0x7a>
    16f4:	00 00       	nop
    _delay_ms(1);

    LCD_WriteCommand4Bit(DISPLAY_SET_COMMAND);
    16f6:	8f e0       	ldi	r24, 0x0F	; 15
    16f8:	0e 94 98 0a 	call	0x1530	; 0x1530 <LCD_WriteCommand4Bit>
    16fc:	8f e9       	ldi	r24, 0x9F	; 159
    16fe:	9f e0       	ldi	r25, 0x0F	; 15
    1700:	01 97       	sbiw	r24, 0x01	; 1
    1702:	f1 f7       	brne	.-4      	; 0x1700 <LCD_Init+0x86>
    1704:	00 c0       	rjmp	.+0      	; 0x1706 <LCD_Init+0x8c>
    1706:	00 00       	nop
    _delay_ms(1);

    LCD_ClearDisplay();
    1708:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    170c:	8f e3       	ldi	r24, 0x3F	; 63
    170e:	9f e1       	ldi	r25, 0x1F	; 31
    1710:	01 97       	sbiw	r24, 0x01	; 1
    1712:	f1 f7       	brne	.-4      	; 0x1710 <LCD_Init+0x96>
    1714:	00 c0       	rjmp	.+0      	; 0x1716 <LCD_Init+0x9c>
    1716:	00 00       	nop
    _delay_ms(2);

    LCD_WriteCommand4Bit(FIRST_LINE_OFFSET);
    1718:	80 e8       	ldi	r24, 0x80	; 128
    171a:	0e 94 98 0a 	call	0x1530	; 0x1530 <LCD_WriteCommand4Bit>
    171e:	8f e3       	ldi	r24, 0x3F	; 63
    1720:	9f e1       	ldi	r25, 0x1F	; 31
    1722:	01 97       	sbiw	r24, 0x01	; 1
    1724:	f1 f7       	brne	.-4      	; 0x1722 <LCD_Init+0xa8>
    1726:	00 c0       	rjmp	.+0      	; 0x1728 <LCD_Init+0xae>
    1728:	00 00       	nop
    172a:	08 95       	ret

0000172c <LED_On>:
 * 
 * @param Copy_u8PortID: Port ID to which the LED is connected
 * @param Copy_u8PinID: Pin ID to which the LED is connected
 */
void LED_On(u8 Copy_u8PortID, u8 Copy_u8PinID)
{
    172c:	0f 93       	push	r16
    172e:	1f 93       	push	r17
    1730:	cf 93       	push	r28
    1732:	df 93       	push	r29
    1734:	1f 92       	push	r1
    1736:	cd b7       	in	r28, 0x3d	; 61
    1738:	de b7       	in	r29, 0x3e	; 62
    if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
    173a:	84 30       	cpi	r24, 0x04	; 4
    173c:	d8 f4       	brcc	.+54     	; 0x1774 <LED_On+0x48>
    {
        if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
    173e:	68 30       	cpi	r22, 0x08	; 8
    1740:	c8 f4       	brcc	.+50     	; 0x1774 <LED_On+0x48>
    1742:	06 2f       	mov	r16, r22
    1744:	18 2f       	mov	r17, r24
        {
            u8 Loc_u8PinDirStatus = 7;
    1746:	87 e0       	ldi	r24, 0x07	; 7
    1748:	89 83       	std	Y+1, r24	; 0x01
            DIO_ReadDDRPinValue(Copy_u8PortID, Copy_u8PinID, &Loc_u8PinDirStatus);
    174a:	ae 01       	movw	r20, r28
    174c:	4f 5f       	subi	r20, 0xFF	; 255
    174e:	5f 4f       	sbci	r21, 0xFF	; 255
    1750:	81 2f       	mov	r24, r17
    1752:	0e 94 50 03 	call	0x6a0	; 0x6a0 <DIO_ReadDDRPinValue>
            if(Loc_u8PinDirStatus == DIO_PIN_OUTPUT || Loc_u8PinDirStatus == DIO_PIN_INPUT)
    1756:	89 81       	ldd	r24, Y+1	; 0x01
    1758:	82 30       	cpi	r24, 0x02	; 2
    175a:	60 f4       	brcc	.+24     	; 0x1774 <LED_On+0x48>
            {
                if(Loc_u8PinDirStatus == DIO_PIN_INPUT)
    175c:	81 11       	cpse	r24, r1
    175e:	05 c0       	rjmp	.+10     	; 0x176a <LED_On+0x3e>
                {
                    DIO_SetPinDirection(Copy_u8PortID, Copy_u8PinID, DIO_PIN_OUTPUT);
    1760:	41 e0       	ldi	r20, 0x01	; 1
    1762:	60 2f       	mov	r22, r16
    1764:	81 2f       	mov	r24, r17
    1766:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
                else
                {
                    /*Do nothing*/
                }

                DIO_SetPinValue(Copy_u8PortID, Copy_u8PinID, DIO_PIN_HIGH);
    176a:	41 e0       	ldi	r20, 0x01	; 1
    176c:	60 2f       	mov	r22, r16
    176e:	81 2f       	mov	r24, r17
    1770:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    }
    else
    {
        /*Do nothing*/
    }
}
    1774:	0f 90       	pop	r0
    1776:	df 91       	pop	r29
    1778:	cf 91       	pop	r28
    177a:	1f 91       	pop	r17
    177c:	0f 91       	pop	r16
    177e:	08 95       	ret

00001780 <LED_Off>:
 * 
 * @param Copy_u8PortID:  Port ID to which the LED is connected 
 * @param Copy_u8PinID: Pin ID to which the LED is connected
 */
void LED_Off(u8 Copy_u8PortID, u8 Copy_u8PinID)
{
    1780:	0f 93       	push	r16
    1782:	1f 93       	push	r17
    1784:	cf 93       	push	r28
    1786:	df 93       	push	r29
    1788:	1f 92       	push	r1
    178a:	cd b7       	in	r28, 0x3d	; 61
    178c:	de b7       	in	r29, 0x3e	; 62
        if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
    178e:	84 30       	cpi	r24, 0x04	; 4
    1790:	d8 f4       	brcc	.+54     	; 0x17c8 <LED_Off+0x48>
    {
        if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
    1792:	68 30       	cpi	r22, 0x08	; 8
    1794:	c8 f4       	brcc	.+50     	; 0x17c8 <LED_Off+0x48>
    1796:	06 2f       	mov	r16, r22
    1798:	18 2f       	mov	r17, r24
        {
            u8 Loc_u8PinDirStatus = 7;
    179a:	87 e0       	ldi	r24, 0x07	; 7
    179c:	89 83       	std	Y+1, r24	; 0x01
            DIO_ReadDDRPinValue(Copy_u8PortID, Copy_u8PinID, &Loc_u8PinDirStatus);
    179e:	ae 01       	movw	r20, r28
    17a0:	4f 5f       	subi	r20, 0xFF	; 255
    17a2:	5f 4f       	sbci	r21, 0xFF	; 255
    17a4:	81 2f       	mov	r24, r17
    17a6:	0e 94 50 03 	call	0x6a0	; 0x6a0 <DIO_ReadDDRPinValue>
            if(Loc_u8PinDirStatus == DIO_PIN_HIGH || Loc_u8PinDirStatus == DIO_PIN_LOW)
    17aa:	89 81       	ldd	r24, Y+1	; 0x01
    17ac:	82 30       	cpi	r24, 0x02	; 2
    17ae:	60 f4       	brcc	.+24     	; 0x17c8 <LED_Off+0x48>
            {
                if(Loc_u8PinDirStatus == DIO_PIN_LOW)
    17b0:	81 11       	cpse	r24, r1
    17b2:	05 c0       	rjmp	.+10     	; 0x17be <LED_Off+0x3e>
                {
                    DIO_SetPinDirection(Copy_u8PortID, Copy_u8PinID, DIO_PIN_OUTPUT);
    17b4:	41 e0       	ldi	r20, 0x01	; 1
    17b6:	60 2f       	mov	r22, r16
    17b8:	81 2f       	mov	r24, r17
    17ba:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
                }
                else
                {
                    /*Do nothing*/
                }
                DIO_SetPinValue(Copy_u8PortID, Copy_u8PinID, DIO_PIN_LOW);   
    17be:	40 e0       	ldi	r20, 0x00	; 0
    17c0:	60 2f       	mov	r22, r16
    17c2:	81 2f       	mov	r24, r17
    17c4:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    }
    else
    {
        /*Do nothing*/
    }
}
    17c8:	0f 90       	pop	r0
    17ca:	df 91       	pop	r29
    17cc:	cf 91       	pop	r28
    17ce:	1f 91       	pop	r17
    17d0:	0f 91       	pop	r16
    17d2:	08 95       	ret

000017d4 <LM35_StartConversion>:
	return 0;
}

void LM35_StartConversion(void)
{
	ADC_StartConversion(ADC_CHANNEL_0);
    17d4:	80 e0       	ldi	r24, 0x00	; 0
    17d6:	0e 94 72 00 	call	0xe4	; 0xe4 <ADC_StartConversion>
    17da:	08 95       	ret

000017dc <LM35_TempControl>:

}
/*LM35 Temp Sensor gives us 10mv/degree*/
void LM35_TempControl(void)
{
    17dc:	cf 93       	push	r28
    17de:	df 93       	push	r29
    17e0:	00 d0       	rcall	.+0      	; 0x17e2 <LM35_TempControl+0x6>
    17e2:	cd b7       	in	r28, 0x3d	; 61
    17e4:	de b7       	in	r29, 0x3e	; 62
	u16 Loc_u16ADCValue = 0;
    17e6:	1a 82       	std	Y+2, r1	; 0x02
    17e8:	19 82       	std	Y+1, r1	; 0x01
	ADC_GetDigitalValueAsynchronous(&Loc_u16ADCValue);
    17ea:	ce 01       	movw	r24, r28
    17ec:	01 96       	adiw	r24, 0x01	; 1
    17ee:	0e 94 85 00 	call	0x10a	; 0x10a <ADC_GetDigitalValueAsynchronous>
	u8 Loc_u8Temp = Loc_u16ADCValue / 4;
    17f2:	89 81       	ldd	r24, Y+1	; 0x01
    17f4:	9a 81       	ldd	r25, Y+2	; 0x02
    17f6:	96 95       	lsr	r25
    17f8:	87 95       	ror	r24
    17fa:	96 95       	lsr	r25
    17fc:	87 95       	ror	r24
	
	if(Loc_u8Temp < 21)
    17fe:	85 31       	cpi	r24, 0x15	; 21
    1800:	30 f4       	brcc	.+12     	; 0x180e <LM35_TempControl+0x32>
	{
		DIO_SetPinValue(DIO_PORTA,DIO_PIN2,DIO_PIN_LOW);
    1802:	40 e0       	ldi	r20, 0x00	; 0
    1804:	62 e0       	ldi	r22, 0x02	; 2
    1806:	80 e0       	ldi	r24, 0x00	; 0
    1808:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    180c:	07 c0       	rjmp	.+14     	; 0x181c <LM35_TempControl+0x40>
	}
	else if(Loc_u8Temp > 28)
    180e:	8d 31       	cpi	r24, 0x1D	; 29
    1810:	28 f0       	brcs	.+10     	; 0x181c <LM35_TempControl+0x40>
	{
		DIO_SetPinValue(DIO_PORTA,DIO_PIN2,DIO_PIN_HIGH);
    1812:	41 e0       	ldi	r20, 0x01	; 1
    1814:	62 e0       	ldi	r22, 0x02	; 2
    1816:	80 e0       	ldi	r24, 0x00	; 0
    1818:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
	else
	{
		/*Do nothing*/
	}
	
}
    181c:	0f 90       	pop	r0
    181e:	0f 90       	pop	r0
    1820:	df 91       	pop	r29
    1822:	cf 91       	pop	r28
    1824:	08 95       	ret

00001826 <main>:
#define F_CPU 16000000UL
#include <util/delay.h>
void LM35_StartConversion(void);
void LM35_TempControl(void);
int main(void)
{
    1826:	cf 93       	push	r28
    1828:	df 93       	push	r29
    182a:	00 d0       	rcall	.+0      	; 0x182c <main+0x6>
    182c:	cd b7       	in	r28, 0x3d	; 61
    182e:	de b7       	in	r29, 0x3e	; 62
	u8 Loc_u8Value = 0;
    1830:	19 82       	std	Y+1, r1	; 0x01
	LCD_Init();
    1832:	0e 94 3d 0b 	call	0x167a	; 0x167a <LCD_Init>
	SRVM_Init();
    1836:	0e 94 9b 0c 	call	0x1936	; 0x1936 <SRVM_Init>
	BUZZER_Init();
    183a:	0e 94 c0 00 	call	0x180	; 0x180 <BUZZER_Init>
	GI_Enable();
    183e:	0e 94 cb 03 	call	0x796	; 0x796 <GI_Enable>

	DIO_SetPinDirection(DIO_PORTA, DIO_PIN0, DIO_PIN_INPUT);
    1842:	40 e0       	ldi	r20, 0x00	; 0
    1844:	60 e0       	ldi	r22, 0x00	; 0
    1846:	80 e0       	ldi	r24, 0x00	; 0
    1848:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PORTA, DIO_PIN2, DIO_PIN_OUTPUT);
    184c:	41 e0       	ldi	r20, 0x01	; 1
    184e:	62 e0       	ldi	r22, 0x02	; 2
    1850:	80 e0       	ldi	r24, 0x00	; 0
    1852:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
	TMR_Timer0Init();
    1856:	0e 94 f3 0c 	call	0x19e6	; 0x19e6 <TMR_Timer0Init>
	TMR_Timer0_OVF_SetCallBack(LM35_StartConversion);
    185a:	8a ee       	ldi	r24, 0xEA	; 234
    185c:	9b e0       	ldi	r25, 0x0B	; 11
    185e:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <TMR_Timer0_OVF_SetCallBack>
	TMR_Timer0Start();
    1862:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <TMR_Timer0Start>
	ADC_ConversionCompleteSetCallback(LM35_TempControl);
    1866:	8e ee       	ldi	r24, 0xEE	; 238
    1868:	9b e0       	ldi	r25, 0x0B	; 11
    186a:	0e 94 7e 00 	call	0xfc	; 0xfc <ADC_ConversionCompleteSetCallback>
	ADC_Init();
    186e:	0e 94 56 00 	call	0xac	; 0xac <ADC_Init>
	KPD_Init();
    1872:	0e 94 b4 09 	call	0x1368	; 0x1368 <KPD_Init>
	TMR_Timer2Init();
    1876:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <TMR_Timer2Init>
	DIO_SetPinDirection(DIO_PORTD, DIO_PIN0, DIO_PIN_INPUT); //Rx
    187a:	40 e0       	ldi	r20, 0x00	; 0
    187c:	60 e0       	ldi	r22, 0x00	; 0
    187e:	83 e0       	ldi	r24, 0x03	; 3
    1880:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PORTD, DIO_PIN1, DIO_PIN_OUTPUT); //Tx
    1884:	41 e0       	ldi	r20, 0x01	; 1
    1886:	61 e0       	ldi	r22, 0x01	; 1
    1888:	83 e0       	ldi	r24, 0x03	; 3
    188a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
	UART_RxCompleteSetCallback(HC05_AdminUserInterface);
    188e:	80 ea       	ldi	r24, 0xA0	; 160
    1890:	95 e0       	ldi	r25, 0x05	; 5
    1892:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <UART_RxCompleteSetCallback>
	UART_Init();
    1896:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <UART_Init>
	Internal_EEPROM_ReadByte(HC05_ADMIN_SAVED_STATUS_MEM_ADDRESS, &Loc_u8Value);
    189a:	be 01       	movw	r22, r28
    189c:	6f 5f       	subi	r22, 0xFF	; 255
    189e:	7f 4f       	sbci	r23, 0xFF	; 255
    18a0:	80 e5       	ldi	r24, 0x50	; 80
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
	if (1 != Loc_u8Value)
    18a8:	89 81       	ldd	r24, Y+1	; 0x01
    18aa:	81 30       	cpi	r24, 0x01	; 1
    18ac:	89 f0       	breq	.+34     	; 0x18d0 <main+0xaa>
	{
		LCD_WriteString("First Entry!");
    18ae:	8e ef       	ldi	r24, 0xFE	; 254
    18b0:	95 e0       	ldi	r25, 0x05	; 5
    18b2:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    18b6:	2f ef       	ldi	r18, 0xFF	; 255
    18b8:	87 ea       	ldi	r24, 0xA7	; 167
    18ba:	91 e6       	ldi	r25, 0x61	; 97
    18bc:	21 50       	subi	r18, 0x01	; 1
    18be:	80 40       	sbci	r24, 0x00	; 0
    18c0:	90 40       	sbci	r25, 0x00	; 0
    18c2:	e1 f7       	brne	.-8      	; 0x18bc <main+0x96>
    18c4:	00 c0       	rjmp	.+0      	; 0x18c6 <main+0xa0>
    18c6:	00 00       	nop
		_delay_ms(2000);
		LCD_ClearDisplay();
    18c8:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
		HC05_AdminUsernamePasswordSaver();
    18cc:	0e 94 df 03 	call	0x7be	; 0x7be <HC05_AdminUsernamePasswordSaver>
	}
	USER_PROGRAM_START();
    18d0:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <USER_PROGRAM_START>
	HC05_WelcomeMessage();
    18d4:	0e 94 cf 03 	call	0x79e	; 0x79e <HC05_WelcomeMessage>
	u8 Loc_u8UserInput = KPD_NOT_PRESSED;
    18d8:	8f ef       	ldi	r24, 0xFF	; 255
    18da:	8a 83       	std	Y+2, r24	; 0x02
    while (1) 
    {
		LCD_WriteString("WANT TO LOGIN?");
    18dc:	8b e0       	ldi	r24, 0x0B	; 11
    18de:	96 e0       	ldi	r25, 0x06	; 6
    18e0:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
		
		LCD_SetCursorPosition(LCD_SECOND_ROW, 0);
    18e4:	60 e0       	ldi	r22, 0x00	; 0
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
		LCD_WriteString("1:Yes    2:No");
    18ec:	8a e1       	ldi	r24, 0x1A	; 26
    18ee:	96 e0       	ldi	r25, 0x06	; 6
    18f0:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    18f4:	2f ef       	ldi	r18, 0xFF	; 255
    18f6:	83 ed       	ldi	r24, 0xD3	; 211
    18f8:	90 e3       	ldi	r25, 0x30	; 48
    18fa:	21 50       	subi	r18, 0x01	; 1
    18fc:	80 40       	sbci	r24, 0x00	; 0
    18fe:	90 40       	sbci	r25, 0x00	; 0
    1900:	e1 f7       	brne	.-8      	; 0x18fa <main+0xd4>
    1902:	00 c0       	rjmp	.+0      	; 0x1904 <main+0xde>
    1904:	00 00       	nop
		_delay_ms(1000);
		LCD_ClearDisplay();
    1906:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
		while(Loc_u8UserInput == KPD_NOT_PRESSED)
    190a:	04 c0       	rjmp	.+8      	; 0x1914 <main+0xee>
		{
			KPD_GetValue(&Loc_u8UserInput);
    190c:	ce 01       	movw	r24, r28
    190e:	02 96       	adiw	r24, 0x02	; 2
    1910:	0e 94 01 0a 	call	0x1402	; 0x1402 <KPD_GetValue>
		
		LCD_SetCursorPosition(LCD_SECOND_ROW, 0);
		LCD_WriteString("1:Yes    2:No");
		_delay_ms(1000);
		LCD_ClearDisplay();
		while(Loc_u8UserInput == KPD_NOT_PRESSED)
    1914:	8a 81       	ldd	r24, Y+2	; 0x02
    1916:	8f 3f       	cpi	r24, 0xFF	; 255
    1918:	c9 f3       	breq	.-14     	; 0x190c <main+0xe6>
		{
			KPD_GetValue(&Loc_u8UserInput);
		}
		if('1' == Loc_u8UserInput)
    191a:	81 33       	cpi	r24, 0x31	; 49
    191c:	19 f4       	brne	.+6      	; 0x1924 <main+0xfe>
		{
			USER_APP();
    191e:	0e 94 c5 12 	call	0x258a	; 0x258a <USER_APP>
    1922:	06 c0       	rjmp	.+12     	; 0x1930 <main+0x10a>
		}
		else if('2' == Loc_u8UserInput)
    1924:	82 33       	cpi	r24, 0x32	; 50
    1926:	21 f4       	brne	.+8      	; 0x1930 <main+0x10a>
		{
			LCD_ClearDisplay();
    1928:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
			HC05_ShowRunningDevices();
    192c:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <HC05_ShowRunningDevices>
		}
		else
		{
			/*Do nothing*/
		}
		Loc_u8UserInput = KPD_NOT_PRESSED;
    1930:	8f ef       	ldi	r24, 0xFF	; 255
    1932:	8a 83       	std	Y+2, r24	; 0x02
	}
    1934:	d3 cf       	rjmp	.-90     	; 0x18dc <main+0xb6>

00001936 <SRVM_Init>:
 * @brief: Function to initialize the Servo motor Peripheral
 * 
 */
void SRVM_Init(void)
{
    TMR_Timer1Init();
    1936:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <TMR_Timer1Init>
    TMR_Timer1SetFastPWMFreq(50);
    193a:	62 e3       	ldi	r22, 0x32	; 50
    193c:	70 e0       	ldi	r23, 0x00	; 0
    193e:	80 e0       	ldi	r24, 0x00	; 0
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <TMR_Timer1SetFastPWMFreq>
    TMR_Timer1Start();
    1946:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <TMR_Timer1Start>
    194a:	08 95       	ret

0000194c <SRVM_SetRotationAngle>:
 * 
 * @param Copy_u8RotationAngleSign: Sign of angle of servo motor 
 * @param Copy_u8RotationAngle: : Angle of Servo motor 
 */
void SRVM_SetRotationAngle(u8 Copy_u8RotationAngleSign,u8 Copy_u8RotationAngle)
{
    194c:	0f 93       	push	r16
    194e:	1f 93       	push	r17
    
                  540 + (2 x Angle)
    DutyCycle = --------------------  Note: Angle can be positive or negative
                        72
*/
    if((Copy_u8RotationAngle >= 0) && (Copy_u8RotationAngle <= 90))
    1950:	6b 35       	cpi	r22, 0x5B	; 91
    1952:	08 f0       	brcs	.+2      	; 0x1956 <SRVM_SetRotationAngle+0xa>
    1954:	45 c0       	rjmp	.+138    	; 0x19e0 <SRVM_SetRotationAngle+0x94>
    {
        if(Copy_u8RotationAngle == 0)
    1956:	61 11       	cpse	r22, r1
    1958:	04 c0       	rjmp	.+8      	; 0x1962 <SRVM_SetRotationAngle+0x16>
        {
            TMR_Timer1SetPWMDutyCycle(SRVM_OC_CONNECTED, TMR_TIMER1_ZERO_POSITION);
    195a:	81 e0       	ldi	r24, 0x01	; 1
    195c:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <TMR_Timer1SetPWMDutyCycle>
    1960:	3f c0       	rjmp	.+126    	; 0x19e0 <SRVM_SetRotationAngle+0x94>
        }
        else
        {
            u8 Loc_u8DutyCycle = 0;
            switch(Copy_u8RotationAngleSign)
    1962:	81 30       	cpi	r24, 0x01	; 1
    1964:	19 f0       	breq	.+6      	; 0x196c <SRVM_SetRotationAngle+0x20>
    1966:	82 30       	cpi	r24, 0x02	; 2
    1968:	d1 f0       	breq	.+52     	; 0x199e <SRVM_SetRotationAngle+0x52>
    196a:	3a c0       	rjmp	.+116    	; 0x19e0 <SRVM_SetRotationAngle+0x94>
            {
                case SRVM_ANGLE_POSITIVE:
                {
                    Loc_u8DutyCycle = (u32)(((u32)(540 + (u32)(2 * (u32)Copy_u8RotationAngle))) / 72);
    196c:	86 2f       	mov	r24, r22
    196e:	90 e0       	ldi	r25, 0x00	; 0
    1970:	a0 e0       	ldi	r26, 0x00	; 0
    1972:	b0 e0       	ldi	r27, 0x00	; 0
    1974:	82 5f       	subi	r24, 0xF2	; 242
    1976:	9e 4f       	sbci	r25, 0xFE	; 254
    1978:	af 4f       	sbci	r26, 0xFF	; 255
    197a:	bf 4f       	sbci	r27, 0xFF	; 255
    197c:	bc 01       	movw	r22, r24
    197e:	cd 01       	movw	r24, r26
    1980:	66 0f       	add	r22, r22
    1982:	77 1f       	adc	r23, r23
    1984:	88 1f       	adc	r24, r24
    1986:	99 1f       	adc	r25, r25
    1988:	28 e4       	ldi	r18, 0x48	; 72
    198a:	30 e0       	ldi	r19, 0x00	; 0
    198c:	40 e0       	ldi	r20, 0x00	; 0
    198e:	50 e0       	ldi	r21, 0x00	; 0
    1990:	0e 94 ce 12 	call	0x259c	; 0x259c <__udivmodsi4>
                    TMR_Timer1SetPWMDutyCycle(SRVM_OC_CONNECTED, Loc_u8DutyCycle);
    1994:	62 2f       	mov	r22, r18
    1996:	81 e0       	ldi	r24, 0x01	; 1
    1998:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <TMR_Timer1SetPWMDutyCycle>
                    break;
    199c:	21 c0       	rjmp	.+66     	; 0x19e0 <SRVM_SetRotationAngle+0x94>
                }
                case SRVM_ANGLE_NEGATIVE:
                {
                    Loc_u8DutyCycle = (u32)(((u32)(540 - (u32)(2 * (u32)Copy_u8RotationAngle))) / 72);
    199e:	86 2f       	mov	r24, r22
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	a0 e0       	ldi	r26, 0x00	; 0
    19a4:	b0 e0       	ldi	r27, 0x00	; 0
    19a6:	00 e0       	ldi	r16, 0x00	; 0
    19a8:	10 e0       	ldi	r17, 0x00	; 0
    19aa:	98 01       	movw	r18, r16
    19ac:	08 1b       	sub	r16, r24
    19ae:	19 0b       	sbc	r17, r25
    19b0:	2a 0b       	sbc	r18, r26
    19b2:	3b 0b       	sbc	r19, r27
    19b4:	d9 01       	movw	r26, r18
    19b6:	c8 01       	movw	r24, r16
    19b8:	88 0f       	add	r24, r24
    19ba:	99 1f       	adc	r25, r25
    19bc:	aa 1f       	adc	r26, r26
    19be:	bb 1f       	adc	r27, r27
    19c0:	bc 01       	movw	r22, r24
    19c2:	cd 01       	movw	r24, r26
    19c4:	64 5e       	subi	r22, 0xE4	; 228
    19c6:	7d 4f       	sbci	r23, 0xFD	; 253
    19c8:	8f 4f       	sbci	r24, 0xFF	; 255
    19ca:	9f 4f       	sbci	r25, 0xFF	; 255
    19cc:	28 e4       	ldi	r18, 0x48	; 72
    19ce:	30 e0       	ldi	r19, 0x00	; 0
    19d0:	40 e0       	ldi	r20, 0x00	; 0
    19d2:	50 e0       	ldi	r21, 0x00	; 0
    19d4:	0e 94 ce 12 	call	0x259c	; 0x259c <__udivmodsi4>
                    TMR_Timer1SetPWMDutyCycle(SRVM_OC_CONNECTED, Loc_u8DutyCycle);
    19d8:	62 2f       	mov	r22, r18
    19da:	81 e0       	ldi	r24, 0x01	; 1
    19dc:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <TMR_Timer1SetPWMDutyCycle>
    }
    else
    {
        /*Do nothing*/
    }
    19e0:	1f 91       	pop	r17
    19e2:	0f 91       	pop	r16
    19e4:	08 95       	ret

000019e6 <TMR_Timer0Init>:
 */
void TMR_Timer2_OVF_SetCallBack     (Ptr_to_func_t P_funcCallBack)
{
    if(P_funcCallBack != NULL)
    {
        TMR_Timer2_OVF_PCallBack = P_funcCallBack;
    19e6:	83 b7       	in	r24, 0x33	; 51
    19e8:	8f 7b       	andi	r24, 0xBF	; 191
    19ea:	83 bf       	out	0x33, r24	; 51
    19ec:	83 b7       	in	r24, 0x33	; 51
    19ee:	87 7f       	andi	r24, 0xF7	; 247
    19f0:	83 bf       	out	0x33, r24	; 51
    19f2:	89 b7       	in	r24, 0x39	; 57
    19f4:	81 60       	ori	r24, 0x01	; 1
    19f6:	89 bf       	out	0x39, r24	; 57
    19f8:	08 95       	ret

000019fa <TMR_Timer0Start>:
    19fa:	83 b7       	in	r24, 0x33	; 51
    19fc:	8e 7f       	andi	r24, 0xFE	; 254
    19fe:	83 bf       	out	0x33, r24	; 51
    1a00:	83 b7       	in	r24, 0x33	; 51
    1a02:	8d 7f       	andi	r24, 0xFD	; 253
    1a04:	83 bf       	out	0x33, r24	; 51
    1a06:	83 b7       	in	r24, 0x33	; 51
    1a08:	84 60       	ori	r24, 0x04	; 4
    1a0a:	83 bf       	out	0x33, r24	; 51
    1a0c:	08 95       	ret

00001a0e <TMR_Timer0_OVF_SetCallBack>:
    1a0e:	00 97       	sbiw	r24, 0x00	; 0
    1a10:	21 f0       	breq	.+8      	; 0x1a1a <TMR_Timer0_OVF_SetCallBack+0xc>
    1a12:	90 93 9f 07 	sts	0x079F, r25	; 0x80079f <TMR_Timer0_OVF_PCallBack+0x1>
    1a16:	80 93 9e 07 	sts	0x079E, r24	; 0x80079e <TMR_Timer0_OVF_PCallBack>
    1a1a:	08 95       	ret

00001a1c <__vector_10>:
    1a1c:	1f 92       	push	r1
    1a1e:	0f 92       	push	r0
    1a20:	0f b6       	in	r0, 0x3f	; 63
    1a22:	0f 92       	push	r0
    1a24:	11 24       	eor	r1, r1
    1a26:	2f 93       	push	r18
    1a28:	3f 93       	push	r19
    1a2a:	4f 93       	push	r20
    1a2c:	5f 93       	push	r21
    1a2e:	6f 93       	push	r22
    1a30:	7f 93       	push	r23
    1a32:	8f 93       	push	r24
    1a34:	9f 93       	push	r25
    1a36:	af 93       	push	r26
    1a38:	bf 93       	push	r27
    1a3a:	ef 93       	push	r30
    1a3c:	ff 93       	push	r31
    1a3e:	e0 91 a0 07 	lds	r30, 0x07A0	; 0x8007a0 <TMR_Timer0_CTC_PCallBack>
    1a42:	f0 91 a1 07 	lds	r31, 0x07A1	; 0x8007a1 <TMR_Timer0_CTC_PCallBack+0x1>
    1a46:	30 97       	sbiw	r30, 0x00	; 0
    1a48:	09 f0       	breq	.+2      	; 0x1a4c <__vector_10+0x30>
    1a4a:	09 95       	icall
    1a4c:	ff 91       	pop	r31
    1a4e:	ef 91       	pop	r30
    1a50:	bf 91       	pop	r27
    1a52:	af 91       	pop	r26
    1a54:	9f 91       	pop	r25
    1a56:	8f 91       	pop	r24
    1a58:	7f 91       	pop	r23
    1a5a:	6f 91       	pop	r22
    1a5c:	5f 91       	pop	r21
    1a5e:	4f 91       	pop	r20
    1a60:	3f 91       	pop	r19
    1a62:	2f 91       	pop	r18
    1a64:	0f 90       	pop	r0
    1a66:	0f be       	out	0x3f, r0	; 63
    1a68:	0f 90       	pop	r0
    1a6a:	1f 90       	pop	r1
    1a6c:	18 95       	reti

00001a6e <__vector_11>:
    1a6e:	1f 92       	push	r1
    1a70:	0f 92       	push	r0
    1a72:	0f b6       	in	r0, 0x3f	; 63
    1a74:	0f 92       	push	r0
    1a76:	11 24       	eor	r1, r1
    1a78:	2f 93       	push	r18
    1a7a:	3f 93       	push	r19
    1a7c:	4f 93       	push	r20
    1a7e:	5f 93       	push	r21
    1a80:	6f 93       	push	r22
    1a82:	7f 93       	push	r23
    1a84:	8f 93       	push	r24
    1a86:	9f 93       	push	r25
    1a88:	af 93       	push	r26
    1a8a:	bf 93       	push	r27
    1a8c:	ef 93       	push	r30
    1a8e:	ff 93       	push	r31
    1a90:	e0 91 9e 07 	lds	r30, 0x079E	; 0x80079e <TMR_Timer0_OVF_PCallBack>
    1a94:	f0 91 9f 07 	lds	r31, 0x079F	; 0x80079f <TMR_Timer0_OVF_PCallBack+0x1>
    1a98:	30 97       	sbiw	r30, 0x00	; 0
    1a9a:	09 f0       	breq	.+2      	; 0x1a9e <__vector_11+0x30>
    1a9c:	09 95       	icall
    1a9e:	ff 91       	pop	r31
    1aa0:	ef 91       	pop	r30
    1aa2:	bf 91       	pop	r27
    1aa4:	af 91       	pop	r26
    1aa6:	9f 91       	pop	r25
    1aa8:	8f 91       	pop	r24
    1aaa:	7f 91       	pop	r23
    1aac:	6f 91       	pop	r22
    1aae:	5f 91       	pop	r21
    1ab0:	4f 91       	pop	r20
    1ab2:	3f 91       	pop	r19
    1ab4:	2f 91       	pop	r18
    1ab6:	0f 90       	pop	r0
    1ab8:	0f be       	out	0x3f, r0	; 63
    1aba:	0f 90       	pop	r0
    1abc:	1f 90       	pop	r1
    1abe:	18 95       	reti

00001ac0 <TMR_Timer1Init>:
    1ac0:	81 b3       	in	r24, 0x11	; 17
    1ac2:	80 62       	ori	r24, 0x20	; 32
    1ac4:	81 bb       	out	0x11, r24	; 17
    1ac6:	81 b3       	in	r24, 0x11	; 17
    1ac8:	80 61       	ori	r24, 0x10	; 16
    1aca:	81 bb       	out	0x11, r24	; 17
    1acc:	8f b5       	in	r24, 0x2f	; 47
    1ace:	8e 7f       	andi	r24, 0xFE	; 254
    1ad0:	8f bd       	out	0x2f, r24	; 47
    1ad2:	8f b5       	in	r24, 0x2f	; 47
    1ad4:	82 60       	ori	r24, 0x02	; 2
    1ad6:	8f bd       	out	0x2f, r24	; 47
    1ad8:	8e b5       	in	r24, 0x2e	; 46
    1ada:	88 60       	ori	r24, 0x08	; 8
    1adc:	8e bd       	out	0x2e, r24	; 46
    1ade:	8e b5       	in	r24, 0x2e	; 46
    1ae0:	80 61       	ori	r24, 0x10	; 16
    1ae2:	8e bd       	out	0x2e, r24	; 46
    1ae4:	8f b5       	in	r24, 0x2f	; 47
    1ae6:	8f 7b       	andi	r24, 0xBF	; 191
    1ae8:	8f bd       	out	0x2f, r24	; 47
    1aea:	8f b5       	in	r24, 0x2f	; 47
    1aec:	80 68       	ori	r24, 0x80	; 128
    1aee:	8f bd       	out	0x2f, r24	; 47
    1af0:	08 95       	ret

00001af2 <TMR_Timer1Start>:
    1af2:	8e b5       	in	r24, 0x2e	; 46
    1af4:	81 60       	ori	r24, 0x01	; 1
    1af6:	8e bd       	out	0x2e, r24	; 46
    1af8:	8e b5       	in	r24, 0x2e	; 46
    1afa:	82 60       	ori	r24, 0x02	; 2
    1afc:	8e bd       	out	0x2e, r24	; 46
    1afe:	8e b5       	in	r24, 0x2e	; 46
    1b00:	8b 7f       	andi	r24, 0xFB	; 251
    1b02:	8e bd       	out	0x2e, r24	; 46
    1b04:	08 95       	ret

00001b06 <TMR_Timer1Stop>:
    1b06:	8e b5       	in	r24, 0x2e	; 46
    1b08:	8e 7f       	andi	r24, 0xFE	; 254
    1b0a:	8e bd       	out	0x2e, r24	; 46
    1b0c:	8e b5       	in	r24, 0x2e	; 46
    1b0e:	8d 7f       	andi	r24, 0xFD	; 253
    1b10:	8e bd       	out	0x2e, r24	; 46
    1b12:	8e b5       	in	r24, 0x2e	; 46
    1b14:	8b 7f       	andi	r24, 0xFB	; 251
    1b16:	8e bd       	out	0x2e, r24	; 46
    1b18:	08 95       	ret

00001b1a <TMR_Timer1SetPWMDutyCycle>:
    1b1a:	cf 93       	push	r28
    1b1c:	c8 2f       	mov	r28, r24
    1b1e:	65 36       	cpi	r22, 0x65	; 101
    1b20:	f0 f4       	brcc	.+60     	; 0x1b5e <TMR_Timer1SetPWMDutyCycle+0x44>
    1b22:	66 23       	and	r22, r22
    1b24:	81 f0       	breq	.+32     	; 0x1b46 <TMR_Timer1SetPWMDutyCycle+0x2c>
    1b26:	a6 b5       	in	r26, 0x26	; 38
    1b28:	b7 b5       	in	r27, 0x27	; 39
    1b2a:	11 96       	adiw	r26, 0x01	; 1
    1b2c:	26 2f       	mov	r18, r22
    1b2e:	30 e0       	ldi	r19, 0x00	; 0
    1b30:	0e 94 f6 12 	call	0x25ec	; 0x25ec <__umulhisi3>
    1b34:	24 e6       	ldi	r18, 0x64	; 100
    1b36:	30 e0       	ldi	r19, 0x00	; 0
    1b38:	40 e0       	ldi	r20, 0x00	; 0
    1b3a:	50 e0       	ldi	r21, 0x00	; 0
    1b3c:	0e 94 ce 12 	call	0x259c	; 0x259c <__udivmodsi4>
    1b40:	21 50       	subi	r18, 0x01	; 1
    1b42:	31 09       	sbc	r19, r1
    1b44:	02 c0       	rjmp	.+4      	; 0x1b4a <TMR_Timer1SetPWMDutyCycle+0x30>
    1b46:	26 e7       	ldi	r18, 0x76	; 118
    1b48:	31 e0       	ldi	r19, 0x01	; 1
    1b4a:	c1 30       	cpi	r28, 0x01	; 1
    1b4c:	19 f0       	breq	.+6      	; 0x1b54 <TMR_Timer1SetPWMDutyCycle+0x3a>
    1b4e:	c2 30       	cpi	r28, 0x02	; 2
    1b50:	21 f0       	breq	.+8      	; 0x1b5a <TMR_Timer1SetPWMDutyCycle+0x40>
    1b52:	05 c0       	rjmp	.+10     	; 0x1b5e <TMR_Timer1SetPWMDutyCycle+0x44>
    1b54:	3b bd       	out	0x2b, r19	; 43
    1b56:	2a bd       	out	0x2a, r18	; 42
    1b58:	02 c0       	rjmp	.+4      	; 0x1b5e <TMR_Timer1SetPWMDutyCycle+0x44>
    1b5a:	39 bd       	out	0x29, r19	; 41
    1b5c:	28 bd       	out	0x28, r18	; 40
    1b5e:	cf 91       	pop	r28
    1b60:	08 95       	ret

00001b62 <TMR_Timer1SetFastPWMFreq>:
    1b62:	61 30       	cpi	r22, 0x01	; 1
    1b64:	24 e2       	ldi	r18, 0x24	; 36
    1b66:	72 07       	cpc	r23, r18
    1b68:	24 ef       	ldi	r18, 0xF4	; 244
    1b6a:	82 07       	cpc	r24, r18
    1b6c:	91 05       	cpc	r25, r1
    1b6e:	30 f5       	brcc	.+76     	; 0x1bbc <TMR_Timer1SetFastPWMFreq+0x5a>
    1b70:	dc 01       	movw	r26, r24
    1b72:	cb 01       	movw	r24, r22
    1b74:	88 0f       	add	r24, r24
    1b76:	99 1f       	adc	r25, r25
    1b78:	aa 1f       	adc	r26, r26
    1b7a:	bb 1f       	adc	r27, r27
    1b7c:	88 0f       	add	r24, r24
    1b7e:	99 1f       	adc	r25, r25
    1b80:	aa 1f       	adc	r26, r26
    1b82:	bb 1f       	adc	r27, r27
    1b84:	88 0f       	add	r24, r24
    1b86:	99 1f       	adc	r25, r25
    1b88:	aa 1f       	adc	r26, r26
    1b8a:	bb 1f       	adc	r27, r27
    1b8c:	88 0f       	add	r24, r24
    1b8e:	99 1f       	adc	r25, r25
    1b90:	aa 1f       	adc	r26, r26
    1b92:	bb 1f       	adc	r27, r27
    1b94:	9c 01       	movw	r18, r24
    1b96:	ad 01       	movw	r20, r26
    1b98:	22 0f       	add	r18, r18
    1b9a:	33 1f       	adc	r19, r19
    1b9c:	44 1f       	adc	r20, r20
    1b9e:	55 1f       	adc	r21, r21
    1ba0:	22 0f       	add	r18, r18
    1ba2:	33 1f       	adc	r19, r19
    1ba4:	44 1f       	adc	r20, r20
    1ba6:	55 1f       	adc	r21, r21
    1ba8:	60 e0       	ldi	r22, 0x00	; 0
    1baa:	74 e2       	ldi	r23, 0x24	; 36
    1bac:	84 ef       	ldi	r24, 0xF4	; 244
    1bae:	90 e0       	ldi	r25, 0x00	; 0
    1bb0:	0e 94 ce 12 	call	0x259c	; 0x259c <__udivmodsi4>
    1bb4:	21 50       	subi	r18, 0x01	; 1
    1bb6:	31 09       	sbc	r19, r1
    1bb8:	37 bd       	out	0x27, r19	; 39
    1bba:	26 bd       	out	0x26, r18	; 38
    1bbc:	08 95       	ret

00001bbe <__vector_7>:
    1bbe:	1f 92       	push	r1
    1bc0:	0f 92       	push	r0
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	0f 92       	push	r0
    1bc6:	11 24       	eor	r1, r1
    1bc8:	2f 93       	push	r18
    1bca:	3f 93       	push	r19
    1bcc:	4f 93       	push	r20
    1bce:	5f 93       	push	r21
    1bd0:	6f 93       	push	r22
    1bd2:	7f 93       	push	r23
    1bd4:	8f 93       	push	r24
    1bd6:	9f 93       	push	r25
    1bd8:	af 93       	push	r26
    1bda:	bf 93       	push	r27
    1bdc:	ef 93       	push	r30
    1bde:	ff 93       	push	r31
    1be0:	e0 91 9a 07 	lds	r30, 0x079A	; 0x80079a <TMR_Timer1_CTC1A_PCallBack>
    1be4:	f0 91 9b 07 	lds	r31, 0x079B	; 0x80079b <TMR_Timer1_CTC1A_PCallBack+0x1>
    1be8:	30 97       	sbiw	r30, 0x00	; 0
    1bea:	09 f0       	breq	.+2      	; 0x1bee <__vector_7+0x30>
    1bec:	09 95       	icall
    1bee:	ff 91       	pop	r31
    1bf0:	ef 91       	pop	r30
    1bf2:	bf 91       	pop	r27
    1bf4:	af 91       	pop	r26
    1bf6:	9f 91       	pop	r25
    1bf8:	8f 91       	pop	r24
    1bfa:	7f 91       	pop	r23
    1bfc:	6f 91       	pop	r22
    1bfe:	5f 91       	pop	r21
    1c00:	4f 91       	pop	r20
    1c02:	3f 91       	pop	r19
    1c04:	2f 91       	pop	r18
    1c06:	0f 90       	pop	r0
    1c08:	0f be       	out	0x3f, r0	; 63
    1c0a:	0f 90       	pop	r0
    1c0c:	1f 90       	pop	r1
    1c0e:	18 95       	reti

00001c10 <__vector_8>:
    1c10:	1f 92       	push	r1
    1c12:	0f 92       	push	r0
    1c14:	0f b6       	in	r0, 0x3f	; 63
    1c16:	0f 92       	push	r0
    1c18:	11 24       	eor	r1, r1
    1c1a:	2f 93       	push	r18
    1c1c:	3f 93       	push	r19
    1c1e:	4f 93       	push	r20
    1c20:	5f 93       	push	r21
    1c22:	6f 93       	push	r22
    1c24:	7f 93       	push	r23
    1c26:	8f 93       	push	r24
    1c28:	9f 93       	push	r25
    1c2a:	af 93       	push	r26
    1c2c:	bf 93       	push	r27
    1c2e:	ef 93       	push	r30
    1c30:	ff 93       	push	r31
    1c32:	e0 91 98 07 	lds	r30, 0x0798	; 0x800798 <TMR_Timer1_CTC1B_PCallBack>
    1c36:	f0 91 99 07 	lds	r31, 0x0799	; 0x800799 <TMR_Timer1_CTC1B_PCallBack+0x1>
    1c3a:	30 97       	sbiw	r30, 0x00	; 0
    1c3c:	09 f0       	breq	.+2      	; 0x1c40 <__vector_8+0x30>
    1c3e:	09 95       	icall
    1c40:	ff 91       	pop	r31
    1c42:	ef 91       	pop	r30
    1c44:	bf 91       	pop	r27
    1c46:	af 91       	pop	r26
    1c48:	9f 91       	pop	r25
    1c4a:	8f 91       	pop	r24
    1c4c:	7f 91       	pop	r23
    1c4e:	6f 91       	pop	r22
    1c50:	5f 91       	pop	r21
    1c52:	4f 91       	pop	r20
    1c54:	3f 91       	pop	r19
    1c56:	2f 91       	pop	r18
    1c58:	0f 90       	pop	r0
    1c5a:	0f be       	out	0x3f, r0	; 63
    1c5c:	0f 90       	pop	r0
    1c5e:	1f 90       	pop	r1
    1c60:	18 95       	reti

00001c62 <__vector_9>:
    1c62:	1f 92       	push	r1
    1c64:	0f 92       	push	r0
    1c66:	0f b6       	in	r0, 0x3f	; 63
    1c68:	0f 92       	push	r0
    1c6a:	11 24       	eor	r1, r1
    1c6c:	2f 93       	push	r18
    1c6e:	3f 93       	push	r19
    1c70:	4f 93       	push	r20
    1c72:	5f 93       	push	r21
    1c74:	6f 93       	push	r22
    1c76:	7f 93       	push	r23
    1c78:	8f 93       	push	r24
    1c7a:	9f 93       	push	r25
    1c7c:	af 93       	push	r26
    1c7e:	bf 93       	push	r27
    1c80:	ef 93       	push	r30
    1c82:	ff 93       	push	r31
    1c84:	e0 91 9c 07 	lds	r30, 0x079C	; 0x80079c <TMR_Timer1_OVF_PCallBack>
    1c88:	f0 91 9d 07 	lds	r31, 0x079D	; 0x80079d <TMR_Timer1_OVF_PCallBack+0x1>
    1c8c:	30 97       	sbiw	r30, 0x00	; 0
    1c8e:	09 f0       	breq	.+2      	; 0x1c92 <__vector_9+0x30>
    1c90:	09 95       	icall
    1c92:	ff 91       	pop	r31
    1c94:	ef 91       	pop	r30
    1c96:	bf 91       	pop	r27
    1c98:	af 91       	pop	r26
    1c9a:	9f 91       	pop	r25
    1c9c:	8f 91       	pop	r24
    1c9e:	7f 91       	pop	r23
    1ca0:	6f 91       	pop	r22
    1ca2:	5f 91       	pop	r21
    1ca4:	4f 91       	pop	r20
    1ca6:	3f 91       	pop	r19
    1ca8:	2f 91       	pop	r18
    1caa:	0f 90       	pop	r0
    1cac:	0f be       	out	0x3f, r0	; 63
    1cae:	0f 90       	pop	r0
    1cb0:	1f 90       	pop	r1
    1cb2:	18 95       	reti

00001cb4 <TMR_Timer2Init>:
    1cb4:	85 b5       	in	r24, 0x25	; 37
    1cb6:	80 64       	ori	r24, 0x40	; 64
    1cb8:	85 bd       	out	0x25, r24	; 37
    1cba:	85 b5       	in	r24, 0x25	; 37
    1cbc:	88 60       	ori	r24, 0x08	; 8
    1cbe:	85 bd       	out	0x25, r24	; 37
    1cc0:	81 b3       	in	r24, 0x11	; 17
    1cc2:	80 68       	ori	r24, 0x80	; 128
    1cc4:	81 bb       	out	0x11, r24	; 17
    1cc6:	85 b5       	in	r24, 0x25	; 37
    1cc8:	8f 7e       	andi	r24, 0xEF	; 239
    1cca:	85 bd       	out	0x25, r24	; 37
    1ccc:	85 b5       	in	r24, 0x25	; 37
    1cce:	80 62       	ori	r24, 0x20	; 32
    1cd0:	85 bd       	out	0x25, r24	; 37
    1cd2:	08 95       	ret

00001cd4 <TMR_Timer2Start>:
    1cd4:	85 b5       	in	r24, 0x25	; 37
    1cd6:	81 60       	ori	r24, 0x01	; 1
    1cd8:	85 bd       	out	0x25, r24	; 37
    1cda:	85 b5       	in	r24, 0x25	; 37
    1cdc:	8d 7f       	andi	r24, 0xFD	; 253
    1cde:	85 bd       	out	0x25, r24	; 37
    1ce0:	85 b5       	in	r24, 0x25	; 37
    1ce2:	8b 7f       	andi	r24, 0xFB	; 251
    1ce4:	85 bd       	out	0x25, r24	; 37
    1ce6:	08 95       	ret

00001ce8 <TMR_Timer2Stop>:
    1ce8:	85 b5       	in	r24, 0x25	; 37
    1cea:	8e 7f       	andi	r24, 0xFE	; 254
    1cec:	85 bd       	out	0x25, r24	; 37
    1cee:	85 b5       	in	r24, 0x25	; 37
    1cf0:	8d 7f       	andi	r24, 0xFD	; 253
    1cf2:	85 bd       	out	0x25, r24	; 37
    1cf4:	85 b5       	in	r24, 0x25	; 37
    1cf6:	8b 7f       	andi	r24, 0xFB	; 251
    1cf8:	85 bd       	out	0x25, r24	; 37
    1cfa:	08 95       	ret

00001cfc <TMR_Timer2Set_PWM_DutyCycle>:
    1cfc:	85 36       	cpi	r24, 0x65	; 101
    1cfe:	78 f4       	brcc	.+30     	; 0x1d1e <TMR_Timer2Set_PWM_DutyCycle+0x22>
    1d00:	9f ef       	ldi	r25, 0xFF	; 255
    1d02:	89 9f       	mul	r24, r25
    1d04:	b0 01       	movw	r22, r0
    1d06:	11 24       	eor	r1, r1
    1d08:	07 2e       	mov	r0, r23
    1d0a:	00 0c       	add	r0, r0
    1d0c:	88 0b       	sbc	r24, r24
    1d0e:	99 0b       	sbc	r25, r25
    1d10:	24 e6       	ldi	r18, 0x64	; 100
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	40 e0       	ldi	r20, 0x00	; 0
    1d16:	50 e0       	ldi	r21, 0x00	; 0
    1d18:	0e 94 ce 12 	call	0x259c	; 0x259c <__udivmodsi4>
    1d1c:	23 bd       	out	0x23, r18	; 35
    1d1e:	08 95       	ret

00001d20 <__vector_4>:
    }
}
//ISR Function prototype for CTC2
void __vector_4(void) __attribute__ ((signal));
void __vector_4(void)
{
    1d20:	1f 92       	push	r1
    1d22:	0f 92       	push	r0
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	0f 92       	push	r0
    1d28:	11 24       	eor	r1, r1
    1d2a:	2f 93       	push	r18
    1d2c:	3f 93       	push	r19
    1d2e:	4f 93       	push	r20
    1d30:	5f 93       	push	r21
    1d32:	6f 93       	push	r22
    1d34:	7f 93       	push	r23
    1d36:	8f 93       	push	r24
    1d38:	9f 93       	push	r25
    1d3a:	af 93       	push	r26
    1d3c:	bf 93       	push	r27
    1d3e:	ef 93       	push	r30
    1d40:	ff 93       	push	r31
    if(TMR_Timer2_CTC_PCallBack != NULL)
    1d42:	e0 91 94 07 	lds	r30, 0x0794	; 0x800794 <TMR_Timer2_CTC_PCallBack>
    1d46:	f0 91 95 07 	lds	r31, 0x0795	; 0x800795 <TMR_Timer2_CTC_PCallBack+0x1>
    1d4a:	30 97       	sbiw	r30, 0x00	; 0
    1d4c:	09 f0       	breq	.+2      	; 0x1d50 <__vector_4+0x30>
    {
        TMR_Timer2_CTC_PCallBack();
    1d4e:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1d50:	ff 91       	pop	r31
    1d52:	ef 91       	pop	r30
    1d54:	bf 91       	pop	r27
    1d56:	af 91       	pop	r26
    1d58:	9f 91       	pop	r25
    1d5a:	8f 91       	pop	r24
    1d5c:	7f 91       	pop	r23
    1d5e:	6f 91       	pop	r22
    1d60:	5f 91       	pop	r21
    1d62:	4f 91       	pop	r20
    1d64:	3f 91       	pop	r19
    1d66:	2f 91       	pop	r18
    1d68:	0f 90       	pop	r0
    1d6a:	0f be       	out	0x3f, r0	; 63
    1d6c:	0f 90       	pop	r0
    1d6e:	1f 90       	pop	r1
    1d70:	18 95       	reti

00001d72 <__vector_5>:

//ISR Function prototype for OVF2
void __vector_5(void) __attribute__ ((signal));
void __vector_5(void)
{
    1d72:	1f 92       	push	r1
    1d74:	0f 92       	push	r0
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	0f 92       	push	r0
    1d7a:	11 24       	eor	r1, r1
    1d7c:	2f 93       	push	r18
    1d7e:	3f 93       	push	r19
    1d80:	4f 93       	push	r20
    1d82:	5f 93       	push	r21
    1d84:	6f 93       	push	r22
    1d86:	7f 93       	push	r23
    1d88:	8f 93       	push	r24
    1d8a:	9f 93       	push	r25
    1d8c:	af 93       	push	r26
    1d8e:	bf 93       	push	r27
    1d90:	ef 93       	push	r30
    1d92:	ff 93       	push	r31
    if(TMR_Timer2_OVF_PCallBack != NULL)
    1d94:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <TMR_Timer2_OVF_PCallBack>
    1d98:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <TMR_Timer2_OVF_PCallBack+0x1>
    1d9c:	30 97       	sbiw	r30, 0x00	; 0
    1d9e:	09 f0       	breq	.+2      	; 0x1da2 <__vector_5+0x30>
    {
        TMR_Timer2_OVF_PCallBack();
    1da0:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1da2:	ff 91       	pop	r31
    1da4:	ef 91       	pop	r30
    1da6:	bf 91       	pop	r27
    1da8:	af 91       	pop	r26
    1daa:	9f 91       	pop	r25
    1dac:	8f 91       	pop	r24
    1dae:	7f 91       	pop	r23
    1db0:	6f 91       	pop	r22
    1db2:	5f 91       	pop	r21
    1db4:	4f 91       	pop	r20
    1db6:	3f 91       	pop	r19
    1db8:	2f 91       	pop	r18
    1dba:	0f 90       	pop	r0
    1dbc:	0f be       	out	0x3f, r0	; 63
    1dbe:	0f 90       	pop	r0
    1dc0:	1f 90       	pop	r1
    1dc2:	18 95       	reti

00001dc4 <UART_Init>:
 */
void UART_DataRegEmptySetCallback   (ptr_to_func_t P_DataRegEmptySetCallback)
{
    if(P_DataRegEmptySetCallback != NULL)
    {
        UART_DataRegEmpty_PCallback = P_DataRegEmptySetCallback;
    1dc4:	8a b1       	in	r24, 0x0a	; 10
    1dc6:	8b 7f       	andi	r24, 0xFB	; 251
    1dc8:	8a b9       	out	0x0a, r24	; 10
    1dca:	86 e8       	ldi	r24, 0x86	; 134
    1dcc:	80 bd       	out	0x20, r24	; 32
    1dce:	87 e6       	ldi	r24, 0x67	; 103
    1dd0:	89 b9       	out	0x09, r24	; 9
    1dd2:	10 bc       	out	0x20, r1	; 32
    1dd4:	8a b1       	in	r24, 0x0a	; 10
    1dd6:	80 68       	ori	r24, 0x80	; 128
    1dd8:	8a b9       	out	0x0a, r24	; 10
    1dda:	8a b1       	in	r24, 0x0a	; 10
    1ddc:	8f 7b       	andi	r24, 0xBF	; 191
    1dde:	8a b9       	out	0x0a, r24	; 10
    1de0:	8a b1       	in	r24, 0x0a	; 10
    1de2:	8f 7d       	andi	r24, 0xDF	; 223
    1de4:	8a b9       	out	0x0a, r24	; 10
    1de6:	8a b1       	in	r24, 0x0a	; 10
    1de8:	88 60       	ori	r24, 0x08	; 8
    1dea:	8a b9       	out	0x0a, r24	; 10
    1dec:	8a b1       	in	r24, 0x0a	; 10
    1dee:	80 61       	ori	r24, 0x10	; 16
    1df0:	8a b9       	out	0x0a, r24	; 10
    1df2:	08 95       	ret

00001df4 <UART_TxChar>:
    1df4:	8c b9       	out	0x0c, r24	; 12
    1df6:	5d 9b       	sbis	0x0b, 5	; 11
    1df8:	fe cf       	rjmp	.-4      	; 0x1df6 <UART_TxChar+0x2>
    1dfa:	08 95       	ret

00001dfc <UART_RxCharAsynchronous>:
    1dfc:	00 97       	sbiw	r24, 0x00	; 0
    1dfe:	19 f0       	breq	.+6      	; 0x1e06 <UART_RxCharAsynchronous+0xa>
    1e00:	2c b1       	in	r18, 0x0c	; 12
    1e02:	fc 01       	movw	r30, r24
    1e04:	20 83       	st	Z, r18
    1e06:	08 95       	ret

00001e08 <UART_TxString>:
    1e08:	0f 93       	push	r16
    1e0a:	1f 93       	push	r17
    1e0c:	cf 93       	push	r28
    1e0e:	00 97       	sbiw	r24, 0x00	; 0
    1e10:	29 f4       	brne	.+10     	; 0x1e1c <UART_TxString+0x14>
    1e12:	0f c0       	rjmp	.+30     	; 0x1e32 <UART_TxString+0x2a>
    1e14:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
    1e18:	cf 5f       	subi	r28, 0xFF	; 255
    1e1a:	02 c0       	rjmp	.+4      	; 0x1e20 <UART_TxString+0x18>
    1e1c:	8c 01       	movw	r16, r24
    1e1e:	c0 e0       	ldi	r28, 0x00	; 0
    1e20:	f8 01       	movw	r30, r16
    1e22:	ec 0f       	add	r30, r28
    1e24:	f1 1d       	adc	r31, r1
    1e26:	80 81       	ld	r24, Z
    1e28:	81 11       	cpse	r24, r1
    1e2a:	f4 cf       	rjmp	.-24     	; 0x1e14 <UART_TxString+0xc>
    1e2c:	8d e0       	ldi	r24, 0x0D	; 13
    1e2e:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <UART_TxChar>
    1e32:	cf 91       	pop	r28
    1e34:	1f 91       	pop	r17
    1e36:	0f 91       	pop	r16
    1e38:	08 95       	ret

00001e3a <UART_RxCompleteSetCallback>:
    1e3a:	00 97       	sbiw	r24, 0x00	; 0
    1e3c:	21 f0       	breq	.+8      	; 0x1e46 <UART_RxCompleteSetCallback+0xc>
    1e3e:	90 93 a5 07 	sts	0x07A5, r25	; 0x8007a5 <UART_RxComplete_PCallback+0x1>
    1e42:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <UART_RxComplete_PCallback>
    1e46:	08 95       	ret

00001e48 <__vector_13>:
}

/*ISR Function for UART Rx Complete Interrupt*/
void __vector_13(void) __attribute__ ((signal));
void __vector_13(void)
{
    1e48:	1f 92       	push	r1
    1e4a:	0f 92       	push	r0
    1e4c:	0f b6       	in	r0, 0x3f	; 63
    1e4e:	0f 92       	push	r0
    1e50:	11 24       	eor	r1, r1
    1e52:	2f 93       	push	r18
    1e54:	3f 93       	push	r19
    1e56:	4f 93       	push	r20
    1e58:	5f 93       	push	r21
    1e5a:	6f 93       	push	r22
    1e5c:	7f 93       	push	r23
    1e5e:	8f 93       	push	r24
    1e60:	9f 93       	push	r25
    1e62:	af 93       	push	r26
    1e64:	bf 93       	push	r27
    1e66:	ef 93       	push	r30
    1e68:	ff 93       	push	r31
    if(UART_RxComplete_PCallback != NULL)
    1e6a:	e0 91 a4 07 	lds	r30, 0x07A4	; 0x8007a4 <UART_RxComplete_PCallback>
    1e6e:	f0 91 a5 07 	lds	r31, 0x07A5	; 0x8007a5 <UART_RxComplete_PCallback+0x1>
    1e72:	30 97       	sbiw	r30, 0x00	; 0
    1e74:	09 f0       	breq	.+2      	; 0x1e78 <__vector_13+0x30>
    {
        UART_RxComplete_PCallback();
    1e76:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1e78:	ff 91       	pop	r31
    1e7a:	ef 91       	pop	r30
    1e7c:	bf 91       	pop	r27
    1e7e:	af 91       	pop	r26
    1e80:	9f 91       	pop	r25
    1e82:	8f 91       	pop	r24
    1e84:	7f 91       	pop	r23
    1e86:	6f 91       	pop	r22
    1e88:	5f 91       	pop	r21
    1e8a:	4f 91       	pop	r20
    1e8c:	3f 91       	pop	r19
    1e8e:	2f 91       	pop	r18
    1e90:	0f 90       	pop	r0
    1e92:	0f be       	out	0x3f, r0	; 63
    1e94:	0f 90       	pop	r0
    1e96:	1f 90       	pop	r1
    1e98:	18 95       	reti

00001e9a <__vector_14>:

/*ISR Function for UART Data Register Empty Interrupt*/
void __vector_14(void) __attribute__ ((signal));
void __vector_14(void)
{
    1e9a:	1f 92       	push	r1
    1e9c:	0f 92       	push	r0
    1e9e:	0f b6       	in	r0, 0x3f	; 63
    1ea0:	0f 92       	push	r0
    1ea2:	11 24       	eor	r1, r1
    1ea4:	2f 93       	push	r18
    1ea6:	3f 93       	push	r19
    1ea8:	4f 93       	push	r20
    1eaa:	5f 93       	push	r21
    1eac:	6f 93       	push	r22
    1eae:	7f 93       	push	r23
    1eb0:	8f 93       	push	r24
    1eb2:	9f 93       	push	r25
    1eb4:	af 93       	push	r26
    1eb6:	bf 93       	push	r27
    1eb8:	ef 93       	push	r30
    1eba:	ff 93       	push	r31
    if(UART_DataRegEmpty_PCallback != NULL)
    1ebc:	e0 91 a2 07 	lds	r30, 0x07A2	; 0x8007a2 <UART_DataRegEmpty_PCallback>
    1ec0:	f0 91 a3 07 	lds	r31, 0x07A3	; 0x8007a3 <UART_DataRegEmpty_PCallback+0x1>
    1ec4:	30 97       	sbiw	r30, 0x00	; 0
    1ec6:	09 f0       	breq	.+2      	; 0x1eca <__vector_14+0x30>
    {
        UART_DataRegEmpty_PCallback();
    1ec8:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1eca:	ff 91       	pop	r31
    1ecc:	ef 91       	pop	r30
    1ece:	bf 91       	pop	r27
    1ed0:	af 91       	pop	r26
    1ed2:	9f 91       	pop	r25
    1ed4:	8f 91       	pop	r24
    1ed6:	7f 91       	pop	r23
    1ed8:	6f 91       	pop	r22
    1eda:	5f 91       	pop	r21
    1edc:	4f 91       	pop	r20
    1ede:	3f 91       	pop	r19
    1ee0:	2f 91       	pop	r18
    1ee2:	0f 90       	pop	r0
    1ee4:	0f be       	out	0x3f, r0	; 63
    1ee6:	0f 90       	pop	r0
    1ee8:	1f 90       	pop	r1
    1eea:	18 95       	reti

00001eec <__vector_15>:

/*ISR Function for UART Tx Complete Interrupt*/
void __vector_15(void) __attribute__ ((signal));
void __vector_15(void)
{
    1eec:	1f 92       	push	r1
    1eee:	0f 92       	push	r0
    1ef0:	0f b6       	in	r0, 0x3f	; 63
    1ef2:	0f 92       	push	r0
    1ef4:	11 24       	eor	r1, r1
    1ef6:	2f 93       	push	r18
    1ef8:	3f 93       	push	r19
    1efa:	4f 93       	push	r20
    1efc:	5f 93       	push	r21
    1efe:	6f 93       	push	r22
    1f00:	7f 93       	push	r23
    1f02:	8f 93       	push	r24
    1f04:	9f 93       	push	r25
    1f06:	af 93       	push	r26
    1f08:	bf 93       	push	r27
    1f0a:	ef 93       	push	r30
    1f0c:	ff 93       	push	r31
    if(UART_TxComplete_PCallback != NULL)
    1f0e:	e0 91 a6 07 	lds	r30, 0x07A6	; 0x8007a6 <UART_TxComplete_PCallback>
    1f12:	f0 91 a7 07 	lds	r31, 0x07A7	; 0x8007a7 <UART_TxComplete_PCallback+0x1>
    1f16:	30 97       	sbiw	r30, 0x00	; 0
    1f18:	09 f0       	breq	.+2      	; 0x1f1c <__vector_15+0x30>
    {
        UART_TxComplete_PCallback();
    1f1a:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
    1f1c:	ff 91       	pop	r31
    1f1e:	ef 91       	pop	r30
    1f20:	bf 91       	pop	r27
    1f22:	af 91       	pop	r26
    1f24:	9f 91       	pop	r25
    1f26:	8f 91       	pop	r24
    1f28:	7f 91       	pop	r23
    1f2a:	6f 91       	pop	r22
    1f2c:	5f 91       	pop	r21
    1f2e:	4f 91       	pop	r20
    1f30:	3f 91       	pop	r19
    1f32:	2f 91       	pop	r18
    1f34:	0f 90       	pop	r0
    1f36:	0f be       	out	0x3f, r0	; 63
    1f38:	0f 90       	pop	r0
    1f3a:	1f 90       	pop	r1
    1f3c:	18 95       	reti

00001f3e <USER_PROGRAM_START>:


u8 USER_EXIST(void)
{
	return user_exist;
}
    1f3e:	0e 94 3d 0b 	call	0x167a	; 0x167a <LCD_Init>
    1f42:	0e 94 b4 09 	call	0x1368	; 0x1368 <KPD_Init>
    1f46:	41 e0       	ldi	r20, 0x01	; 1
    1f48:	62 e0       	ldi	r22, 0x02	; 2
    1f4a:	82 e0       	ldi	r24, 0x02	; 2
    1f4c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    1f50:	41 e0       	ldi	r20, 0x01	; 1
    1f52:	67 e0       	ldi	r22, 0x07	; 7
    1f54:	82 e0       	ldi	r24, 0x02	; 2
    1f56:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    1f5a:	41 e0       	ldi	r20, 0x01	; 1
    1f5c:	67 e0       	ldi	r22, 0x07	; 7
    1f5e:	83 e0       	ldi	r24, 0x03	; 3
    1f60:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <DIO_SetPinDirection>
    1f64:	88 e2       	ldi	r24, 0x28	; 40
    1f66:	96 e0       	ldi	r25, 0x06	; 6
    1f68:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    1f6c:	60 e0       	ldi	r22, 0x00	; 0
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    1f74:	83 e3       	ldi	r24, 0x33	; 51
    1f76:	96 e0       	ldi	r25, 0x06	; 6
    1f78:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    1f7c:	2f ef       	ldi	r18, 0xFF	; 255
    1f7e:	83 ed       	ldi	r24, 0xD3	; 211
    1f80:	90 e3       	ldi	r25, 0x30	; 48
    1f82:	21 50       	subi	r18, 0x01	; 1
    1f84:	80 40       	sbci	r24, 0x00	; 0
    1f86:	90 40       	sbci	r25, 0x00	; 0
    1f88:	e1 f7       	brne	.-8      	; 0x1f82 <USER_PROGRAM_START+0x44>
    1f8a:	00 c0       	rjmp	.+0      	; 0x1f8c <USER_PROGRAM_START+0x4e>
    1f8c:	00 00       	nop
    1f8e:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    1f92:	08 95       	ret

00001f94 <USER_LOGIN>:
    1f94:	ff 92       	push	r15
    1f96:	0f 93       	push	r16
    1f98:	1f 93       	push	r17
    1f9a:	cf 93       	push	r28
    1f9c:	df 93       	push	r29
    1f9e:	00 d0       	rcall	.+0      	; 0x1fa0 <USER_LOGIN+0xc>
    1fa0:	00 d0       	rcall	.+0      	; 0x1fa2 <USER_LOGIN+0xe>
    1fa2:	00 d0       	rcall	.+0      	; 0x1fa4 <USER_LOGIN+0x10>
    1fa4:	cd b7       	in	r28, 0x3d	; 61
    1fa6:	de b7       	in	r29, 0x3e	; 62
    1fa8:	8f ef       	ldi	r24, 0xFF	; 255
    1faa:	89 83       	std	Y+1, r24	; 0x01
    1fac:	8e e3       	ldi	r24, 0x3E	; 62
    1fae:	96 e0       	ldi	r25, 0x06	; 6
    1fb0:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    1fb4:	04 c0       	rjmp	.+8      	; 0x1fbe <USER_LOGIN+0x2a>
    1fb6:	ce 01       	movw	r24, r28
    1fb8:	01 96       	adiw	r24, 0x01	; 1
    1fba:	0e 94 01 0a 	call	0x1402	; 0x1402 <KPD_GetValue>
    1fbe:	89 81       	ldd	r24, Y+1	; 0x01
    1fc0:	8f 3f       	cpi	r24, 0xFF	; 255
    1fc2:	c9 f3       	breq	.-14     	; 0x1fb6 <USER_LOGIN+0x22>
    1fc4:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <LCD_WriteChar4Bit>
    1fc8:	2f ef       	ldi	r18, 0xFF	; 255
    1fca:	83 ed       	ldi	r24, 0xD3	; 211
    1fcc:	90 e3       	ldi	r25, 0x30	; 48
    1fce:	21 50       	subi	r18, 0x01	; 1
    1fd0:	80 40       	sbci	r24, 0x00	; 0
    1fd2:	90 40       	sbci	r25, 0x00	; 0
    1fd4:	e1 f7       	brne	.-8      	; 0x1fce <USER_LOGIN+0x3a>
    1fd6:	00 c0       	rjmp	.+0      	; 0x1fd8 <USER_LOGIN+0x44>
    1fd8:	00 00       	nop
    1fda:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    1fde:	8d e4       	ldi	r24, 0x4D	; 77
    1fe0:	96 e0       	ldi	r25, 0x06	; 6
    1fe2:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    1fe6:	60 e0       	ldi	r22, 0x00	; 0
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    1fee:	f1 2c       	mov	r15, r1
    1ff0:	02 e0       	ldi	r16, 0x02	; 2
    1ff2:	10 e0       	ldi	r17, 0x00	; 0
    1ff4:	0c 0f       	add	r16, r28
    1ff6:	1d 1f       	adc	r17, r29
    1ff8:	0f 0d       	add	r16, r15
    1ffa:	11 1d       	adc	r17, r1
    1ffc:	c8 01       	movw	r24, r16
    1ffe:	0e 94 01 0a 	call	0x1402	; 0x1402 <KPD_GetValue>
    2002:	f8 01       	movw	r30, r16
    2004:	80 81       	ld	r24, Z
    2006:	8f 3f       	cpi	r24, 0xFF	; 255
    2008:	99 f3       	breq	.-26     	; 0x1ff0 <USER_LOGIN+0x5c>
    200a:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <LCD_WriteChar4Bit>
    200e:	f3 94       	inc	r15
    2010:	f3 e0       	ldi	r31, 0x03	; 3
    2012:	ff 12       	cpse	r15, r31
    2014:	ed cf       	rjmp	.-38     	; 0x1ff0 <USER_LOGIN+0x5c>
    2016:	2f ef       	ldi	r18, 0xFF	; 255
    2018:	83 ed       	ldi	r24, 0xD3	; 211
    201a:	90 e3       	ldi	r25, 0x30	; 48
    201c:	21 50       	subi	r18, 0x01	; 1
    201e:	80 40       	sbci	r24, 0x00	; 0
    2020:	90 40       	sbci	r25, 0x00	; 0
    2022:	e1 f7       	brne	.-8      	; 0x201c <USER_LOGIN+0x88>
    2024:	00 c0       	rjmp	.+0      	; 0x2026 <USER_LOGIN+0x92>
    2026:	00 00       	nop
    2028:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    202c:	1d 82       	std	Y+5, r1	; 0x05
    202e:	1e 82       	std	Y+6, r1	; 0x06
    2030:	be 01       	movw	r22, r28
    2032:	6b 5f       	subi	r22, 0xFB	; 251
    2034:	7f 4f       	sbci	r23, 0xFF	; 255
    2036:	8a e0       	ldi	r24, 0x0A	; 10
    2038:	90 e0       	ldi	r25, 0x00	; 0
    203a:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
    203e:	10 e0       	ldi	r17, 0x00	; 0
    2040:	01 e0       	ldi	r16, 0x01	; 1
    2042:	10 c0       	rjmp	.+32     	; 0x2064 <USER_LOGIN+0xd0>
    2044:	10 2f       	mov	r17, r16
    2046:	11 0f       	add	r17, r17
    2048:	11 0f       	add	r17, r17
    204a:	1e 5c       	subi	r17, 0xCE	; 206
    204c:	be 01       	movw	r22, r28
    204e:	6a 5f       	subi	r22, 0xFA	; 250
    2050:	7f 4f       	sbci	r23, 0xFF	; 255
    2052:	81 2f       	mov	r24, r17
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
    205a:	9e 81       	ldd	r25, Y+6	; 0x06
    205c:	89 81       	ldd	r24, Y+1	; 0x01
    205e:	98 17       	cp	r25, r24
    2060:	31 f0       	breq	.+12     	; 0x206e <USER_LOGIN+0xda>
    2062:	0f 5f       	subi	r16, 0xFF	; 255
    2064:	8d 81       	ldd	r24, Y+5	; 0x05
    2066:	08 17       	cp	r16, r24
    2068:	68 f3       	brcs	.-38     	; 0x2044 <USER_LOGIN+0xb0>
    206a:	80 e0       	ldi	r24, 0x00	; 0
    206c:	01 c0       	rjmp	.+2      	; 0x2070 <USER_LOGIN+0xdc>
    206e:	81 e0       	ldi	r24, 0x01	; 1
    2070:	81 30       	cpi	r24, 0x01	; 1
    2072:	09 f0       	breq	.+2      	; 0x2076 <USER_LOGIN+0xe2>
    2074:	59 c0       	rjmp	.+178    	; 0x2128 <USER_LOGIN+0x194>
    2076:	1f 5f       	subi	r17, 0xFF	; 255
    2078:	00 e0       	ldi	r16, 0x00	; 0
    207a:	2c c0       	rjmp	.+88     	; 0x20d4 <USER_LOGIN+0x140>
    207c:	be 01       	movw	r22, r28
    207e:	6a 5f       	subi	r22, 0xFA	; 250
    2080:	7f 4f       	sbci	r23, 0xFF	; 255
    2082:	81 2f       	mov	r24, r17
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	0e 94 a2 09 	call	0x1344	; 0x1344 <Internal_EEPROM_ReadByte>
    208a:	e2 e0       	ldi	r30, 0x02	; 2
    208c:	f0 e0       	ldi	r31, 0x00	; 0
    208e:	ec 0f       	add	r30, r28
    2090:	fd 1f       	adc	r31, r29
    2092:	e0 0f       	add	r30, r16
    2094:	f1 1d       	adc	r31, r1
    2096:	90 81       	ld	r25, Z
    2098:	8e 81       	ldd	r24, Y+6	; 0x06
    209a:	98 17       	cp	r25, r24
    209c:	c9 f0       	breq	.+50     	; 0x20d0 <USER_LOGIN+0x13c>
    209e:	8d e5       	ldi	r24, 0x5D	; 93
    20a0:	96 e0       	ldi	r25, 0x06	; 6
    20a2:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    20a6:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <user_exist>
    20aa:	ef ef       	ldi	r30, 0xFF	; 255
    20ac:	f3 ed       	ldi	r31, 0xD3	; 211
    20ae:	20 e3       	ldi	r18, 0x30	; 48
    20b0:	e1 50       	subi	r30, 0x01	; 1
    20b2:	f0 40       	sbci	r31, 0x00	; 0
    20b4:	20 40       	sbci	r18, 0x00	; 0
    20b6:	e1 f7       	brne	.-8      	; 0x20b0 <USER_LOGIN+0x11c>
    20b8:	00 c0       	rjmp	.+0      	; 0x20ba <USER_LOGIN+0x126>
    20ba:	00 00       	nop
    20bc:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    20c0:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <buzzer_check>
    20c4:	8f 5f       	subi	r24, 0xFF	; 255
    20c6:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <buzzer_check>
    20ca:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <user_exist>
    20ce:	55 c0       	rjmp	.+170    	; 0x217a <USER_LOGIN+0x1e6>
    20d0:	1f 5f       	subi	r17, 0xFF	; 255
    20d2:	0f 5f       	subi	r16, 0xFF	; 255
    20d4:	03 30       	cpi	r16, 0x03	; 3
    20d6:	90 f2       	brcs	.-92     	; 0x207c <USER_LOGIN+0xe8>
    20d8:	81 e0       	ldi	r24, 0x01	; 1
    20da:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <user_exist>
    20de:	88 e6       	ldi	r24, 0x68	; 104
    20e0:	96 e0       	ldi	r25, 0x06	; 6
    20e2:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    20e6:	8f ef       	ldi	r24, 0xFF	; 255
    20e8:	93 ed       	ldi	r25, 0xD3	; 211
    20ea:	e0 e3       	ldi	r30, 0x30	; 48
    20ec:	81 50       	subi	r24, 0x01	; 1
    20ee:	90 40       	sbci	r25, 0x00	; 0
    20f0:	e0 40       	sbci	r30, 0x00	; 0
    20f2:	e1 f7       	brne	.-8      	; 0x20ec <USER_LOGIN+0x158>
    20f4:	00 c0       	rjmp	.+0      	; 0x20f6 <USER_LOGIN+0x162>
    20f6:	00 00       	nop
    20f8:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    20fc:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <buzzer_check>
    2100:	83 30       	cpi	r24, 0x03	; 3
    2102:	79 f4       	brne	.+30     	; 0x2122 <USER_LOGIN+0x18e>
    2104:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <buzzer_check>
    2108:	0e 94 c6 00 	call	0x18c	; 0x18c <BUZZER_On>
    210c:	ff ef       	ldi	r31, 0xFF	; 255
    210e:	2b e7       	ldi	r18, 0x7B	; 123
    2110:	82 e9       	ldi	r24, 0x92	; 146
    2112:	f1 50       	subi	r31, 0x01	; 1
    2114:	20 40       	sbci	r18, 0x00	; 0
    2116:	80 40       	sbci	r24, 0x00	; 0
    2118:	e1 f7       	brne	.-8      	; 0x2112 <USER_LOGIN+0x17e>
    211a:	00 c0       	rjmp	.+0      	; 0x211c <USER_LOGIN+0x188>
    211c:	00 00       	nop
    211e:	0e 94 cc 00 	call	0x198	; 0x198 <BUZZER_Off>
    2122:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <user_exist>
    2126:	29 c0       	rjmp	.+82     	; 0x217a <USER_LOGIN+0x1e6>
    2128:	86 e7       	ldi	r24, 0x76	; 118
    212a:	96 e0       	ldi	r25, 0x06	; 6
    212c:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    2130:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <user_exist>
    2134:	9f ef       	ldi	r25, 0xFF	; 255
    2136:	e3 ed       	ldi	r30, 0xD3	; 211
    2138:	f0 e3       	ldi	r31, 0x30	; 48
    213a:	91 50       	subi	r25, 0x01	; 1
    213c:	e0 40       	sbci	r30, 0x00	; 0
    213e:	f0 40       	sbci	r31, 0x00	; 0
    2140:	e1 f7       	brne	.-8      	; 0x213a <USER_LOGIN+0x1a6>
    2142:	00 c0       	rjmp	.+0      	; 0x2144 <USER_LOGIN+0x1b0>
    2144:	00 00       	nop
    2146:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    214a:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <buzzer_check>
    214e:	8f 5f       	subi	r24, 0xFF	; 255
    2150:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <buzzer_check>
    2154:	83 30       	cpi	r24, 0x03	; 3
    2156:	79 f4       	brne	.+30     	; 0x2176 <USER_LOGIN+0x1e2>
    2158:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <buzzer_check>
    215c:	0e 94 c6 00 	call	0x18c	; 0x18c <BUZZER_On>
    2160:	2f ef       	ldi	r18, 0xFF	; 255
    2162:	8b e7       	ldi	r24, 0x7B	; 123
    2164:	92 e9       	ldi	r25, 0x92	; 146
    2166:	21 50       	subi	r18, 0x01	; 1
    2168:	80 40       	sbci	r24, 0x00	; 0
    216a:	90 40       	sbci	r25, 0x00	; 0
    216c:	e1 f7       	brne	.-8      	; 0x2166 <USER_LOGIN+0x1d2>
    216e:	00 c0       	rjmp	.+0      	; 0x2170 <USER_LOGIN+0x1dc>
    2170:	00 00       	nop
    2172:	0e 94 cc 00 	call	0x198	; 0x198 <BUZZER_Off>
    2176:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <user_exist>
    217a:	26 96       	adiw	r28, 0x06	; 6
    217c:	0f b6       	in	r0, 0x3f	; 63
    217e:	f8 94       	cli
    2180:	de bf       	out	0x3e, r29	; 62
    2182:	0f be       	out	0x3f, r0	; 63
    2184:	cd bf       	out	0x3d, r28	; 61
    2186:	df 91       	pop	r29
    2188:	cf 91       	pop	r28
    218a:	1f 91       	pop	r17
    218c:	0f 91       	pop	r16
    218e:	ff 90       	pop	r15
    2190:	08 95       	ret

00002192 <USER_Control_Leds>:
    2192:	cf 93       	push	r28
    2194:	df 93       	push	r29
    2196:	00 d0       	rcall	.+0      	; 0x2198 <USER_Control_Leds+0x6>
    2198:	1f 92       	push	r1
    219a:	cd b7       	in	r28, 0x3d	; 61
    219c:	de b7       	in	r29, 0x3e	; 62
    219e:	8f ef       	ldi	r24, 0xFF	; 255
    21a0:	89 83       	std	Y+1, r24	; 0x01
    21a2:	8f e7       	ldi	r24, 0x7F	; 127
    21a4:	96 e0       	ldi	r25, 0x06	; 6
    21a6:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    21aa:	2f ef       	ldi	r18, 0xFF	; 255
    21ac:	83 ed       	ldi	r24, 0xD3	; 211
    21ae:	90 e3       	ldi	r25, 0x30	; 48
    21b0:	21 50       	subi	r18, 0x01	; 1
    21b2:	80 40       	sbci	r24, 0x00	; 0
    21b4:	90 40       	sbci	r25, 0x00	; 0
    21b6:	e1 f7       	brne	.-8      	; 0x21b0 <USER_Control_Leds+0x1e>
    21b8:	00 c0       	rjmp	.+0      	; 0x21ba <USER_Control_Leds+0x28>
    21ba:	00 00       	nop
    21bc:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    21c0:	8b e8       	ldi	r24, 0x8B	; 139
    21c2:	96 e0       	ldi	r25, 0x06	; 6
    21c4:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    21c8:	60 e0       	ldi	r22, 0x00	; 0
    21ca:	81 e0       	ldi	r24, 0x01	; 1
    21cc:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    21d0:	8b e9       	ldi	r24, 0x9B	; 155
    21d2:	96 e0       	ldi	r25, 0x06	; 6
    21d4:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    21d8:	2f ef       	ldi	r18, 0xFF	; 255
    21da:	83 ed       	ldi	r24, 0xD3	; 211
    21dc:	90 e3       	ldi	r25, 0x30	; 48
    21de:	21 50       	subi	r18, 0x01	; 1
    21e0:	80 40       	sbci	r24, 0x00	; 0
    21e2:	90 40       	sbci	r25, 0x00	; 0
    21e4:	e1 f7       	brne	.-8      	; 0x21de <USER_Control_Leds+0x4c>
    21e6:	00 c0       	rjmp	.+0      	; 0x21e8 <USER_Control_Leds+0x56>
    21e8:	00 00       	nop
    21ea:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    21ee:	89 81       	ldd	r24, Y+1	; 0x01
    21f0:	8f 3f       	cpi	r24, 0xFF	; 255
    21f2:	29 f4       	brne	.+10     	; 0x21fe <USER_Control_Leds+0x6c>
    21f4:	ce 01       	movw	r24, r28
    21f6:	01 96       	adiw	r24, 0x01	; 1
    21f8:	0e 94 01 0a 	call	0x1402	; 0x1402 <KPD_GetValue>
    21fc:	f8 cf       	rjmp	.-16     	; 0x21ee <USER_Control_Leds+0x5c>
    21fe:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <LCD_WriteChar4Bit>
    2202:	2f ef       	ldi	r18, 0xFF	; 255
    2204:	83 ed       	ldi	r24, 0xD3	; 211
    2206:	90 e3       	ldi	r25, 0x30	; 48
    2208:	21 50       	subi	r18, 0x01	; 1
    220a:	80 40       	sbci	r24, 0x00	; 0
    220c:	90 40       	sbci	r25, 0x00	; 0
    220e:	e1 f7       	brne	.-8      	; 0x2208 <USER_Control_Leds+0x76>
    2210:	00 c0       	rjmp	.+0      	; 0x2212 <USER_Control_Leds+0x80>
    2212:	00 00       	nop
    2214:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    2218:	89 ea       	ldi	r24, 0xA9	; 169
    221a:	96 e0       	ldi	r25, 0x06	; 6
    221c:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    2220:	60 e0       	ldi	r22, 0x00	; 0
    2222:	81 e0       	ldi	r24, 0x01	; 1
    2224:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    2228:	8f ef       	ldi	r24, 0xFF	; 255
    222a:	8a 83       	std	Y+2, r24	; 0x02
    222c:	8a 81       	ldd	r24, Y+2	; 0x02
    222e:	8f 3f       	cpi	r24, 0xFF	; 255
    2230:	29 f4       	brne	.+10     	; 0x223c <USER_Control_Leds+0xaa>
    2232:	ce 01       	movw	r24, r28
    2234:	02 96       	adiw	r24, 0x02	; 2
    2236:	0e 94 01 0a 	call	0x1402	; 0x1402 <KPD_GetValue>
    223a:	f8 cf       	rjmp	.-16     	; 0x222c <USER_Control_Leds+0x9a>
    223c:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <LCD_WriteChar4Bit>
    2240:	2f ef       	ldi	r18, 0xFF	; 255
    2242:	83 ed       	ldi	r24, 0xD3	; 211
    2244:	90 e3       	ldi	r25, 0x30	; 48
    2246:	21 50       	subi	r18, 0x01	; 1
    2248:	80 40       	sbci	r24, 0x00	; 0
    224a:	90 40       	sbci	r25, 0x00	; 0
    224c:	e1 f7       	brne	.-8      	; 0x2246 <USER_Control_Leds+0xb4>
    224e:	00 c0       	rjmp	.+0      	; 0x2250 <USER_Control_Leds+0xbe>
    2250:	00 00       	nop
    2252:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    2256:	89 81       	ldd	r24, Y+1	; 0x01
    2258:	81 33       	cpi	r24, 0x31	; 49
    225a:	c1 f4       	brne	.+48     	; 0x228c <USER_Control_Leds+0xfa>
    225c:	9a 81       	ldd	r25, Y+2	; 0x02
    225e:	91 33       	cpi	r25, 0x31	; 49
    2260:	a9 f4       	brne	.+42     	; 0x228c <USER_Control_Leds+0xfa>
    2262:	41 e0       	ldi	r20, 0x01	; 1
    2264:	62 e0       	ldi	r22, 0x02	; 2
    2266:	82 e0       	ldi	r24, 0x02	; 2
    2268:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    226c:	89 eb       	ldi	r24, 0xB9	; 185
    226e:	96 e0       	ldi	r25, 0x06	; 6
    2270:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    2274:	2f ef       	ldi	r18, 0xFF	; 255
    2276:	83 ed       	ldi	r24, 0xD3	; 211
    2278:	90 e3       	ldi	r25, 0x30	; 48
    227a:	21 50       	subi	r18, 0x01	; 1
    227c:	80 40       	sbci	r24, 0x00	; 0
    227e:	90 40       	sbci	r25, 0x00	; 0
    2280:	e1 f7       	brne	.-8      	; 0x227a <USER_Control_Leds+0xe8>
    2282:	00 c0       	rjmp	.+0      	; 0x2284 <USER_Control_Leds+0xf2>
    2284:	00 00       	nop
    2286:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    228a:	8d c0       	rjmp	.+282    	; 0x23a6 <USER_Control_Leds+0x214>
    228c:	82 33       	cpi	r24, 0x32	; 50
    228e:	c1 f4       	brne	.+48     	; 0x22c0 <USER_Control_Leds+0x12e>
    2290:	9a 81       	ldd	r25, Y+2	; 0x02
    2292:	91 33       	cpi	r25, 0x31	; 49
    2294:	a9 f4       	brne	.+42     	; 0x22c0 <USER_Control_Leds+0x12e>
    2296:	41 e0       	ldi	r20, 0x01	; 1
    2298:	67 e0       	ldi	r22, 0x07	; 7
    229a:	82 e0       	ldi	r24, 0x02	; 2
    229c:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    22a0:	89 eb       	ldi	r24, 0xB9	; 185
    22a2:	96 e0       	ldi	r25, 0x06	; 6
    22a4:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    22a8:	2f ef       	ldi	r18, 0xFF	; 255
    22aa:	83 ed       	ldi	r24, 0xD3	; 211
    22ac:	90 e3       	ldi	r25, 0x30	; 48
    22ae:	21 50       	subi	r18, 0x01	; 1
    22b0:	80 40       	sbci	r24, 0x00	; 0
    22b2:	90 40       	sbci	r25, 0x00	; 0
    22b4:	e1 f7       	brne	.-8      	; 0x22ae <USER_Control_Leds+0x11c>
    22b6:	00 c0       	rjmp	.+0      	; 0x22b8 <USER_Control_Leds+0x126>
    22b8:	00 00       	nop
    22ba:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    22be:	73 c0       	rjmp	.+230    	; 0x23a6 <USER_Control_Leds+0x214>
    22c0:	83 33       	cpi	r24, 0x33	; 51
    22c2:	09 f0       	breq	.+2      	; 0x22c6 <USER_Control_Leds+0x134>
    22c4:	70 c0       	rjmp	.+224    	; 0x23a6 <USER_Control_Leds+0x214>
    22c6:	8a 81       	ldd	r24, Y+2	; 0x02
    22c8:	81 33       	cpi	r24, 0x31	; 49
    22ca:	09 f0       	breq	.+2      	; 0x22ce <USER_Control_Leds+0x13c>
    22cc:	6c c0       	rjmp	.+216    	; 0x23a6 <USER_Control_Leds+0x214>
    22ce:	83 ec       	ldi	r24, 0xC3	; 195
    22d0:	96 e0       	ldi	r25, 0x06	; 6
    22d2:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    22d6:	2f ef       	ldi	r18, 0xFF	; 255
    22d8:	83 ed       	ldi	r24, 0xD3	; 211
    22da:	90 e3       	ldi	r25, 0x30	; 48
    22dc:	21 50       	subi	r18, 0x01	; 1
    22de:	80 40       	sbci	r24, 0x00	; 0
    22e0:	90 40       	sbci	r25, 0x00	; 0
    22e2:	e1 f7       	brne	.-8      	; 0x22dc <USER_Control_Leds+0x14a>
    22e4:	00 c0       	rjmp	.+0      	; 0x22e6 <USER_Control_Leds+0x154>
    22e6:	00 00       	nop
    22e8:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    22ec:	81 ed       	ldi	r24, 0xD1	; 209
    22ee:	96 e0       	ldi	r25, 0x06	; 6
    22f0:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    22f4:	60 e0       	ldi	r22, 0x00	; 0
    22f6:	81 e0       	ldi	r24, 0x01	; 1
    22f8:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    22fc:	80 ee       	ldi	r24, 0xE0	; 224
    22fe:	96 e0       	ldi	r25, 0x06	; 6
    2300:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    2304:	2f ef       	ldi	r18, 0xFF	; 255
    2306:	83 ed       	ldi	r24, 0xD3	; 211
    2308:	90 e3       	ldi	r25, 0x30	; 48
    230a:	21 50       	subi	r18, 0x01	; 1
    230c:	80 40       	sbci	r24, 0x00	; 0
    230e:	90 40       	sbci	r25, 0x00	; 0
    2310:	e1 f7       	brne	.-8      	; 0x230a <USER_Control_Leds+0x178>
    2312:	00 c0       	rjmp	.+0      	; 0x2314 <USER_Control_Leds+0x182>
    2314:	00 00       	nop
    2316:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    231a:	8f ee       	ldi	r24, 0xEF	; 239
    231c:	96 e0       	ldi	r25, 0x06	; 6
    231e:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    2322:	60 e0       	ldi	r22, 0x00	; 0
    2324:	81 e0       	ldi	r24, 0x01	; 1
    2326:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    232a:	8f ef       	ldi	r24, 0xFF	; 255
    232c:	8b 83       	std	Y+3, r24	; 0x03
    232e:	8b 81       	ldd	r24, Y+3	; 0x03
    2330:	8f 3f       	cpi	r24, 0xFF	; 255
    2332:	29 f4       	brne	.+10     	; 0x233e <USER_Control_Leds+0x1ac>
    2334:	ce 01       	movw	r24, r28
    2336:	03 96       	adiw	r24, 0x03	; 3
    2338:	0e 94 01 0a 	call	0x1402	; 0x1402 <KPD_GetValue>
    233c:	f8 cf       	rjmp	.-16     	; 0x232e <USER_Control_Leds+0x19c>
    233e:	83 33       	cpi	r24, 0x33	; 51
    2340:	d9 f0       	breq	.+54     	; 0x2378 <USER_Control_Leds+0x1e6>
    2342:	28 f4       	brcc	.+10     	; 0x234e <USER_Control_Leds+0x1bc>
    2344:	81 33       	cpi	r24, 0x31	; 49
    2346:	41 f0       	breq	.+16     	; 0x2358 <USER_Control_Leds+0x1c6>
    2348:	82 33       	cpi	r24, 0x32	; 50
    234a:	71 f0       	breq	.+28     	; 0x2368 <USER_Control_Leds+0x1d6>
    234c:	2c c0       	rjmp	.+88     	; 0x23a6 <USER_Control_Leds+0x214>
    234e:	84 33       	cpi	r24, 0x34	; 52
    2350:	d9 f0       	breq	.+54     	; 0x2388 <USER_Control_Leds+0x1f6>
    2352:	85 33       	cpi	r24, 0x35	; 53
    2354:	09 f1       	breq	.+66     	; 0x2398 <USER_Control_Leds+0x206>
    2356:	27 c0       	rjmp	.+78     	; 0x23a6 <USER_Control_Leds+0x214>
    2358:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
    235c:	84 e1       	ldi	r24, 0x14	; 20
    235e:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
    2362:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
    2366:	1f c0       	rjmp	.+62     	; 0x23a6 <USER_Control_Leds+0x214>
    2368:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
    236c:	88 e2       	ldi	r24, 0x28	; 40
    236e:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
    2372:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
    2376:	17 c0       	rjmp	.+46     	; 0x23a6 <USER_Control_Leds+0x214>
    2378:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
    237c:	8c e3       	ldi	r24, 0x3C	; 60
    237e:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
    2382:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
    2386:	0f c0       	rjmp	.+30     	; 0x23a6 <USER_Control_Leds+0x214>
    2388:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
    238c:	80 e5       	ldi	r24, 0x50	; 80
    238e:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
    2392:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
    2396:	07 c0       	rjmp	.+14     	; 0x23a6 <USER_Control_Leds+0x214>
    2398:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
    239c:	84 e6       	ldi	r24, 0x64	; 100
    239e:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
    23a2:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
    23a6:	89 81       	ldd	r24, Y+1	; 0x01
    23a8:	81 33       	cpi	r24, 0x31	; 49
    23aa:	c1 f4       	brne	.+48     	; 0x23dc <USER_Control_Leds+0x24a>
    23ac:	9a 81       	ldd	r25, Y+2	; 0x02
    23ae:	92 33       	cpi	r25, 0x32	; 50
    23b0:	a9 f4       	brne	.+42     	; 0x23dc <USER_Control_Leds+0x24a>
    23b2:	40 e0       	ldi	r20, 0x00	; 0
    23b4:	62 e0       	ldi	r22, 0x02	; 2
    23b6:	82 e0       	ldi	r24, 0x02	; 2
    23b8:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    23bc:	89 eb       	ldi	r24, 0xB9	; 185
    23be:	96 e0       	ldi	r25, 0x06	; 6
    23c0:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    23c4:	2f ef       	ldi	r18, 0xFF	; 255
    23c6:	83 ed       	ldi	r24, 0xD3	; 211
    23c8:	90 e3       	ldi	r25, 0x30	; 48
    23ca:	21 50       	subi	r18, 0x01	; 1
    23cc:	80 40       	sbci	r24, 0x00	; 0
    23ce:	90 40       	sbci	r25, 0x00	; 0
    23d0:	e1 f7       	brne	.-8      	; 0x23ca <USER_Control_Leds+0x238>
    23d2:	00 c0       	rjmp	.+0      	; 0x23d4 <USER_Control_Leds+0x242>
    23d4:	00 00       	nop
    23d6:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    23da:	35 c0       	rjmp	.+106    	; 0x2446 <USER_Control_Leds+0x2b4>
    23dc:	82 33       	cpi	r24, 0x32	; 50
    23de:	c1 f4       	brne	.+48     	; 0x2410 <USER_Control_Leds+0x27e>
    23e0:	9a 81       	ldd	r25, Y+2	; 0x02
    23e2:	92 33       	cpi	r25, 0x32	; 50
    23e4:	a9 f4       	brne	.+42     	; 0x2410 <USER_Control_Leds+0x27e>
    23e6:	40 e0       	ldi	r20, 0x00	; 0
    23e8:	67 e0       	ldi	r22, 0x07	; 7
    23ea:	82 e0       	ldi	r24, 0x02	; 2
    23ec:	0e 94 4d 01 	call	0x29a	; 0x29a <DIO_SetPinValue>
    23f0:	89 eb       	ldi	r24, 0xB9	; 185
    23f2:	96 e0       	ldi	r25, 0x06	; 6
    23f4:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    23f8:	2f ef       	ldi	r18, 0xFF	; 255
    23fa:	83 ed       	ldi	r24, 0xD3	; 211
    23fc:	90 e3       	ldi	r25, 0x30	; 48
    23fe:	21 50       	subi	r18, 0x01	; 1
    2400:	80 40       	sbci	r24, 0x00	; 0
    2402:	90 40       	sbci	r25, 0x00	; 0
    2404:	e1 f7       	brne	.-8      	; 0x23fe <USER_Control_Leds+0x26c>
    2406:	00 c0       	rjmp	.+0      	; 0x2408 <USER_Control_Leds+0x276>
    2408:	00 00       	nop
    240a:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    240e:	1b c0       	rjmp	.+54     	; 0x2446 <USER_Control_Leds+0x2b4>
    2410:	83 33       	cpi	r24, 0x33	; 51
    2412:	c9 f4       	brne	.+50     	; 0x2446 <USER_Control_Leds+0x2b4>
    2414:	8a 81       	ldd	r24, Y+2	; 0x02
    2416:	82 33       	cpi	r24, 0x32	; 50
    2418:	b1 f4       	brne	.+44     	; 0x2446 <USER_Control_Leds+0x2b4>
    241a:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <TMR_Timer2Stop>
    241e:	80 e0       	ldi	r24, 0x00	; 0
    2420:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TMR_Timer2Set_PWM_DutyCycle>
    2424:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <TMR_Timer2Start>
    2428:	89 eb       	ldi	r24, 0xB9	; 185
    242a:	96 e0       	ldi	r25, 0x06	; 6
    242c:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    2430:	2f ef       	ldi	r18, 0xFF	; 255
    2432:	83 ed       	ldi	r24, 0xD3	; 211
    2434:	90 e3       	ldi	r25, 0x30	; 48
    2436:	21 50       	subi	r18, 0x01	; 1
    2438:	80 40       	sbci	r24, 0x00	; 0
    243a:	90 40       	sbci	r25, 0x00	; 0
    243c:	e1 f7       	brne	.-8      	; 0x2436 <USER_Control_Leds+0x2a4>
    243e:	00 c0       	rjmp	.+0      	; 0x2440 <USER_Control_Leds+0x2ae>
    2440:	00 00       	nop
    2442:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    2446:	0f 90       	pop	r0
    2448:	0f 90       	pop	r0
    244a:	0f 90       	pop	r0
    244c:	df 91       	pop	r29
    244e:	cf 91       	pop	r28
    2450:	08 95       	ret

00002452 <USER_LOGOUT>:
    2452:	86 ef       	ldi	r24, 0xF6	; 246
    2454:	96 e0       	ldi	r25, 0x06	; 6
    2456:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    245a:	2f ef       	ldi	r18, 0xFF	; 255
    245c:	87 ea       	ldi	r24, 0xA7	; 167
    245e:	91 e6       	ldi	r25, 0x61	; 97
    2460:	21 50       	subi	r18, 0x01	; 1
    2462:	80 40       	sbci	r24, 0x00	; 0
    2464:	90 40       	sbci	r25, 0x00	; 0
    2466:	e1 f7       	brne	.-8      	; 0x2460 <USER_LOGOUT+0xe>
    2468:	00 c0       	rjmp	.+0      	; 0x246a <USER_LOGOUT+0x18>
    246a:	00 00       	nop
    246c:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    2470:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <user_exist>
    2474:	08 95       	ret

00002476 <USER_PROGRAM>:
    2476:	cf 93       	push	r28
    2478:	df 93       	push	r29
    247a:	1f 92       	push	r1
    247c:	cd b7       	in	r28, 0x3d	; 61
    247e:	de b7       	in	r29, 0x3e	; 62
    2480:	8f ef       	ldi	r24, 0xFF	; 255
    2482:	89 83       	std	Y+1, r24	; 0x01
    2484:	80 e0       	ldi	r24, 0x00	; 0
    2486:	97 e0       	ldi	r25, 0x07	; 7
    2488:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    248c:	2f ef       	ldi	r18, 0xFF	; 255
    248e:	83 ed       	ldi	r24, 0xD3	; 211
    2490:	90 e3       	ldi	r25, 0x30	; 48
    2492:	21 50       	subi	r18, 0x01	; 1
    2494:	80 40       	sbci	r24, 0x00	; 0
    2496:	90 40       	sbci	r25, 0x00	; 0
    2498:	e1 f7       	brne	.-8      	; 0x2492 <USER_PROGRAM+0x1c>
    249a:	00 c0       	rjmp	.+0      	; 0x249c <USER_PROGRAM+0x26>
    249c:	00 00       	nop
    249e:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    24a2:	80 e1       	ldi	r24, 0x10	; 16
    24a4:	97 e0       	ldi	r25, 0x07	; 7
    24a6:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    24aa:	60 e0       	ldi	r22, 0x00	; 0
    24ac:	81 e0       	ldi	r24, 0x01	; 1
    24ae:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    24b2:	8f e1       	ldi	r24, 0x1F	; 31
    24b4:	97 e0       	ldi	r25, 0x07	; 7
    24b6:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    24ba:	2f ef       	ldi	r18, 0xFF	; 255
    24bc:	83 ed       	ldi	r24, 0xD3	; 211
    24be:	90 e3       	ldi	r25, 0x30	; 48
    24c0:	21 50       	subi	r18, 0x01	; 1
    24c2:	80 40       	sbci	r24, 0x00	; 0
    24c4:	90 40       	sbci	r25, 0x00	; 0
    24c6:	e1 f7       	brne	.-8      	; 0x24c0 <USER_PROGRAM+0x4a>
    24c8:	00 c0       	rjmp	.+0      	; 0x24ca <USER_PROGRAM+0x54>
    24ca:	00 00       	nop
    24cc:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    24d0:	89 e2       	ldi	r24, 0x29	; 41
    24d2:	97 e0       	ldi	r25, 0x07	; 7
    24d4:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    24d8:	60 e0       	ldi	r22, 0x00	; 0
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <LCD_SetCursorPosition>
    24e0:	89 81       	ldd	r24, Y+1	; 0x01
    24e2:	8f 3f       	cpi	r24, 0xFF	; 255
    24e4:	29 f4       	brne	.+10     	; 0x24f0 <USER_PROGRAM+0x7a>
    24e6:	ce 01       	movw	r24, r28
    24e8:	01 96       	adiw	r24, 0x01	; 1
    24ea:	0e 94 01 0a 	call	0x1402	; 0x1402 <KPD_GetValue>
    24ee:	f8 cf       	rjmp	.-16     	; 0x24e0 <USER_PROGRAM+0x6a>
    24f0:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <LCD_WriteChar4Bit>
    24f4:	2f ef       	ldi	r18, 0xFF	; 255
    24f6:	83 ed       	ldi	r24, 0xD3	; 211
    24f8:	90 e3       	ldi	r25, 0x30	; 48
    24fa:	21 50       	subi	r18, 0x01	; 1
    24fc:	80 40       	sbci	r24, 0x00	; 0
    24fe:	90 40       	sbci	r25, 0x00	; 0
    2500:	e1 f7       	brne	.-8      	; 0x24fa <USER_PROGRAM+0x84>
    2502:	00 c0       	rjmp	.+0      	; 0x2504 <USER_PROGRAM+0x8e>
    2504:	00 00       	nop
    2506:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    250a:	89 81       	ldd	r24, Y+1	; 0x01
    250c:	81 33       	cpi	r24, 0x31	; 49
    250e:	19 f0       	breq	.+6      	; 0x2516 <USER_PROGRAM+0xa0>
    2510:	82 33       	cpi	r24, 0x32	; 50
    2512:	81 f1       	breq	.+96     	; 0x2574 <USER_PROGRAM+0xfe>
    2514:	33 c0       	rjmp	.+102    	; 0x257c <USER_PROGRAM+0x106>
    2516:	0e 94 a4 04 	call	0x948	; 0x948 <HC05_AdminLoginCheck>
    251a:	87 30       	cpi	r24, 0x07	; 7
    251c:	39 f5       	brne	.+78     	; 0x256c <USER_PROGRAM+0xf6>
    251e:	84 e3       	ldi	r24, 0x34	; 52
    2520:	97 e0       	ldi	r25, 0x07	; 7
    2522:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    2526:	82 e6       	ldi	r24, 0x62	; 98
    2528:	97 e0       	ldi	r25, 0x07	; 7
    252a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <UART_TxString>
    252e:	0e 94 8a 09 	call	0x1314	; 0x1314 <HC05_ScreenChangeToAdminResponse>
    2532:	0e 94 79 09 	call	0x12f2	; 0x12f2 <HC05_AdminApproval>
    2536:	83 30       	cpi	r24, 0x03	; 3
    2538:	e1 f3       	breq	.-8      	; 0x2532 <USER_PROGRAM+0xbc>
    253a:	81 30       	cpi	r24, 0x01	; 1
    253c:	21 f4       	brne	.+8      	; 0x2546 <USER_PROGRAM+0xd0>
    253e:	0e 94 c9 10 	call	0x2192	; 0x2192 <USER_Control_Leds>
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	1e c0       	rjmp	.+60     	; 0x2582 <USER_PROGRAM+0x10c>
    2546:	82 30       	cpi	r24, 0x02	; 2
    2548:	d9 f4       	brne	.+54     	; 0x2580 <USER_PROGRAM+0x10a>
    254a:	86 e7       	ldi	r24, 0x76	; 118
    254c:	97 e0       	ldi	r25, 0x07	; 7
    254e:	0e 94 23 0b 	call	0x1646	; 0x1646 <LCD_WriteString>
    2552:	2f ef       	ldi	r18, 0xFF	; 255
    2554:	89 e6       	ldi	r24, 0x69	; 105
    2556:	98 e1       	ldi	r25, 0x18	; 24
    2558:	21 50       	subi	r18, 0x01	; 1
    255a:	80 40       	sbci	r24, 0x00	; 0
    255c:	90 40       	sbci	r25, 0x00	; 0
    255e:	e1 f7       	brne	.-8      	; 0x2558 <USER_PROGRAM+0xe2>
    2560:	00 c0       	rjmp	.+0      	; 0x2562 <USER_PROGRAM+0xec>
    2562:	00 00       	nop
    2564:	0e 94 39 0b 	call	0x1672	; 0x1672 <LCD_ClearDisplay>
    2568:	81 e0       	ldi	r24, 0x01	; 1
    256a:	0b c0       	rjmp	.+22     	; 0x2582 <USER_PROGRAM+0x10c>
    256c:	0e 94 c9 10 	call	0x2192	; 0x2192 <USER_Control_Leds>
    2570:	81 e0       	ldi	r24, 0x01	; 1
    2572:	07 c0       	rjmp	.+14     	; 0x2582 <USER_PROGRAM+0x10c>
    2574:	0e 94 29 12 	call	0x2452	; 0x2452 <USER_LOGOUT>
    2578:	80 e0       	ldi	r24, 0x00	; 0
    257a:	03 c0       	rjmp	.+6      	; 0x2582 <USER_PROGRAM+0x10c>
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	01 c0       	rjmp	.+2      	; 0x2582 <USER_PROGRAM+0x10c>
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	0f 90       	pop	r0
    2584:	df 91       	pop	r29
    2586:	cf 91       	pop	r28
    2588:	08 95       	ret

0000258a <USER_APP>:

void USER_APP(void)
{
	u8 check1 = 0 ;
	u8 check2 = 0 ;
	check1 = USER_LOGIN();
    258a:	0e 94 ca 0f 	call	0x1f94	; 0x1f94 <USER_LOGIN>
	if(check1==1)
    258e:	81 30       	cpi	r24, 0x01	; 1
    2590:	21 f4       	brne	.+8      	; 0x259a <USER_APP+0x10>
	{
		while(1)
		{
			check2 = USER_PROGRAM();
    2592:	0e 94 3b 12 	call	0x2476	; 0x2476 <USER_PROGRAM>
			if(check2==0)
    2596:	81 11       	cpse	r24, r1
    2598:	fc cf       	rjmp	.-8      	; 0x2592 <USER_APP+0x8>
    259a:	08 95       	ret

0000259c <__udivmodsi4>:
    259c:	a1 e2       	ldi	r26, 0x21	; 33
    259e:	1a 2e       	mov	r1, r26
    25a0:	aa 1b       	sub	r26, r26
    25a2:	bb 1b       	sub	r27, r27
    25a4:	fd 01       	movw	r30, r26
    25a6:	0d c0       	rjmp	.+26     	; 0x25c2 <__udivmodsi4_ep>

000025a8 <__udivmodsi4_loop>:
    25a8:	aa 1f       	adc	r26, r26
    25aa:	bb 1f       	adc	r27, r27
    25ac:	ee 1f       	adc	r30, r30
    25ae:	ff 1f       	adc	r31, r31
    25b0:	a2 17       	cp	r26, r18
    25b2:	b3 07       	cpc	r27, r19
    25b4:	e4 07       	cpc	r30, r20
    25b6:	f5 07       	cpc	r31, r21
    25b8:	20 f0       	brcs	.+8      	; 0x25c2 <__udivmodsi4_ep>
    25ba:	a2 1b       	sub	r26, r18
    25bc:	b3 0b       	sbc	r27, r19
    25be:	e4 0b       	sbc	r30, r20
    25c0:	f5 0b       	sbc	r31, r21

000025c2 <__udivmodsi4_ep>:
    25c2:	66 1f       	adc	r22, r22
    25c4:	77 1f       	adc	r23, r23
    25c6:	88 1f       	adc	r24, r24
    25c8:	99 1f       	adc	r25, r25
    25ca:	1a 94       	dec	r1
    25cc:	69 f7       	brne	.-38     	; 0x25a8 <__udivmodsi4_loop>
    25ce:	60 95       	com	r22
    25d0:	70 95       	com	r23
    25d2:	80 95       	com	r24
    25d4:	90 95       	com	r25
    25d6:	9b 01       	movw	r18, r22
    25d8:	ac 01       	movw	r20, r24
    25da:	bd 01       	movw	r22, r26
    25dc:	cf 01       	movw	r24, r30
    25de:	08 95       	ret

000025e0 <__tablejump2__>:
    25e0:	ee 0f       	add	r30, r30
    25e2:	ff 1f       	adc	r31, r31
    25e4:	05 90       	lpm	r0, Z+
    25e6:	f4 91       	lpm	r31, Z
    25e8:	e0 2d       	mov	r30, r0
    25ea:	09 94       	ijmp

000025ec <__umulhisi3>:
    25ec:	a2 9f       	mul	r26, r18
    25ee:	b0 01       	movw	r22, r0
    25f0:	b3 9f       	mul	r27, r19
    25f2:	c0 01       	movw	r24, r0
    25f4:	a3 9f       	mul	r26, r19
    25f6:	70 0d       	add	r23, r0
    25f8:	81 1d       	adc	r24, r1
    25fa:	11 24       	eor	r1, r1
    25fc:	91 1d       	adc	r25, r1
    25fe:	b2 9f       	mul	r27, r18
    2600:	70 0d       	add	r23, r0
    2602:	81 1d       	adc	r24, r1
    2604:	11 24       	eor	r1, r1
    2606:	91 1d       	adc	r25, r1
    2608:	08 95       	ret

0000260a <_exit>:
    260a:	f8 94       	cli

0000260c <__stop_program>:
    260c:	ff cf       	rjmp	.-2      	; 0x260c <__stop_program>
