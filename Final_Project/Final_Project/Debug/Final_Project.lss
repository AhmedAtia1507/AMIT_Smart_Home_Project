
Final_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000259e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000079c  00800060  0000259e  00002632  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002e  008007fc  008007fc  00002dce  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002dce  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002e00  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004a8  00000000  00000000  00002e3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005703  00000000  00000000  000032e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013d4  00000000  00000000  000089e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002dbe  00000000  00000000  00009dbb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ca0  00000000  00000000  0000cb7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001315  00000000  00000000  0000d81c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002fe0  00000000  00000000  0000eb31  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000418  00000000  00000000  00011b11  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 37 00 	jmp	0x6e	; 0x6e <__ctors_end>
       4:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
       8:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
       c:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      10:	0c 94 cb 0d 	jmp	0x1b96	; 0x1b96 <__vector_4>
      14:	0c 94 f4 0d 	jmp	0x1be8	; 0x1be8 <__vector_5>
      18:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      1c:	0c 94 1a 0d 	jmp	0x1a34	; 0x1a34 <__vector_7>
      20:	0c 94 43 0d 	jmp	0x1a86	; 0x1a86 <__vector_8>
      24:	0c 94 6c 0d 	jmp	0x1ad8	; 0x1ad8 <__vector_9>
      28:	0c 94 49 0c 	jmp	0x1892	; 0x1892 <__vector_10>
      2c:	0c 94 72 0c 	jmp	0x18e4	; 0x18e4 <__vector_11>
      30:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      34:	0c 94 88 0e 	jmp	0x1d10	; 0x1d10 <__vector_13>
      38:	0c 94 b1 0e 	jmp	0x1d62	; 0x1d62 <__vector_14>
      3c:	0c 94 da 0e 	jmp	0x1db4	; 0x1db4 <__vector_15>
      40:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      44:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      48:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      4c:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      50:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__bad_interrupt>
      54:	b3 05       	cpc	r27, r3
      56:	e2 05       	cpc	r30, r2
      58:	ee 05       	cpc	r30, r14
      5a:	34 06       	cpc	r3, r20
      5c:	f4 06       	cpc	r15, r20
      5e:	47 07       	cpc	r20, r23
      60:	6a 08       	sbc	r6, r10
      62:	b0 06       	cpc	r11, r16
      64:	2f 08       	sbc	r2, r15
      66:	3b 08       	sbc	r3, r11
      68:	4b 08       	sbc	r4, r11
      6a:	6a 08       	sbc	r6, r10
      6c:	55 08       	sbc	r5, r5

0000006e <__ctors_end>:
      6e:	11 24       	eor	r1, r1
      70:	1f be       	out	0x3f, r1	; 63
      72:	cf e5       	ldi	r28, 0x5F	; 95
      74:	d8 e0       	ldi	r29, 0x08	; 8
      76:	de bf       	out	0x3e, r29	; 62
      78:	cd bf       	out	0x3d, r28	; 61

0000007a <__do_copy_data>:
      7a:	17 e0       	ldi	r17, 0x07	; 7
      7c:	a0 e6       	ldi	r26, 0x60	; 96
      7e:	b0 e0       	ldi	r27, 0x00	; 0
      80:	ee e9       	ldi	r30, 0x9E	; 158
      82:	f5 e2       	ldi	r31, 0x25	; 37
      84:	02 c0       	rjmp	.+4      	; 0x8a <__do_copy_data+0x10>
      86:	05 90       	lpm	r0, Z+
      88:	0d 92       	st	X+, r0
      8a:	ac 3f       	cpi	r26, 0xFC	; 252
      8c:	b1 07       	cpc	r27, r17
      8e:	d9 f7       	brne	.-10     	; 0x86 <__do_copy_data+0xc>

00000090 <__do_clear_bss>:
      90:	28 e0       	ldi	r18, 0x08	; 8
      92:	ac ef       	ldi	r26, 0xFC	; 252
      94:	b7 e0       	ldi	r27, 0x07	; 7
      96:	01 c0       	rjmp	.+2      	; 0x9a <.do_clear_bss_start>

00000098 <.do_clear_bss_loop>:
      98:	1d 92       	st	X+, r1

0000009a <.do_clear_bss_start>:
      9a:	aa 32       	cpi	r26, 0x2A	; 42
      9c:	b2 07       	cpc	r27, r18
      9e:	e1 f7       	brne	.-8      	; 0x98 <.do_clear_bss_loop>
      a0:	0e 94 72 0b 	call	0x16e4	; 0x16e4 <main>
      a4:	0c 94 cd 12 	jmp	0x259a	; 0x259a <_exit>

000000a8 <__bad_interrupt>:
      a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ac <ADC_Init>:
    //Select Vref = AVCC
    #if ADC_SET_VREF == VREF_AREF_PIN
        CLEAR_BIT(ADMUX, REFS0);
        CLEAR_BIT(ADMUX, REFS1);
    #elif ADC_SET_VREF == VREF_AVCC_PIN
        SET_BIT(ADMUX, REFS0);
      ac:	87 b1       	in	r24, 0x07	; 7
      ae:	80 64       	ori	r24, 0x40	; 64
      b0:	87 b9       	out	0x07, r24	; 7
        CLEAR_BIT(ADMUX, REFS1);
      b2:	87 b1       	in	r24, 0x07	; 7
      b4:	8f 77       	andi	r24, 0x7F	; 127
      b6:	87 b9       	out	0x07, r24	; 7
        #error "Wrong Voltage Reference Chosen" 
    #endif

    //Right Adjust
    #if ADC_SET_ADJUST_LEVEL == ADC_RIGHT_ADJUST
        CLEAR_BIT(ADMUX, ADLAR);
      b8:	87 b1       	in	r24, 0x07	; 7
      ba:	8f 7d       	andi	r24, 0xDF	; 223
      bc:	87 b9       	out	0x07, r24	; 7
    #else
        #error "Wrong Adjustment Chosen"
    #endif

    //Single Conversion mode
    CLEAR_BIT(ADCSRA, ADATE);
      be:	86 b1       	in	r24, 0x06	; 6
      c0:	8f 7d       	andi	r24, 0xDF	; 223
      c2:	86 b9       	out	0x06, r24	; 6
    #elif ADC_SET_PRESCALAR == PRESCALER_DIVIDE_BY_64
        CLEAR_BIT(ADCSRA, ADPS0);
        SET_BIT(ADCSRA, ADPS1);
        SET_BIT(ADCSRA, ADPS2);
    #elif ADC_SET_PRESCALAR == PRESCALER_DIVIDE_BY_128
        SET_BIT(ADCSRA, ADPS0);
      c4:	86 b1       	in	r24, 0x06	; 6
      c6:	81 60       	ori	r24, 0x01	; 1
      c8:	86 b9       	out	0x06, r24	; 6
        SET_BIT(ADCSRA, ADPS1);
      ca:	86 b1       	in	r24, 0x06	; 6
      cc:	82 60       	ori	r24, 0x02	; 2
      ce:	86 b9       	out	0x06, r24	; 6
        SET_BIT(ADCSRA, ADPS2);
      d0:	86 b1       	in	r24, 0x06	; 6
      d2:	84 60       	ori	r24, 0x04	; 4
      d4:	86 b9       	out	0x06, r24	; 6
    #else
        #error "Wrong Prescalar Chosen"
    #endif

    //ADC Enable
    SET_BIT(ADCSRA, 7);
      d6:	86 b1       	in	r24, 0x06	; 6
      d8:	80 68       	ori	r24, 0x80	; 128
      da:	86 b9       	out	0x06, r24	; 6
      dc:	08 95       	ret

000000de <ADC_GetDigitalValue>:
 * @param Copy_u8ChannelNumber: The ADC channel
 * @param P_u16DigitalValue: Pointer to store the value of the conversion in
 */
void ADC_GetDigitalValue(u8 Copy_u8ChannelNumber, u16* P_u16DigitalValue)
{
    if(P_u16DigitalValue != NULL)
      de:	61 15       	cp	r22, r1
      e0:	71 05       	cpc	r23, r1
      e2:	a9 f0       	breq	.+42     	; 0x10e <ADC_GetDigitalValue+0x30>
    {
        if(Copy_u8ChannelNumber >= ADC_CHANNEL_0 && Copy_u8ChannelNumber <= ADC_CHANNEL_7)
      e4:	88 30       	cpi	r24, 0x08	; 8
      e6:	98 f4       	brcc	.+38     	; 0x10e <ADC_GetDigitalValue+0x30>
        {
            //clear the first 5 bits of the ADMUX register
            ADMUX &= 0b11100000; 
      e8:	97 b1       	in	r25, 0x07	; 7
      ea:	90 7e       	andi	r25, 0xE0	; 224
      ec:	97 b9       	out	0x07, r25	; 7
            //Set the values of the first 5 bits as the channel number
            ADMUX |= Copy_u8ChannelNumber; 
      ee:	97 b1       	in	r25, 0x07	; 7
      f0:	89 2b       	or	r24, r25
      f2:	87 b9       	out	0x07, r24	; 7
            //Start Conversion
            SET_BIT(ADCSRA, ADSC);
      f4:	86 b1       	in	r24, 0x06	; 6
      f6:	80 64       	ori	r24, 0x40	; 64
      f8:	86 b9       	out	0x06, r24	; 6

            //Wait for the flag of ADC
            while(GET_BIT(ADCSRA, ADIF) == 0);
      fa:	34 9b       	sbis	0x06, 4	; 6
      fc:	fe cf       	rjmp	.-4      	; 0xfa <ADC_GetDigitalValue+0x1c>

            //Clear ADC Flag
            SET_BIT(ADCSRA,ADIF);
      fe:	86 b1       	in	r24, 0x06	; 6
     100:	80 61       	ori	r24, 0x10	; 16
     102:	86 b9       	out	0x06, r24	; 6

            //Read Digital Value
            *P_u16DigitalValue = ADC_u16;
     104:	84 b1       	in	r24, 0x04	; 4
     106:	95 b1       	in	r25, 0x05	; 5
     108:	fb 01       	movw	r30, r22
     10a:	91 83       	std	Z+1, r25	; 0x01
     10c:	80 83       	st	Z, r24
     10e:	08 95       	ret

00000110 <BUZZER_On>:
 * @brief: Function to turn on the Buzzer Peripheral
 * 
 */
void BUZZER_On(void)
{
    DIO_SetPinValue(BUZZER_PORT_ID, BUZZER_PIN_ID, DIO_PIN_HIGH);
     110:	41 e0       	ldi	r20, 0x01	; 1
     112:	63 e0       	ldi	r22, 0x03	; 3
     114:	80 e0       	ldi	r24, 0x00	; 0
     116:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
     11a:	08 95       	ret

0000011c <BUZZER_Off>:
 * @brief: Function to turn off the Buzzer Peripheral
 * 
 */
void BUZZER_Off(void)
{
    DIO_SetPinValue(BUZZER_PORT_ID, BUZZER_PIN_ID, DIO_PIN_LOW);
     11c:	40 e0       	ldi	r20, 0x00	; 0
     11e:	63 e0       	ldi	r22, 0x03	; 3
     120:	80 e0       	ldi	r24, 0x00	; 0
     122:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
     126:	08 95       	ret

00000128 <AC_Auto>:
	static u16 AnalogValue=0;
	static u16 DigitalValue=0;
	//ADC_init();
	
	
	ADC_GetDigitalValue(ADC_CHANNEL_1,&DigitalValue);
     128:	6c ef       	ldi	r22, 0xFC	; 252
     12a:	77 e0       	ldi	r23, 0x07	; 7
     12c:	81 e0       	ldi	r24, 0x01	; 1
     12e:	0e 94 6f 00 	call	0xde	; 0xde <ADC_GetDigitalValue>
	
	AnalogValue = (((u32)DigitalValue *5000UL)/1024);
     132:	20 91 fc 07 	lds	r18, 0x07FC	; 0x8007fc <__data_end>
     136:	30 91 fd 07 	lds	r19, 0x07FD	; 0x8007fd <__data_end+0x1>
     13a:	a8 e8       	ldi	r26, 0x88	; 136
     13c:	b3 e1       	ldi	r27, 0x13	; 19
     13e:	0e 94 be 12 	call	0x257c	; 0x257c <__umulhisi3>
     142:	dc 01       	movw	r26, r24
     144:	cb 01       	movw	r24, r22
     146:	07 2e       	mov	r0, r23
     148:	7a e0       	ldi	r23, 0x0A	; 10
     14a:	b6 95       	lsr	r27
     14c:	a7 95       	ror	r26
     14e:	97 95       	ror	r25
     150:	87 95       	ror	r24
     152:	7a 95       	dec	r23
     154:	d1 f7       	brne	.-12     	; 0x14a <AC_Auto+0x22>
     156:	70 2d       	mov	r23, r0
     158:	bc 01       	movw	r22, r24
	
	if (AnalogValue < 2000) //Temp < 21
     15a:	60 3d       	cpi	r22, 0xD0	; 208
     15c:	87 e0       	ldi	r24, 0x07	; 7
     15e:	78 07       	cpc	r23, r24
     160:	58 f4       	brcc	.+22     	; 0x178 <AC_Auto+0x50>
	{
		DIO_SetPinDirection(DIO_PORTA,DIO_PIN2,DIO_PIN_OUTPUT);
     162:	41 e0       	ldi	r20, 0x01	; 1
     164:	62 e0       	ldi	r22, 0x02	; 2
     166:	80 e0       	ldi	r24, 0x00	; 0
     168:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
	    DIO_SetPinValue(DIO_PORTA,DIO_PIN2,DIO_PIN_LOW);
     16c:	40 e0       	ldi	r20, 0x00	; 0
     16e:	62 e0       	ldi	r22, 0x02	; 2
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
     176:	08 95       	ret
	}
		
	else if(AnalogValue > 4000)//Temp > 28
     178:	61 3a       	cpi	r22, 0xA1	; 161
     17a:	7f 40       	sbci	r23, 0x0F	; 15
     17c:	50 f0       	brcs	.+20     	; 0x192 <AC_Auto+0x6a>
	{
		DIO_SetPinDirection(DIO_PORTA,DIO_PIN2,DIO_PIN_OUTPUT);
     17e:	41 e0       	ldi	r20, 0x01	; 1
     180:	62 e0       	ldi	r22, 0x02	; 2
     182:	80 e0       	ldi	r24, 0x00	; 0
     184:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
		DIO_SetPinValue(DIO_PORTA,DIO_PIN2,DIO_PIN_HIGH);
     188:	41 e0       	ldi	r20, 0x01	; 1
     18a:	62 e0       	ldi	r22, 0x02	; 2
     18c:	80 e0       	ldi	r24, 0x00	; 0
     18e:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
     192:	08 95       	ret

00000194 <DIO_SetPinDirection>:
					*P_u8PortValue = PINC;
					break;
				}
				case DIO_PORTD:
				{
					*P_u8PortValue = PIND;
     194:	84 30       	cpi	r24, 0x04	; 4
     196:	08 f0       	brcs	.+2      	; 0x19a <DIO_SetPinDirection+0x6>
     198:	77 c0       	rjmp	.+238    	; 0x288 <DIO_SetPinDirection+0xf4>
     19a:	68 30       	cpi	r22, 0x08	; 8
     19c:	08 f0       	brcs	.+2      	; 0x1a0 <DIO_SetPinDirection+0xc>
     19e:	74 c0       	rjmp	.+232    	; 0x288 <DIO_SetPinDirection+0xf4>
     1a0:	81 30       	cpi	r24, 0x01	; 1
     1a2:	11 f1       	breq	.+68     	; 0x1e8 <DIO_SetPinDirection+0x54>
     1a4:	30 f0       	brcs	.+12     	; 0x1b2 <DIO_SetPinDirection+0x1e>
     1a6:	82 30       	cpi	r24, 0x02	; 2
     1a8:	d1 f1       	breq	.+116    	; 0x21e <DIO_SetPinDirection+0x8a>
     1aa:	83 30       	cpi	r24, 0x03	; 3
     1ac:	09 f4       	brne	.+2      	; 0x1b0 <DIO_SetPinDirection+0x1c>
     1ae:	52 c0       	rjmp	.+164    	; 0x254 <DIO_SetPinDirection+0xc0>
     1b0:	08 95       	ret
     1b2:	41 30       	cpi	r20, 0x01	; 1
     1b4:	59 f4       	brne	.+22     	; 0x1cc <DIO_SetPinDirection+0x38>
     1b6:	2a b3       	in	r18, 0x1a	; 26
     1b8:	81 e0       	ldi	r24, 0x01	; 1
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	02 c0       	rjmp	.+4      	; 0x1c2 <DIO_SetPinDirection+0x2e>
     1be:	88 0f       	add	r24, r24
     1c0:	99 1f       	adc	r25, r25
     1c2:	6a 95       	dec	r22
     1c4:	e2 f7       	brpl	.-8      	; 0x1be <DIO_SetPinDirection+0x2a>
     1c6:	82 2b       	or	r24, r18
     1c8:	8a bb       	out	0x1a, r24	; 26
     1ca:	08 95       	ret
     1cc:	41 11       	cpse	r20, r1
     1ce:	5c c0       	rjmp	.+184    	; 0x288 <DIO_SetPinDirection+0xf4>
     1d0:	2a b3       	in	r18, 0x1a	; 26
     1d2:	81 e0       	ldi	r24, 0x01	; 1
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <DIO_SetPinDirection+0x48>
     1d8:	88 0f       	add	r24, r24
     1da:	99 1f       	adc	r25, r25
     1dc:	6a 95       	dec	r22
     1de:	e2 f7       	brpl	.-8      	; 0x1d8 <DIO_SetPinDirection+0x44>
     1e0:	80 95       	com	r24
     1e2:	82 23       	and	r24, r18
     1e4:	8a bb       	out	0x1a, r24	; 26
     1e6:	08 95       	ret
     1e8:	41 30       	cpi	r20, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <DIO_SetPinDirection+0x6e>
     1ec:	27 b3       	in	r18, 0x17	; 23
     1ee:	81 e0       	ldi	r24, 0x01	; 1
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	02 c0       	rjmp	.+4      	; 0x1f8 <DIO_SetPinDirection+0x64>
     1f4:	88 0f       	add	r24, r24
     1f6:	99 1f       	adc	r25, r25
     1f8:	6a 95       	dec	r22
     1fa:	e2 f7       	brpl	.-8      	; 0x1f4 <DIO_SetPinDirection+0x60>
     1fc:	82 2b       	or	r24, r18
     1fe:	87 bb       	out	0x17, r24	; 23
     200:	08 95       	ret
     202:	41 11       	cpse	r20, r1
     204:	41 c0       	rjmp	.+130    	; 0x288 <DIO_SetPinDirection+0xf4>
     206:	27 b3       	in	r18, 0x17	; 23
     208:	81 e0       	ldi	r24, 0x01	; 1
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	02 c0       	rjmp	.+4      	; 0x212 <DIO_SetPinDirection+0x7e>
     20e:	88 0f       	add	r24, r24
     210:	99 1f       	adc	r25, r25
     212:	6a 95       	dec	r22
     214:	e2 f7       	brpl	.-8      	; 0x20e <DIO_SetPinDirection+0x7a>
     216:	80 95       	com	r24
     218:	82 23       	and	r24, r18
     21a:	87 bb       	out	0x17, r24	; 23
     21c:	08 95       	ret
     21e:	41 30       	cpi	r20, 0x01	; 1
     220:	59 f4       	brne	.+22     	; 0x238 <DIO_SetPinDirection+0xa4>
     222:	24 b3       	in	r18, 0x14	; 20
     224:	81 e0       	ldi	r24, 0x01	; 1
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	02 c0       	rjmp	.+4      	; 0x22e <DIO_SetPinDirection+0x9a>
     22a:	88 0f       	add	r24, r24
     22c:	99 1f       	adc	r25, r25
     22e:	6a 95       	dec	r22
     230:	e2 f7       	brpl	.-8      	; 0x22a <DIO_SetPinDirection+0x96>
     232:	82 2b       	or	r24, r18
     234:	84 bb       	out	0x14, r24	; 20
     236:	08 95       	ret
     238:	41 11       	cpse	r20, r1
     23a:	26 c0       	rjmp	.+76     	; 0x288 <DIO_SetPinDirection+0xf4>
     23c:	24 b3       	in	r18, 0x14	; 20
     23e:	81 e0       	ldi	r24, 0x01	; 1
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	02 c0       	rjmp	.+4      	; 0x248 <DIO_SetPinDirection+0xb4>
     244:	88 0f       	add	r24, r24
     246:	99 1f       	adc	r25, r25
     248:	6a 95       	dec	r22
     24a:	e2 f7       	brpl	.-8      	; 0x244 <DIO_SetPinDirection+0xb0>
     24c:	80 95       	com	r24
     24e:	82 23       	and	r24, r18
     250:	84 bb       	out	0x14, r24	; 20
     252:	08 95       	ret
     254:	41 30       	cpi	r20, 0x01	; 1
     256:	59 f4       	brne	.+22     	; 0x26e <DIO_SetPinDirection+0xda>
     258:	21 b3       	in	r18, 0x11	; 17
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	02 c0       	rjmp	.+4      	; 0x264 <DIO_SetPinDirection+0xd0>
     260:	88 0f       	add	r24, r24
     262:	99 1f       	adc	r25, r25
     264:	6a 95       	dec	r22
     266:	e2 f7       	brpl	.-8      	; 0x260 <DIO_SetPinDirection+0xcc>
     268:	82 2b       	or	r24, r18
     26a:	81 bb       	out	0x11, r24	; 17
     26c:	08 95       	ret
     26e:	41 11       	cpse	r20, r1
     270:	0b c0       	rjmp	.+22     	; 0x288 <DIO_SetPinDirection+0xf4>
     272:	21 b3       	in	r18, 0x11	; 17
     274:	81 e0       	ldi	r24, 0x01	; 1
     276:	90 e0       	ldi	r25, 0x00	; 0
     278:	02 c0       	rjmp	.+4      	; 0x27e <DIO_SetPinDirection+0xea>
     27a:	88 0f       	add	r24, r24
     27c:	99 1f       	adc	r25, r25
     27e:	6a 95       	dec	r22
     280:	e2 f7       	brpl	.-8      	; 0x27a <DIO_SetPinDirection+0xe6>
     282:	80 95       	com	r24
     284:	82 23       	and	r24, r18
     286:	81 bb       	out	0x11, r24	; 17
     288:	08 95       	ret

0000028a <DIO_SetPinValue>:
     28a:	84 30       	cpi	r24, 0x04	; 4
     28c:	08 f0       	brcs	.+2      	; 0x290 <DIO_SetPinValue+0x6>
     28e:	77 c0       	rjmp	.+238    	; 0x37e <DIO_SetPinValue+0xf4>
     290:	68 30       	cpi	r22, 0x08	; 8
     292:	08 f0       	brcs	.+2      	; 0x296 <DIO_SetPinValue+0xc>
     294:	74 c0       	rjmp	.+232    	; 0x37e <DIO_SetPinValue+0xf4>
     296:	81 30       	cpi	r24, 0x01	; 1
     298:	11 f1       	breq	.+68     	; 0x2de <DIO_SetPinValue+0x54>
     29a:	30 f0       	brcs	.+12     	; 0x2a8 <DIO_SetPinValue+0x1e>
     29c:	82 30       	cpi	r24, 0x02	; 2
     29e:	d1 f1       	breq	.+116    	; 0x314 <DIO_SetPinValue+0x8a>
     2a0:	83 30       	cpi	r24, 0x03	; 3
     2a2:	09 f4       	brne	.+2      	; 0x2a6 <DIO_SetPinValue+0x1c>
     2a4:	52 c0       	rjmp	.+164    	; 0x34a <DIO_SetPinValue+0xc0>
     2a6:	08 95       	ret
     2a8:	41 30       	cpi	r20, 0x01	; 1
     2aa:	59 f4       	brne	.+22     	; 0x2c2 <DIO_SetPinValue+0x38>
     2ac:	2b b3       	in	r18, 0x1b	; 27
     2ae:	81 e0       	ldi	r24, 0x01	; 1
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	02 c0       	rjmp	.+4      	; 0x2b8 <DIO_SetPinValue+0x2e>
     2b4:	88 0f       	add	r24, r24
     2b6:	99 1f       	adc	r25, r25
     2b8:	6a 95       	dec	r22
     2ba:	e2 f7       	brpl	.-8      	; 0x2b4 <DIO_SetPinValue+0x2a>
     2bc:	82 2b       	or	r24, r18
     2be:	8b bb       	out	0x1b, r24	; 27
     2c0:	08 95       	ret
     2c2:	41 11       	cpse	r20, r1
     2c4:	5c c0       	rjmp	.+184    	; 0x37e <DIO_SetPinValue+0xf4>
     2c6:	2b b3       	in	r18, 0x1b	; 27
     2c8:	81 e0       	ldi	r24, 0x01	; 1
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	02 c0       	rjmp	.+4      	; 0x2d2 <DIO_SetPinValue+0x48>
     2ce:	88 0f       	add	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	6a 95       	dec	r22
     2d4:	e2 f7       	brpl	.-8      	; 0x2ce <DIO_SetPinValue+0x44>
     2d6:	80 95       	com	r24
     2d8:	82 23       	and	r24, r18
     2da:	8b bb       	out	0x1b, r24	; 27
     2dc:	08 95       	ret
     2de:	41 30       	cpi	r20, 0x01	; 1
     2e0:	59 f4       	brne	.+22     	; 0x2f8 <DIO_SetPinValue+0x6e>
     2e2:	28 b3       	in	r18, 0x18	; 24
     2e4:	81 e0       	ldi	r24, 0x01	; 1
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	02 c0       	rjmp	.+4      	; 0x2ee <DIO_SetPinValue+0x64>
     2ea:	88 0f       	add	r24, r24
     2ec:	99 1f       	adc	r25, r25
     2ee:	6a 95       	dec	r22
     2f0:	e2 f7       	brpl	.-8      	; 0x2ea <DIO_SetPinValue+0x60>
     2f2:	82 2b       	or	r24, r18
     2f4:	88 bb       	out	0x18, r24	; 24
     2f6:	08 95       	ret
     2f8:	41 11       	cpse	r20, r1
     2fa:	41 c0       	rjmp	.+130    	; 0x37e <DIO_SetPinValue+0xf4>
     2fc:	28 b3       	in	r18, 0x18	; 24
     2fe:	81 e0       	ldi	r24, 0x01	; 1
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	02 c0       	rjmp	.+4      	; 0x308 <DIO_SetPinValue+0x7e>
     304:	88 0f       	add	r24, r24
     306:	99 1f       	adc	r25, r25
     308:	6a 95       	dec	r22
     30a:	e2 f7       	brpl	.-8      	; 0x304 <DIO_SetPinValue+0x7a>
     30c:	80 95       	com	r24
     30e:	82 23       	and	r24, r18
     310:	88 bb       	out	0x18, r24	; 24
     312:	08 95       	ret
     314:	41 30       	cpi	r20, 0x01	; 1
     316:	59 f4       	brne	.+22     	; 0x32e <DIO_SetPinValue+0xa4>
     318:	25 b3       	in	r18, 0x15	; 21
     31a:	81 e0       	ldi	r24, 0x01	; 1
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	02 c0       	rjmp	.+4      	; 0x324 <DIO_SetPinValue+0x9a>
     320:	88 0f       	add	r24, r24
     322:	99 1f       	adc	r25, r25
     324:	6a 95       	dec	r22
     326:	e2 f7       	brpl	.-8      	; 0x320 <DIO_SetPinValue+0x96>
     328:	82 2b       	or	r24, r18
     32a:	85 bb       	out	0x15, r24	; 21
     32c:	08 95       	ret
     32e:	41 11       	cpse	r20, r1
     330:	26 c0       	rjmp	.+76     	; 0x37e <DIO_SetPinValue+0xf4>
     332:	25 b3       	in	r18, 0x15	; 21
     334:	81 e0       	ldi	r24, 0x01	; 1
     336:	90 e0       	ldi	r25, 0x00	; 0
     338:	02 c0       	rjmp	.+4      	; 0x33e <DIO_SetPinValue+0xb4>
     33a:	88 0f       	add	r24, r24
     33c:	99 1f       	adc	r25, r25
     33e:	6a 95       	dec	r22
     340:	e2 f7       	brpl	.-8      	; 0x33a <DIO_SetPinValue+0xb0>
     342:	80 95       	com	r24
     344:	82 23       	and	r24, r18
     346:	85 bb       	out	0x15, r24	; 21
     348:	08 95       	ret
     34a:	41 30       	cpi	r20, 0x01	; 1
     34c:	59 f4       	brne	.+22     	; 0x364 <DIO_SetPinValue+0xda>
     34e:	22 b3       	in	r18, 0x12	; 18
     350:	81 e0       	ldi	r24, 0x01	; 1
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	02 c0       	rjmp	.+4      	; 0x35a <DIO_SetPinValue+0xd0>
     356:	88 0f       	add	r24, r24
     358:	99 1f       	adc	r25, r25
     35a:	6a 95       	dec	r22
     35c:	e2 f7       	brpl	.-8      	; 0x356 <DIO_SetPinValue+0xcc>
     35e:	82 2b       	or	r24, r18
     360:	82 bb       	out	0x12, r24	; 18
     362:	08 95       	ret
     364:	41 11       	cpse	r20, r1
     366:	0b c0       	rjmp	.+22     	; 0x37e <DIO_SetPinValue+0xf4>
     368:	22 b3       	in	r18, 0x12	; 18
     36a:	81 e0       	ldi	r24, 0x01	; 1
     36c:	90 e0       	ldi	r25, 0x00	; 0
     36e:	02 c0       	rjmp	.+4      	; 0x374 <DIO_SetPinValue+0xea>
     370:	88 0f       	add	r24, r24
     372:	99 1f       	adc	r25, r25
     374:	6a 95       	dec	r22
     376:	e2 f7       	brpl	.-8      	; 0x370 <DIO_SetPinValue+0xe6>
     378:	80 95       	com	r24
     37a:	82 23       	and	r24, r18
     37c:	82 bb       	out	0x12, r24	; 18
     37e:	08 95       	ret

00000380 <DIO_ReadPinValue>:
     380:	41 15       	cp	r20, r1
     382:	51 05       	cpc	r21, r1
     384:	09 f4       	brne	.+2      	; 0x388 <DIO_ReadPinValue+0x8>
     386:	76 c0       	rjmp	.+236    	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     388:	84 30       	cpi	r24, 0x04	; 4
     38a:	08 f0       	brcs	.+2      	; 0x38e <DIO_ReadPinValue+0xe>
     38c:	73 c0       	rjmp	.+230    	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     38e:	68 30       	cpi	r22, 0x08	; 8
     390:	08 f0       	brcs	.+2      	; 0x394 <DIO_ReadPinValue+0x14>
     392:	70 c0       	rjmp	.+224    	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     394:	81 30       	cpi	r24, 0x01	; 1
     396:	09 f1       	breq	.+66     	; 0x3da <DIO_ReadPinValue+0x5a>
     398:	30 f0       	brcs	.+12     	; 0x3a6 <DIO_ReadPinValue+0x26>
     39a:	82 30       	cpi	r24, 0x02	; 2
     39c:	c1 f1       	breq	.+112    	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     39e:	83 30       	cpi	r24, 0x03	; 3
     3a0:	09 f4       	brne	.+2      	; 0x3a4 <DIO_ReadPinValue+0x24>
     3a2:	4f c0       	rjmp	.+158    	; 0x442 <__EEPROM_REGION_LENGTH__+0x42>
     3a4:	08 95       	ret
     3a6:	89 b3       	in	r24, 0x19	; 25
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	06 2e       	mov	r0, r22
     3ac:	02 c0       	rjmp	.+4      	; 0x3b2 <DIO_ReadPinValue+0x32>
     3ae:	95 95       	asr	r25
     3b0:	87 95       	ror	r24
     3b2:	0a 94       	dec	r0
     3b4:	e2 f7       	brpl	.-8      	; 0x3ae <DIO_ReadPinValue+0x2e>
     3b6:	80 ff       	sbrs	r24, 0
     3b8:	04 c0       	rjmp	.+8      	; 0x3c2 <DIO_ReadPinValue+0x42>
     3ba:	81 e0       	ldi	r24, 0x01	; 1
     3bc:	fa 01       	movw	r30, r20
     3be:	80 83       	st	Z, r24
     3c0:	08 95       	ret
     3c2:	89 b3       	in	r24, 0x19	; 25
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	02 c0       	rjmp	.+4      	; 0x3cc <DIO_ReadPinValue+0x4c>
     3c8:	95 95       	asr	r25
     3ca:	87 95       	ror	r24
     3cc:	6a 95       	dec	r22
     3ce:	e2 f7       	brpl	.-8      	; 0x3c8 <DIO_ReadPinValue+0x48>
     3d0:	80 fd       	sbrc	r24, 0
     3d2:	50 c0       	rjmp	.+160    	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     3d4:	fa 01       	movw	r30, r20
     3d6:	10 82       	st	Z, r1
     3d8:	08 95       	ret
     3da:	86 b3       	in	r24, 0x16	; 22
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	06 2e       	mov	r0, r22
     3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <DIO_ReadPinValue+0x66>
     3e2:	95 95       	asr	r25
     3e4:	87 95       	ror	r24
     3e6:	0a 94       	dec	r0
     3e8:	e2 f7       	brpl	.-8      	; 0x3e2 <DIO_ReadPinValue+0x62>
     3ea:	80 ff       	sbrs	r24, 0
     3ec:	04 c0       	rjmp	.+8      	; 0x3f6 <DIO_ReadPinValue+0x76>
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	fa 01       	movw	r30, r20
     3f2:	80 83       	st	Z, r24
     3f4:	08 95       	ret
     3f6:	86 b3       	in	r24, 0x16	; 22
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 c0       	rjmp	.+4      	; 0x400 <__EEPROM_REGION_LENGTH__>
     3fc:	95 95       	asr	r25
     3fe:	87 95       	ror	r24
     400:	6a 95       	dec	r22
     402:	e2 f7       	brpl	.-8      	; 0x3fc <DIO_ReadPinValue+0x7c>
     404:	80 fd       	sbrc	r24, 0
     406:	36 c0       	rjmp	.+108    	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     408:	fa 01       	movw	r30, r20
     40a:	10 82       	st	Z, r1
     40c:	08 95       	ret
     40e:	83 b3       	in	r24, 0x13	; 19
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	06 2e       	mov	r0, r22
     414:	02 c0       	rjmp	.+4      	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
     416:	95 95       	asr	r25
     418:	87 95       	ror	r24
     41a:	0a 94       	dec	r0
     41c:	e2 f7       	brpl	.-8      	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
     41e:	80 ff       	sbrs	r24, 0
     420:	04 c0       	rjmp	.+8      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
     422:	81 e0       	ldi	r24, 0x01	; 1
     424:	fa 01       	movw	r30, r20
     426:	80 83       	st	Z, r24
     428:	08 95       	ret
     42a:	83 b3       	in	r24, 0x13	; 19
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	02 c0       	rjmp	.+4      	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
     430:	95 95       	asr	r25
     432:	87 95       	ror	r24
     434:	6a 95       	dec	r22
     436:	e2 f7       	brpl	.-8      	; 0x430 <__EEPROM_REGION_LENGTH__+0x30>
     438:	80 fd       	sbrc	r24, 0
     43a:	1c c0       	rjmp	.+56     	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     43c:	fa 01       	movw	r30, r20
     43e:	10 82       	st	Z, r1
     440:	08 95       	ret
     442:	80 b3       	in	r24, 0x10	; 16
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	06 2e       	mov	r0, r22
     448:	02 c0       	rjmp	.+4      	; 0x44e <__EEPROM_REGION_LENGTH__+0x4e>
     44a:	95 95       	asr	r25
     44c:	87 95       	ror	r24
     44e:	0a 94       	dec	r0
     450:	e2 f7       	brpl	.-8      	; 0x44a <__EEPROM_REGION_LENGTH__+0x4a>
     452:	80 ff       	sbrs	r24, 0
     454:	04 c0       	rjmp	.+8      	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	fa 01       	movw	r30, r20
     45a:	80 83       	st	Z, r24
     45c:	08 95       	ret
     45e:	80 b3       	in	r24, 0x10	; 16
     460:	90 e0       	ldi	r25, 0x00	; 0
     462:	02 c0       	rjmp	.+4      	; 0x468 <__EEPROM_REGION_LENGTH__+0x68>
     464:	95 95       	asr	r25
     466:	87 95       	ror	r24
     468:	6a 95       	dec	r22
     46a:	e2 f7       	brpl	.-8      	; 0x464 <__EEPROM_REGION_LENGTH__+0x64>
     46c:	80 fd       	sbrc	r24, 0
     46e:	02 c0       	rjmp	.+4      	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     470:	fa 01       	movw	r30, r20
     472:	10 82       	st	Z, r1
     474:	08 95       	ret

00000476 <DIO_ReadOutputPinValue>:
     476:	41 15       	cp	r20, r1
     478:	51 05       	cpc	r21, r1
     47a:	09 f4       	brne	.+2      	; 0x47e <DIO_ReadOutputPinValue+0x8>
     47c:	76 c0       	rjmp	.+236    	; 0x56a <DIO_ReadOutputPinValue+0xf4>
     47e:	84 30       	cpi	r24, 0x04	; 4
     480:	08 f0       	brcs	.+2      	; 0x484 <DIO_ReadOutputPinValue+0xe>
     482:	73 c0       	rjmp	.+230    	; 0x56a <DIO_ReadOutputPinValue+0xf4>
     484:	68 30       	cpi	r22, 0x08	; 8
     486:	08 f0       	brcs	.+2      	; 0x48a <DIO_ReadOutputPinValue+0x14>
     488:	70 c0       	rjmp	.+224    	; 0x56a <DIO_ReadOutputPinValue+0xf4>
     48a:	81 30       	cpi	r24, 0x01	; 1
     48c:	09 f1       	breq	.+66     	; 0x4d0 <DIO_ReadOutputPinValue+0x5a>
     48e:	30 f0       	brcs	.+12     	; 0x49c <DIO_ReadOutputPinValue+0x26>
     490:	82 30       	cpi	r24, 0x02	; 2
     492:	c1 f1       	breq	.+112    	; 0x504 <DIO_ReadOutputPinValue+0x8e>
     494:	83 30       	cpi	r24, 0x03	; 3
     496:	09 f4       	brne	.+2      	; 0x49a <DIO_ReadOutputPinValue+0x24>
     498:	4f c0       	rjmp	.+158    	; 0x538 <DIO_ReadOutputPinValue+0xc2>
     49a:	08 95       	ret
     49c:	8b b3       	in	r24, 0x1b	; 27
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	06 2e       	mov	r0, r22
     4a2:	02 c0       	rjmp	.+4      	; 0x4a8 <DIO_ReadOutputPinValue+0x32>
     4a4:	95 95       	asr	r25
     4a6:	87 95       	ror	r24
     4a8:	0a 94       	dec	r0
     4aa:	e2 f7       	brpl	.-8      	; 0x4a4 <DIO_ReadOutputPinValue+0x2e>
     4ac:	80 ff       	sbrs	r24, 0
     4ae:	04 c0       	rjmp	.+8      	; 0x4b8 <DIO_ReadOutputPinValue+0x42>
     4b0:	81 e0       	ldi	r24, 0x01	; 1
     4b2:	fa 01       	movw	r30, r20
     4b4:	80 83       	st	Z, r24
     4b6:	08 95       	ret
     4b8:	8b b3       	in	r24, 0x1b	; 27
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	02 c0       	rjmp	.+4      	; 0x4c2 <DIO_ReadOutputPinValue+0x4c>
     4be:	95 95       	asr	r25
     4c0:	87 95       	ror	r24
     4c2:	6a 95       	dec	r22
     4c4:	e2 f7       	brpl	.-8      	; 0x4be <DIO_ReadOutputPinValue+0x48>
     4c6:	80 fd       	sbrc	r24, 0
     4c8:	50 c0       	rjmp	.+160    	; 0x56a <DIO_ReadOutputPinValue+0xf4>
     4ca:	fa 01       	movw	r30, r20
     4cc:	10 82       	st	Z, r1
     4ce:	08 95       	ret
     4d0:	88 b3       	in	r24, 0x18	; 24
     4d2:	90 e0       	ldi	r25, 0x00	; 0
     4d4:	06 2e       	mov	r0, r22
     4d6:	02 c0       	rjmp	.+4      	; 0x4dc <DIO_ReadOutputPinValue+0x66>
     4d8:	95 95       	asr	r25
     4da:	87 95       	ror	r24
     4dc:	0a 94       	dec	r0
     4de:	e2 f7       	brpl	.-8      	; 0x4d8 <DIO_ReadOutputPinValue+0x62>
     4e0:	80 ff       	sbrs	r24, 0
     4e2:	04 c0       	rjmp	.+8      	; 0x4ec <DIO_ReadOutputPinValue+0x76>
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	fa 01       	movw	r30, r20
     4e8:	80 83       	st	Z, r24
     4ea:	08 95       	ret
     4ec:	88 b3       	in	r24, 0x18	; 24
     4ee:	90 e0       	ldi	r25, 0x00	; 0
     4f0:	02 c0       	rjmp	.+4      	; 0x4f6 <DIO_ReadOutputPinValue+0x80>
     4f2:	95 95       	asr	r25
     4f4:	87 95       	ror	r24
     4f6:	6a 95       	dec	r22
     4f8:	e2 f7       	brpl	.-8      	; 0x4f2 <DIO_ReadOutputPinValue+0x7c>
     4fa:	80 fd       	sbrc	r24, 0
     4fc:	36 c0       	rjmp	.+108    	; 0x56a <DIO_ReadOutputPinValue+0xf4>
     4fe:	fa 01       	movw	r30, r20
     500:	10 82       	st	Z, r1
     502:	08 95       	ret
     504:	85 b3       	in	r24, 0x15	; 21
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	06 2e       	mov	r0, r22
     50a:	02 c0       	rjmp	.+4      	; 0x510 <DIO_ReadOutputPinValue+0x9a>
     50c:	95 95       	asr	r25
     50e:	87 95       	ror	r24
     510:	0a 94       	dec	r0
     512:	e2 f7       	brpl	.-8      	; 0x50c <DIO_ReadOutputPinValue+0x96>
     514:	80 ff       	sbrs	r24, 0
     516:	04 c0       	rjmp	.+8      	; 0x520 <DIO_ReadOutputPinValue+0xaa>
     518:	81 e0       	ldi	r24, 0x01	; 1
     51a:	fa 01       	movw	r30, r20
     51c:	80 83       	st	Z, r24
     51e:	08 95       	ret
     520:	85 b3       	in	r24, 0x15	; 21
     522:	90 e0       	ldi	r25, 0x00	; 0
     524:	02 c0       	rjmp	.+4      	; 0x52a <DIO_ReadOutputPinValue+0xb4>
     526:	95 95       	asr	r25
     528:	87 95       	ror	r24
     52a:	6a 95       	dec	r22
     52c:	e2 f7       	brpl	.-8      	; 0x526 <DIO_ReadOutputPinValue+0xb0>
     52e:	80 fd       	sbrc	r24, 0
     530:	1c c0       	rjmp	.+56     	; 0x56a <DIO_ReadOutputPinValue+0xf4>
     532:	fa 01       	movw	r30, r20
     534:	10 82       	st	Z, r1
     536:	08 95       	ret
     538:	82 b3       	in	r24, 0x12	; 18
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	06 2e       	mov	r0, r22
     53e:	02 c0       	rjmp	.+4      	; 0x544 <DIO_ReadOutputPinValue+0xce>
     540:	95 95       	asr	r25
     542:	87 95       	ror	r24
     544:	0a 94       	dec	r0
     546:	e2 f7       	brpl	.-8      	; 0x540 <DIO_ReadOutputPinValue+0xca>
     548:	80 ff       	sbrs	r24, 0
     54a:	04 c0       	rjmp	.+8      	; 0x554 <DIO_ReadOutputPinValue+0xde>
     54c:	81 e0       	ldi	r24, 0x01	; 1
     54e:	fa 01       	movw	r30, r20
     550:	80 83       	st	Z, r24
     552:	08 95       	ret
     554:	82 b3       	in	r24, 0x12	; 18
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	02 c0       	rjmp	.+4      	; 0x55e <DIO_ReadOutputPinValue+0xe8>
     55a:	95 95       	asr	r25
     55c:	87 95       	ror	r24
     55e:	6a 95       	dec	r22
     560:	e2 f7       	brpl	.-8      	; 0x55a <DIO_ReadOutputPinValue+0xe4>
     562:	80 fd       	sbrc	r24, 0
     564:	02 c0       	rjmp	.+4      	; 0x56a <DIO_ReadOutputPinValue+0xf4>
     566:	fa 01       	movw	r30, r20
     568:	10 82       	st	Z, r1
     56a:	08 95       	ret

0000056c <DIO_WriteHalfPort>:
     56c:	0f 93       	push	r16
     56e:	1f 93       	push	r17
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
     574:	84 30       	cpi	r24, 0x04	; 4
     576:	20 f5       	brcc	.+72     	; 0x5c0 <DIO_WriteHalfPort+0x54>
     578:	65 30       	cpi	r22, 0x05	; 5
     57a:	10 f5       	brcc	.+68     	; 0x5c0 <DIO_WriteHalfPort+0x54>
     57c:	40 31       	cpi	r20, 0x10	; 16
     57e:	d0 f0       	brcs	.+52     	; 0x5b4 <DIO_WriteHalfPort+0x48>
     580:	1f c0       	rjmp	.+62     	; 0x5c0 <DIO_WriteHalfPort+0x54>
     582:	20 2f       	mov	r18, r16
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	0c 2e       	mov	r0, r28
     588:	02 c0       	rjmp	.+4      	; 0x58e <DIO_WriteHalfPort+0x22>
     58a:	35 95       	asr	r19
     58c:	27 95       	ror	r18
     58e:	0a 94       	dec	r0
     590:	e2 f7       	brpl	.-8      	; 0x58a <DIO_WriteHalfPort+0x1e>
     592:	20 ff       	sbrs	r18, 0
     594:	07 c0       	rjmp	.+14     	; 0x5a4 <DIO_WriteHalfPort+0x38>
     596:	41 e0       	ldi	r20, 0x01	; 1
     598:	6c 2f       	mov	r22, r28
     59a:	61 0f       	add	r22, r17
     59c:	8d 2f       	mov	r24, r29
     59e:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
     5a2:	06 c0       	rjmp	.+12     	; 0x5b0 <DIO_WriteHalfPort+0x44>
     5a4:	40 e0       	ldi	r20, 0x00	; 0
     5a6:	6c 2f       	mov	r22, r28
     5a8:	61 0f       	add	r22, r17
     5aa:	8d 2f       	mov	r24, r29
     5ac:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
     5b0:	cf 5f       	subi	r28, 0xFF	; 255
     5b2:	04 c0       	rjmp	.+8      	; 0x5bc <DIO_WriteHalfPort+0x50>
     5b4:	04 2f       	mov	r16, r20
     5b6:	16 2f       	mov	r17, r22
     5b8:	d8 2f       	mov	r29, r24
     5ba:	c0 e0       	ldi	r28, 0x00	; 0
     5bc:	c4 30       	cpi	r28, 0x04	; 4
     5be:	08 f3       	brcs	.-62     	; 0x582 <DIO_WriteHalfPort+0x16>
     5c0:	df 91       	pop	r29
     5c2:	cf 91       	pop	r28
     5c4:	1f 91       	pop	r17
     5c6:	0f 91       	pop	r16
     5c8:	08 95       	ret

000005ca <DIO_ActivatePullUp>:
 * @param Copy_u8PortID: The ID of the Port containing the desired pin
 * @param Copy_u8PinID: The pin for its pull-up resistor to be activated
 */
void DIO_ActivatePullUp     (u8 Copy_u8PortID, u8 Copy_u8PinID)
{
	if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
     5ca:	84 30       	cpi	r24, 0x04	; 4
     5cc:	08 f0       	brcs	.+2      	; 0x5d0 <DIO_ActivatePullUp+0x6>
     5ce:	5f c0       	rjmp	.+190    	; 0x68e <DIO_ActivatePullUp+0xc4>
	{
		if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
     5d0:	68 30       	cpi	r22, 0x08	; 8
     5d2:	08 f0       	brcs	.+2      	; 0x5d6 <DIO_ActivatePullUp+0xc>
     5d4:	5c c0       	rjmp	.+184    	; 0x68e <DIO_ActivatePullUp+0xc4>
		{
			switch(Copy_u8PortID)
     5d6:	81 30       	cpi	r24, 0x01	; 1
     5d8:	e1 f0       	breq	.+56     	; 0x612 <DIO_ActivatePullUp+0x48>
     5da:	30 f0       	brcs	.+12     	; 0x5e8 <DIO_ActivatePullUp+0x1e>
     5dc:	82 30       	cpi	r24, 0x02	; 2
     5de:	71 f1       	breq	.+92     	; 0x63c <DIO_ActivatePullUp+0x72>
     5e0:	83 30       	cpi	r24, 0x03	; 3
     5e2:	09 f4       	brne	.+2      	; 0x5e6 <DIO_ActivatePullUp+0x1c>
     5e4:	40 c0       	rjmp	.+128    	; 0x666 <DIO_ActivatePullUp+0x9c>
     5e6:	08 95       	ret
			{
				case DIO_PORTA:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRA, Copy_u8PinID))
     5e8:	8a b3       	in	r24, 0x1a	; 26
     5ea:	90 e0       	ldi	r25, 0x00	; 0
     5ec:	06 2e       	mov	r0, r22
     5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <DIO_ActivatePullUp+0x2a>
     5f0:	95 95       	asr	r25
     5f2:	87 95       	ror	r24
     5f4:	0a 94       	dec	r0
     5f6:	e2 f7       	brpl	.-8      	; 0x5f0 <DIO_ActivatePullUp+0x26>
     5f8:	80 fd       	sbrc	r24, 0
     5fa:	49 c0       	rjmp	.+146    	; 0x68e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTA, Copy_u8PinID);
     5fc:	2b b3       	in	r18, 0x1b	; 27
     5fe:	81 e0       	ldi	r24, 0x01	; 1
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	02 c0       	rjmp	.+4      	; 0x608 <DIO_ActivatePullUp+0x3e>
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	6a 95       	dec	r22
     60a:	e2 f7       	brpl	.-8      	; 0x604 <DIO_ActivatePullUp+0x3a>
     60c:	82 2b       	or	r24, r18
     60e:	8b bb       	out	0x1b, r24	; 27
     610:	08 95       	ret
					}
					break;
				}
				case DIO_PORTB:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRB, Copy_u8PinID))
     612:	87 b3       	in	r24, 0x17	; 23
     614:	90 e0       	ldi	r25, 0x00	; 0
     616:	06 2e       	mov	r0, r22
     618:	02 c0       	rjmp	.+4      	; 0x61e <DIO_ActivatePullUp+0x54>
     61a:	95 95       	asr	r25
     61c:	87 95       	ror	r24
     61e:	0a 94       	dec	r0
     620:	e2 f7       	brpl	.-8      	; 0x61a <DIO_ActivatePullUp+0x50>
     622:	80 fd       	sbrc	r24, 0
     624:	34 c0       	rjmp	.+104    	; 0x68e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTB, Copy_u8PinID);
     626:	28 b3       	in	r18, 0x18	; 24
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	02 c0       	rjmp	.+4      	; 0x632 <DIO_ActivatePullUp+0x68>
     62e:	88 0f       	add	r24, r24
     630:	99 1f       	adc	r25, r25
     632:	6a 95       	dec	r22
     634:	e2 f7       	brpl	.-8      	; 0x62e <DIO_ActivatePullUp+0x64>
     636:	82 2b       	or	r24, r18
     638:	88 bb       	out	0x18, r24	; 24
     63a:	08 95       	ret
					}
					break;
				}
				case DIO_PORTC:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRC, Copy_u8PinID))
     63c:	84 b3       	in	r24, 0x14	; 20
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	06 2e       	mov	r0, r22
     642:	02 c0       	rjmp	.+4      	; 0x648 <DIO_ActivatePullUp+0x7e>
     644:	95 95       	asr	r25
     646:	87 95       	ror	r24
     648:	0a 94       	dec	r0
     64a:	e2 f7       	brpl	.-8      	; 0x644 <DIO_ActivatePullUp+0x7a>
     64c:	80 fd       	sbrc	r24, 0
     64e:	1f c0       	rjmp	.+62     	; 0x68e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTC, Copy_u8PinID);
     650:	25 b3       	in	r18, 0x15	; 21
     652:	81 e0       	ldi	r24, 0x01	; 1
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	02 c0       	rjmp	.+4      	; 0x65c <DIO_ActivatePullUp+0x92>
     658:	88 0f       	add	r24, r24
     65a:	99 1f       	adc	r25, r25
     65c:	6a 95       	dec	r22
     65e:	e2 f7       	brpl	.-8      	; 0x658 <DIO_ActivatePullUp+0x8e>
     660:	82 2b       	or	r24, r18
     662:	85 bb       	out	0x15, r24	; 21
     664:	08 95       	ret
					}
					break;
				}
				case DIO_PORTD:
				{
					if(DIO_PIN_LOW == GET_BIT(DDRD, Copy_u8PinID))
     666:	81 b3       	in	r24, 0x11	; 17
     668:	90 e0       	ldi	r25, 0x00	; 0
     66a:	06 2e       	mov	r0, r22
     66c:	02 c0       	rjmp	.+4      	; 0x672 <DIO_ActivatePullUp+0xa8>
     66e:	95 95       	asr	r25
     670:	87 95       	ror	r24
     672:	0a 94       	dec	r0
     674:	e2 f7       	brpl	.-8      	; 0x66e <DIO_ActivatePullUp+0xa4>
     676:	80 fd       	sbrc	r24, 0
     678:	0a c0       	rjmp	.+20     	; 0x68e <DIO_ActivatePullUp+0xc4>
					{
						SET_BIT(PORTD, Copy_u8PinID);
     67a:	22 b3       	in	r18, 0x12	; 18
     67c:	81 e0       	ldi	r24, 0x01	; 1
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	02 c0       	rjmp	.+4      	; 0x686 <DIO_ActivatePullUp+0xbc>
     682:	88 0f       	add	r24, r24
     684:	99 1f       	adc	r25, r25
     686:	6a 95       	dec	r22
     688:	e2 f7       	brpl	.-8      	; 0x682 <DIO_ActivatePullUp+0xb8>
     68a:	82 2b       	or	r24, r18
     68c:	82 bb       	out	0x12, r24	; 18
     68e:	08 95       	ret

00000690 <DIO_ReadDDRPinValue>:
 * @param Copy_u8PinID: The ID of the desired pin 
 * @param P_u8DDRPinValue: Pointer in which we save the desired value
 */
void DIO_ReadDDRPinValue    (u8 Copy_u8PortID, u8 Copy_u8PinID, u8* P_u8DDRPinValue)
{
	if(P_u8DDRPinValue != NULL)
     690:	41 15       	cp	r20, r1
     692:	51 05       	cpc	r21, r1
     694:	09 f4       	brne	.+2      	; 0x698 <DIO_ReadDDRPinValue+0x8>
     696:	76 c0       	rjmp	.+236    	; 0x784 <DIO_ReadDDRPinValue+0xf4>
	{
		if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
     698:	84 30       	cpi	r24, 0x04	; 4
     69a:	08 f0       	brcs	.+2      	; 0x69e <DIO_ReadDDRPinValue+0xe>
     69c:	73 c0       	rjmp	.+230    	; 0x784 <DIO_ReadDDRPinValue+0xf4>
		{
			if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
     69e:	68 30       	cpi	r22, 0x08	; 8
     6a0:	08 f0       	brcs	.+2      	; 0x6a4 <DIO_ReadDDRPinValue+0x14>
     6a2:	70 c0       	rjmp	.+224    	; 0x784 <DIO_ReadDDRPinValue+0xf4>
			{
				switch (Copy_u8PortID)
     6a4:	81 30       	cpi	r24, 0x01	; 1
     6a6:	09 f1       	breq	.+66     	; 0x6ea <DIO_ReadDDRPinValue+0x5a>
     6a8:	30 f0       	brcs	.+12     	; 0x6b6 <DIO_ReadDDRPinValue+0x26>
     6aa:	82 30       	cpi	r24, 0x02	; 2
     6ac:	c1 f1       	breq	.+112    	; 0x71e <DIO_ReadDDRPinValue+0x8e>
     6ae:	83 30       	cpi	r24, 0x03	; 3
     6b0:	09 f4       	brne	.+2      	; 0x6b4 <DIO_ReadDDRPinValue+0x24>
     6b2:	4f c0       	rjmp	.+158    	; 0x752 <DIO_ReadDDRPinValue+0xc2>
     6b4:	08 95       	ret
				{
					case DIO_PORTA:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRA, Copy_u8PinID))
     6b6:	8a b3       	in	r24, 0x1a	; 26
     6b8:	90 e0       	ldi	r25, 0x00	; 0
     6ba:	06 2e       	mov	r0, r22
     6bc:	02 c0       	rjmp	.+4      	; 0x6c2 <DIO_ReadDDRPinValue+0x32>
     6be:	95 95       	asr	r25
     6c0:	87 95       	ror	r24
     6c2:	0a 94       	dec	r0
     6c4:	e2 f7       	brpl	.-8      	; 0x6be <DIO_ReadDDRPinValue+0x2e>
     6c6:	80 ff       	sbrs	r24, 0
     6c8:	04 c0       	rjmp	.+8      	; 0x6d2 <DIO_ReadDDRPinValue+0x42>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     6ca:	81 e0       	ldi	r24, 0x01	; 1
     6cc:	fa 01       	movw	r30, r20
     6ce:	80 83       	st	Z, r24
     6d0:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRA, Copy_u8PinID))
     6d2:	8a b3       	in	r24, 0x1a	; 26
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	02 c0       	rjmp	.+4      	; 0x6dc <DIO_ReadDDRPinValue+0x4c>
     6d8:	95 95       	asr	r25
     6da:	87 95       	ror	r24
     6dc:	6a 95       	dec	r22
     6de:	e2 f7       	brpl	.-8      	; 0x6d8 <DIO_ReadDDRPinValue+0x48>
     6e0:	80 fd       	sbrc	r24, 0
     6e2:	50 c0       	rjmp	.+160    	; 0x784 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     6e4:	fa 01       	movw	r30, r20
     6e6:	10 82       	st	Z, r1
     6e8:	08 95       	ret
						}
						break;
					}
					case DIO_PORTB:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRB, Copy_u8PinID))
     6ea:	87 b3       	in	r24, 0x17	; 23
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	06 2e       	mov	r0, r22
     6f0:	02 c0       	rjmp	.+4      	; 0x6f6 <DIO_ReadDDRPinValue+0x66>
     6f2:	95 95       	asr	r25
     6f4:	87 95       	ror	r24
     6f6:	0a 94       	dec	r0
     6f8:	e2 f7       	brpl	.-8      	; 0x6f2 <DIO_ReadDDRPinValue+0x62>
     6fa:	80 ff       	sbrs	r24, 0
     6fc:	04 c0       	rjmp	.+8      	; 0x706 <DIO_ReadDDRPinValue+0x76>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	fa 01       	movw	r30, r20
     702:	80 83       	st	Z, r24
     704:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRB, Copy_u8PinID))
     706:	87 b3       	in	r24, 0x17	; 23
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	02 c0       	rjmp	.+4      	; 0x710 <DIO_ReadDDRPinValue+0x80>
     70c:	95 95       	asr	r25
     70e:	87 95       	ror	r24
     710:	6a 95       	dec	r22
     712:	e2 f7       	brpl	.-8      	; 0x70c <DIO_ReadDDRPinValue+0x7c>
     714:	80 fd       	sbrc	r24, 0
     716:	36 c0       	rjmp	.+108    	; 0x784 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     718:	fa 01       	movw	r30, r20
     71a:	10 82       	st	Z, r1
     71c:	08 95       	ret
						}
						break;
					}
					case DIO_PORTC:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRC, Copy_u8PinID))
     71e:	84 b3       	in	r24, 0x14	; 20
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	06 2e       	mov	r0, r22
     724:	02 c0       	rjmp	.+4      	; 0x72a <DIO_ReadDDRPinValue+0x9a>
     726:	95 95       	asr	r25
     728:	87 95       	ror	r24
     72a:	0a 94       	dec	r0
     72c:	e2 f7       	brpl	.-8      	; 0x726 <DIO_ReadDDRPinValue+0x96>
     72e:	80 ff       	sbrs	r24, 0
     730:	04 c0       	rjmp	.+8      	; 0x73a <DIO_ReadDDRPinValue+0xaa>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	fa 01       	movw	r30, r20
     736:	80 83       	st	Z, r24
     738:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRC, Copy_u8PinID))
     73a:	84 b3       	in	r24, 0x14	; 20
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	02 c0       	rjmp	.+4      	; 0x744 <DIO_ReadDDRPinValue+0xb4>
     740:	95 95       	asr	r25
     742:	87 95       	ror	r24
     744:	6a 95       	dec	r22
     746:	e2 f7       	brpl	.-8      	; 0x740 <DIO_ReadDDRPinValue+0xb0>
     748:	80 fd       	sbrc	r24, 0
     74a:	1c c0       	rjmp	.+56     	; 0x784 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     74c:	fa 01       	movw	r30, r20
     74e:	10 82       	st	Z, r1
     750:	08 95       	ret
						}
						break;
					}
					case DIO_PORTD:
					{
						if(DIO_PIN_OUTPUT == GET_BIT(DDRD, Copy_u8PinID))
     752:	81 b3       	in	r24, 0x11	; 17
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	06 2e       	mov	r0, r22
     758:	02 c0       	rjmp	.+4      	; 0x75e <DIO_ReadDDRPinValue+0xce>
     75a:	95 95       	asr	r25
     75c:	87 95       	ror	r24
     75e:	0a 94       	dec	r0
     760:	e2 f7       	brpl	.-8      	; 0x75a <DIO_ReadDDRPinValue+0xca>
     762:	80 ff       	sbrs	r24, 0
     764:	04 c0       	rjmp	.+8      	; 0x76e <DIO_ReadDDRPinValue+0xde>
						{
							*P_u8DDRPinValue = DIO_PIN_OUTPUT;
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	fa 01       	movw	r30, r20
     76a:	80 83       	st	Z, r24
     76c:	08 95       	ret
						}
						else if(DIO_PIN_INPUT == GET_BIT(DDRD, Copy_u8PinID))
     76e:	81 b3       	in	r24, 0x11	; 17
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	02 c0       	rjmp	.+4      	; 0x778 <DIO_ReadDDRPinValue+0xe8>
     774:	95 95       	asr	r25
     776:	87 95       	ror	r24
     778:	6a 95       	dec	r22
     77a:	e2 f7       	brpl	.-8      	; 0x774 <DIO_ReadDDRPinValue+0xe4>
     77c:	80 fd       	sbrc	r24, 0
     77e:	02 c0       	rjmp	.+4      	; 0x784 <DIO_ReadDDRPinValue+0xf4>
						{
							*P_u8DDRPinValue = DIO_PIN_INPUT;
     780:	fa 01       	movw	r30, r20
     782:	10 82       	st	Z, r1
     784:	08 95       	ret

00000786 <GI_Enable>:
 * @brief: Function to enable the global interrupt
 * 
 */
void GI_Enable(void)
{
    SET_BIT(SREG, 7);
     786:	8f b7       	in	r24, 0x3f	; 63
     788:	80 68       	ori	r24, 0x80	; 128
     78a:	8f bf       	out	0x3f, r24	; 63
     78c:	08 95       	ret

0000078e <HC05_WelcomeMessage>:
 * @brief: Function to send a welcome message to the user/admin
 * 
 */
void HC05_WelcomeMessage(void)
{
    UART_TxString("Hello! Welcome to Smart Home\n");
     78e:	81 e7       	ldi	r24, 0x71	; 113
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("Please enter whether you are admin or a user\n");
     796:	8f e8       	ldi	r24, 0x8F	; 143
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("1:Admin    2: User\n");
     79e:	8d eb       	ldi	r24, 0xBD	; 189
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    glbl_u8CurrentScreen = HC05_WELCOME_SCREEN;
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     7ac:	08 95       	ret

000007ae <HC05_AdminUsernamePasswordSaver>:
/**
 * @brief: Function to set the admin username and password for the first time
 * 
 */
void HC05_AdminUsernamePasswordSaver(void)
{
     7ae:	cf 93       	push	r28
    /*Write Admin UserName "2" to the specified Admin EEPROM Memory address "50"*/
    Internal_EEPROM_WriteByte(HC05_ADMIN_MEM_ADDRESS, HC05_ADMIN_USERNAME);
     7b0:	62 e3       	ldi	r22, 0x32	; 50
     7b2:	82 e3       	ldi	r24, 0x32	; 50
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>

    u8 Loc_u8Index = 0; 
	u16 Loc_u8Address = 0;

    /*Save Admin Password in the EEPROM "123" */
    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     7ba:	c0 e0       	ldi	r28, 0x00	; 0
     7bc:	0a c0       	rjmp	.+20     	; 0x7d2 <HC05_AdminUsernamePasswordSaver+0x24>
    {
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + Loc_u8Index + 1;
     7be:	8c 2f       	mov	r24, r28
     7c0:	90 e0       	ldi	r25, 0x00	; 0
        Internal_EEPROM_WriteByte(Loc_u8Address, HC05_ADMIN_PASSWRD[Loc_u8Index]);
     7c2:	fc 01       	movw	r30, r24
     7c4:	e6 5a       	subi	r30, 0xA6	; 166
     7c6:	f9 4f       	sbci	r31, 0xF9	; 249
     7c8:	60 81       	ld	r22, Z
     7ca:	c3 96       	adiw	r24, 0x33	; 51
     7cc:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>

    u8 Loc_u8Index = 0; 
	u16 Loc_u8Address = 0;

    /*Save Admin Password in the EEPROM "123" */
    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     7d0:	cf 5f       	subi	r28, 0xFF	; 255
     7d2:	c3 30       	cpi	r28, 0x03	; 3
     7d4:	a0 f3       	brcs	.-24     	; 0x7be <HC05_AdminUsernamePasswordSaver+0x10>
    {
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + Loc_u8Index + 1;
        Internal_EEPROM_WriteByte(Loc_u8Address, HC05_ADMIN_PASSWRD[Loc_u8Index]);
    }
    /*Set number of users to be 1 and save it in EEPROM*/
	Internal_EEPROM_WriteByte(HC05_NO_USERS_MEM_ADDRESS, 1);
     7d6:	61 e0       	ldi	r22, 0x01	; 1
     7d8:	8a e0       	ldi	r24, 0x0A	; 10
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>

    /*We save this status in EEPROM to show that the Admin username and password is successfully*/
    /*Saved in EEPROM*/
	Internal_EEPROM_WriteByte(HC05_ADMIN_SAVED_STATUS_MEM_ADDRESS, 1);
     7e0:	61 e0       	ldi	r22, 0x01	; 1
     7e2:	80 e5       	ldi	r24, 0x50	; 80
     7e4:	90 e0       	ldi	r25, 0x00	; 0
     7e6:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>
}
     7ea:	cf 91       	pop	r28
     7ec:	08 95       	ret

000007ee <HC05_UsernamePasswordCheck>:
 * @brief: Function to check if the password is correct or not
 * 
 * @return u8: The result of the check
 */
u8 HC05_UsernamePasswordCheck(void)
{
     7ee:	df 92       	push	r13
     7f0:	ef 92       	push	r14
     7f2:	ff 92       	push	r15
     7f4:	0f 93       	push	r16
     7f6:	1f 93       	push	r17
     7f8:	cf 93       	push	r28
     7fa:	df 93       	push	r29
     7fc:	00 d0       	rcall	.+0      	; 0x7fe <HC05_UsernamePasswordCheck+0x10>
     7fe:	1f 92       	push	r1
     800:	cd b7       	in	r28, 0x3d	; 61
     802:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8Index = 0;
    u8 Loc_u8Username = 0; 
     804:	19 82       	std	Y+1, r1	; 0x01
    u8 Loc_u8Pass = 0;
     806:	1a 82       	std	Y+2, r1	; 0x02

    if(glbl_u8AdminMode == 1) //Check if the User chose admin mode
     808:	00 91 13 08 	lds	r16, 0x0813	; 0x800813 <glbl_u8AdminMode>
     80c:	01 30       	cpi	r16, 0x01	; 1
     80e:	79 f5       	brne	.+94     	; 0x86e <__stack+0xf>
    {
        /*Read Admin Username from EEPROM and save it in this variable*/
        Internal_EEPROM_ReadByte(HC05_ADMIN_MEM_ADDRESS, &Loc_u8Username);
     810:	be 01       	movw	r22, r28
     812:	6f 5f       	subi	r22, 0xFF	; 255
     814:	7f 4f       	sbci	r23, 0xFF	; 255
     816:	82 e3       	ldi	r24, 0x32	; 50
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>

        /*Check if the username read from memory equals the username entered by user/admin*/
        if(glbl_u8AdminUserUsername[0] == Loc_u8Username)
     81e:	90 91 09 08 	lds	r25, 0x0809	; 0x800809 <glbl_u8AdminUserUsername>
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	98 13       	cpse	r25, r24
     826:	1d c0       	rjmp	.+58     	; 0x862 <__stack+0x3>
     828:	18 c0       	rjmp	.+48     	; 0x85a <__DATA_REGION_LENGTH__+0x5a>
        {
            /*Username is correct*/
            for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
            {
                /*Read Admin Password from memory to check if the entered password is correct or not*/
                Internal_EEPROM_ReadByte((HC05_ADMIN_MEM_ADDRESS + Loc_u8Index + 1), &Loc_u8Pass);
     82a:	e1 2e       	mov	r14, r17
     82c:	f1 2c       	mov	r15, r1
     82e:	be 01       	movw	r22, r28
     830:	6e 5f       	subi	r22, 0xFE	; 254
     832:	7f 4f       	sbci	r23, 0xFF	; 255
     834:	c7 01       	movw	r24, r14
     836:	c3 96       	adiw	r24, 0x33	; 51
     838:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>

                if(Loc_u8Pass != glbl_u8AdminUserPassword[Loc_u8Index])
     83c:	f7 01       	movw	r30, r14
     83e:	ec 5f       	subi	r30, 0xFC	; 252
     840:	f7 4f       	sbci	r31, 0xF7	; 247
     842:	90 81       	ld	r25, Z
     844:	8a 81       	ldd	r24, Y+2	; 0x02
     846:	98 17       	cp	r25, r24
     848:	31 f0       	breq	.+12     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
                {
                    /*Means that the entered password is not correct*/
                    UART_TxString("Sorry, Invalid Password\n");
     84a:	81 ed       	ldi	r24, 0xD1	; 209
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    return HC05_USERNAME_PASSOWRD_INCORRECT;
     852:	02 e0       	ldi	r16, 0x02	; 2
     854:	65 c0       	rjmp	.+202    	; 0x920 <__stack+0xc1>

        /*Check if the username read from memory equals the username entered by user/admin*/
        if(glbl_u8AdminUserUsername[0] == Loc_u8Username)
        {
            /*Username is correct*/
            for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     856:	1f 5f       	subi	r17, 0xFF	; 255
     858:	01 c0       	rjmp	.+2      	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
     85a:	10 e0       	ldi	r17, 0x00	; 0
     85c:	13 30       	cpi	r17, 0x03	; 3
     85e:	28 f3       	brcs	.-54     	; 0x82a <__DATA_REGION_LENGTH__+0x2a>
     860:	5f c0       	rjmp	.+190    	; 0x920 <__stack+0xc1>
            return HC05_USERNAME_PASSOWRD_CORRECT;
        }
        else
        {
            /*Username is incorrect*/
            UART_TxString("Sorry, Invalid username\n");
     862:	8a ee       	ldi	r24, 0xEA	; 234
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
            return HC05_USERNAME_PASSOWRD_INCORRECT;
     86a:	02 e0       	ldi	r16, 0x02	; 2
     86c:	59 c0       	rjmp	.+178    	; 0x920 <__stack+0xc1>
        }
    }
    else if(glbl_u8UserMode == 1) //User has chosen user mode
     86e:	00 91 12 08 	lds	r16, 0x0812	; 0x800812 <glbl_u8UserMode>
     872:	01 30       	cpi	r16, 0x01	; 1
     874:	09 f0       	breq	.+2      	; 0x878 <__stack+0x19>
     876:	4f c0       	rjmp	.+158    	; 0x916 <__stack+0xb7>
    {
        u8 Loc_u8NoOfUsers = 0;
     878:	1b 82       	std	Y+3, r1	; 0x03
        u8 Loc_u8CorrectUserAddress = 0;

        /*Save the current number of users/admin*/
        Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     87a:	be 01       	movw	r22, r28
     87c:	6d 5f       	subi	r22, 0xFD	; 253
     87e:	7f 4f       	sbci	r23, 0xFF	; 255
     880:	8a e0       	ldi	r24, 0x0A	; 10
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
        }
    }
    else if(glbl_u8UserMode == 1) //User has chosen user mode
    {
        u8 Loc_u8NoOfUsers = 0;
        u8 Loc_u8CorrectUserAddress = 0;
     888:	d1 2c       	mov	r13, r1

        /*Save the current number of users/admin*/
        Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);

        for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     88a:	11 e0       	ldi	r17, 0x01	; 1
     88c:	1a c0       	rjmp	.+52     	; 0x8c2 <__stack+0x63>
        {
            /*Read the existing Usernames of users saved and check if the entered username matches one of them*/
            /*or not*/
            Internal_EEPROM_ReadByte((HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index)) , &Loc_u8Username);
     88e:	81 2f       	mov	r24, r17
     890:	90 e0       	ldi	r25, 0x00	; 0
     892:	88 0f       	add	r24, r24
     894:	99 1f       	adc	r25, r25
     896:	88 0f       	add	r24, r24
     898:	99 1f       	adc	r25, r25
     89a:	be 01       	movw	r22, r28
     89c:	6f 5f       	subi	r22, 0xFF	; 255
     89e:	7f 4f       	sbci	r23, 0xFF	; 255
     8a0:	c2 96       	adiw	r24, 0x32	; 50
     8a2:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
            if(glbl_u8AdminUserUsername[0] == Loc_u8Username)
     8a6:	90 91 09 08 	lds	r25, 0x0809	; 0x800809 <glbl_u8AdminUserUsername>
     8aa:	89 81       	ldd	r24, Y+1	; 0x01
     8ac:	98 13       	cpse	r25, r24
     8ae:	08 c0       	rjmp	.+16     	; 0x8c0 <__stack+0x61>
            {
                /*means that the username exists in EEPROM*/
                /*We save this username address in order to check its password*/
                Loc_u8CorrectUserAddress = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index);
     8b0:	81 2f       	mov	r24, r17
     8b2:	88 0f       	add	r24, r24
     8b4:	88 0f       	add	r24, r24
     8b6:	0f 2e       	mov	r0, r31
     8b8:	f2 e3       	ldi	r31, 0x32	; 50
     8ba:	df 2e       	mov	r13, r31
     8bc:	f0 2d       	mov	r31, r0
     8be:	d8 0e       	add	r13, r24
        u8 Loc_u8CorrectUserAddress = 0;

        /*Save the current number of users/admin*/
        Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);

        for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     8c0:	1f 5f       	subi	r17, 0xFF	; 255
     8c2:	8b 81       	ldd	r24, Y+3	; 0x03
     8c4:	18 17       	cp	r17, r24
     8c6:	18 f3       	brcs	.-58     	; 0x88e <__stack+0x2f>
                /*means that the username exists in EEPROM*/
                /*We save this username address in order to check its password*/
                Loc_u8CorrectUserAddress = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index);
            }
        }
        if(Loc_u8CorrectUserAddress == 0)
     8c8:	d1 10       	cpse	r13, r1
     8ca:	21 c0       	rjmp	.+66     	; 0x90e <__stack+0xaf>
        {
            /*Means that the username does not exist*/
            UART_TxString("Sorry, Invalid username\n");
     8cc:	8a ee       	ldi	r24, 0xEA	; 234
     8ce:	90 e0       	ldi	r25, 0x00	; 0
     8d0:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
            return HC05_USERNAME_PASSOWRD_INCORRECT;
     8d4:	02 e0       	ldi	r16, 0x02	; 2
     8d6:	24 c0       	rjmp	.+72     	; 0x920 <__stack+0xc1>

        for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
        {
            /*Read the user ,whose username matches the entered username, password and check if it matches the*/
            /*entered password*/
            Internal_EEPROM_ReadByte((Loc_u8CorrectUserAddress + 1 + Loc_u8Index),&Loc_u8Pass);
     8d8:	8d 2d       	mov	r24, r13
     8da:	90 e0       	ldi	r25, 0x00	; 0
     8dc:	01 96       	adiw	r24, 0x01	; 1
     8de:	e1 2e       	mov	r14, r17
     8e0:	f1 2c       	mov	r15, r1
     8e2:	be 01       	movw	r22, r28
     8e4:	6e 5f       	subi	r22, 0xFE	; 254
     8e6:	7f 4f       	sbci	r23, 0xFF	; 255
     8e8:	8e 0d       	add	r24, r14
     8ea:	9f 1d       	adc	r25, r15
     8ec:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
            if(Loc_u8Pass != glbl_u8AdminUserPassword[Loc_u8Index])
     8f0:	f7 01       	movw	r30, r14
     8f2:	ec 5f       	subi	r30, 0xFC	; 252
     8f4:	f7 4f       	sbci	r31, 0xF7	; 247
     8f6:	90 81       	ld	r25, Z
     8f8:	8a 81       	ldd	r24, Y+2	; 0x02
     8fa:	98 17       	cp	r25, r24
     8fc:	31 f0       	breq	.+12     	; 0x90a <__stack+0xab>
            {
                /*Means that the password entered is incorrect*/
                UART_TxString("Sorry, Invalid password\n");
     8fe:	83 e0       	ldi	r24, 0x03	; 3
     900:	91 e0       	ldi	r25, 0x01	; 1
     902:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                return HC05_USERNAME_PASSOWRD_INCORRECT;
     906:	02 e0       	ldi	r16, 0x02	; 2
     908:	0b c0       	rjmp	.+22     	; 0x920 <__stack+0xc1>
            /*Means that the username does not exist*/
            UART_TxString("Sorry, Invalid username\n");
            return HC05_USERNAME_PASSOWRD_INCORRECT;
        }

        for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     90a:	1f 5f       	subi	r17, 0xFF	; 255
     90c:	01 c0       	rjmp	.+2      	; 0x910 <__stack+0xb1>
     90e:	10 e0       	ldi	r17, 0x00	; 0
     910:	13 30       	cpi	r17, 0x03	; 3
     912:	10 f3       	brcs	.-60     	; 0x8d8 <__stack+0x79>
     914:	05 c0       	rjmp	.+10     	; 0x920 <__stack+0xc1>
        return HC05_USERNAME_PASSOWRD_CORRECT;
    }
    else
    {
        /*Means that the user input is wrong*/
        UART_TxString("Sorry, Wrong Input\n");
     916:	8c e1       	ldi	r24, 0x1C	; 28
     918:	91 e0       	ldi	r25, 0x01	; 1
     91a:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
        return HC05_USERNAME_PASSOWRD_INCORRECT;
     91e:	02 e0       	ldi	r16, 0x02	; 2
    }
}
     920:	80 2f       	mov	r24, r16
     922:	0f 90       	pop	r0
     924:	0f 90       	pop	r0
     926:	0f 90       	pop	r0
     928:	df 91       	pop	r29
     92a:	cf 91       	pop	r28
     92c:	1f 91       	pop	r17
     92e:	0f 91       	pop	r16
     930:	ff 90       	pop	r15
     932:	ef 90       	pop	r14
     934:	df 90       	pop	r13
     936:	08 95       	ret

00000938 <HC05_AdminLoginCheck>:
 */
u8 HC05_AdminLoginCheck(void)
{
    /*Return the status of admin mode to check if admin is currently using the system or not*/
    return glbl_u8AdminMode;
}
     938:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <glbl_u8AdminMode>
     93c:	08 95       	ret

0000093e <HC05_AdminUserChoiceList>:
 * @brief: Function to show the admin/user choice list after logging in
 * 
 */
void HC05_AdminUserChoiceList(void)
{ /*AC Automatic*/
    UART_TxString("Welcome\n");
     93e:	80 e3       	ldi	r24, 0x30	; 48
     940:	91 e0       	ldi	r25, 0x01	; 1
     942:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("Choose the service you wish to do\n");
     946:	89 e3       	ldi	r24, 0x39	; 57
     948:	91 e0       	ldi	r25, 0x01	; 1
     94a:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("1: Door\n");
     94e:	8c e5       	ldi	r24, 0x5C	; 92
     950:	91 e0       	ldi	r25, 0x01	; 1
     952:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("2: LEDs\n");
     956:	85 e6       	ldi	r24, 0x65	; 101
     958:	91 e0       	ldi	r25, 0x01	; 1
     95a:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
	UART_TxString("3: Add User\n");
     95e:	8e e6       	ldi	r24, 0x6E	; 110
     960:	91 e0       	ldi	r25, 0x01	; 1
     962:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
	UART_TxString("4: Delete User\n");
     966:	8b e7       	ldi	r24, 0x7B	; 123
     968:	91 e0       	ldi	r25, 0x01	; 1
     96a:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("5: Log Out\n");
     96e:	8b e8       	ldi	r24, 0x8B	; 139
     970:	91 e0       	ldi	r25, 0x01	; 1
     972:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
     976:	08 95       	ret

00000978 <HC05_AdminUserLEDChoice>:
 * @brief: Function to show the admin/user LED Choice list
 * 
 */
void HC05_AdminUserLEDChoice(void)
{
    UART_TxString("Please select the LED you wish to control\n");
     978:	87 e9       	ldi	r24, 0x97	; 151
     97a:	91 e0       	ldi	r25, 0x01	; 1
     97c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("1: LED 1\n");
     980:	82 ec       	ldi	r24, 0xC2	; 194
     982:	91 e0       	ldi	r25, 0x01	; 1
     984:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("2: LED 2\n");
     988:	8c ec       	ldi	r24, 0xCC	; 204
     98a:	91 e0       	ldi	r25, 0x01	; 1
     98c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("3: LED 3\n");
     990:	86 ed       	ldi	r24, 0xD6	; 214
     992:	91 e0       	ldi	r25, 0x01	; 1
     994:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("4: LED 4\n");
     998:	80 ee       	ldi	r24, 0xE0	; 224
     99a:	91 e0       	ldi	r25, 0x01	; 1
     99c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("5: LED 5\n");
     9a0:	8a ee       	ldi	r24, 0xEA	; 234
     9a2:	91 e0       	ldi	r25, 0x01	; 1
     9a4:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    UART_TxString("6: Dimming LED\n");
     9a8:	84 ef       	ldi	r24, 0xF4	; 244
     9aa:	91 e0       	ldi	r25, 0x01	; 1
     9ac:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
     9b0:	08 95       	ret

000009b2 <HC05_UserNamePasswordExist>:
 * @brief: Function to check if the username entered exists in EEPROM or not
 * 
 * @return u8 
 */
u8 HC05_UserNamePasswordExist(void)
{
     9b2:	1f 93       	push	r17
     9b4:	cf 93       	push	r28
     9b6:	df 93       	push	r29
     9b8:	00 d0       	rcall	.+0      	; 0x9ba <HC05_UserNamePasswordExist+0x8>
     9ba:	cd b7       	in	r28, 0x3d	; 61
     9bc:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8NoOfUsers = 0;
     9be:	19 82       	std	Y+1, r1	; 0x01
    /*Read the current number of users/admin in the system*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     9c0:	be 01       	movw	r22, r28
     9c2:	6f 5f       	subi	r22, 0xFF	; 255
     9c4:	7f 4f       	sbci	r23, 0xFF	; 255
     9c6:	8a e0       	ldi	r24, 0x0A	; 10
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>

    u8 Loc_u8Index = 0;
    u8 Loc_u8Username = 0;
     9ce:	1a 82       	std	Y+2, r1	; 0x02
    
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     9d0:	11 e0       	ldi	r17, 0x01	; 1
     9d2:	18 c0       	rjmp	.+48     	; 0xa04 <HC05_UserNamePasswordExist+0x52>
    {
        /*Read the users' usernames currently in EEPROM and check if entered username matches one of them*/
        Internal_EEPROM_ReadByte((HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index)) , &Loc_u8Username);
     9d4:	81 2f       	mov	r24, r17
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	88 0f       	add	r24, r24
     9da:	99 1f       	adc	r25, r25
     9dc:	88 0f       	add	r24, r24
     9de:	99 1f       	adc	r25, r25
     9e0:	be 01       	movw	r22, r28
     9e2:	6e 5f       	subi	r22, 0xFE	; 254
     9e4:	7f 4f       	sbci	r23, 0xFF	; 255
     9e6:	c2 96       	adiw	r24, 0x32	; 50
     9e8:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
        if(glbl_u8AdminUserUsername[0] == Loc_u8Username)
     9ec:	90 91 09 08 	lds	r25, 0x0809	; 0x800809 <glbl_u8AdminUserUsername>
     9f0:	8a 81       	ldd	r24, Y+2	; 0x02
     9f2:	98 13       	cpse	r25, r24
     9f4:	06 c0       	rjmp	.+12     	; 0xa02 <HC05_UserNamePasswordExist+0x50>
        {
            /*User entered already exists in EEPROM*/
            UART_TxString("Sorry, User Already Exists\n");
     9f6:	84 e0       	ldi	r24, 0x04	; 4
     9f8:	92 e0       	ldi	r25, 0x02	; 2
     9fa:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
            return HC05_USER_EXIST;
     9fe:	81 e0       	ldi	r24, 0x01	; 1
     a00:	05 c0       	rjmp	.+10     	; 0xa0c <HC05_UserNamePasswordExist+0x5a>
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);

    u8 Loc_u8Index = 0;
    u8 Loc_u8Username = 0;
    
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     a02:	1f 5f       	subi	r17, 0xFF	; 255
     a04:	89 81       	ldd	r24, Y+1	; 0x01
     a06:	18 17       	cp	r17, r24
     a08:	28 f3       	brcs	.-54     	; 0x9d4 <HC05_UserNamePasswordExist+0x22>
            UART_TxString("Sorry, User Already Exists\n");
            return HC05_USER_EXIST;
        }
    }
    /*Means that the username entered is not found in EEPROM*/
    return HC05_USER_NOT_EXIST;
     a0a:	82 e0       	ldi	r24, 0x02	; 2
}
     a0c:	0f 90       	pop	r0
     a0e:	0f 90       	pop	r0
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	1f 91       	pop	r17
     a16:	08 95       	ret

00000a18 <HC05_AddNewUser>:
/**
 * @brief: Function to add new user to EEPROM
 * 
 */
void HC05_AddNewUser(void)
{
     a18:	0f 93       	push	r16
     a1a:	1f 93       	push	r17
     a1c:	cf 93       	push	r28
     a1e:	df 93       	push	r29
     a20:	1f 92       	push	r1
     a22:	cd b7       	in	r28, 0x3d	; 61
     a24:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8NoOfUsers = 0;
     a26:	19 82       	std	Y+1, r1	; 0x01
    /*Read number of users/admin from the EEPROM*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     a28:	be 01       	movw	r22, r28
     a2a:	6f 5f       	subi	r22, 0xFF	; 255
     a2c:	7f 4f       	sbci	r23, 0xFF	; 255
     a2e:	8a e0       	ldi	r24, 0x0A	; 10
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>

    /*Set the address to be the last address not accessed by system*/
    /*We add the user at the end*/
    u8 Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8NoOfUsers);
     a36:	09 81       	ldd	r16, Y+1	; 0x01
     a38:	00 0f       	add	r16, r16
     a3a:	00 0f       	add	r16, r16
     a3c:	82 e3       	ldi	r24, 0x32	; 50
     a3e:	80 0f       	add	r24, r16
    
    /*we enter the new username in the empty place in EEPROM*/
    Internal_EEPROM_WriteByte((Loc_u8Address), glbl_u8AdminUserUsername[0]);
     a40:	60 91 09 08 	lds	r22, 0x0809	; 0x800809 <glbl_u8AdminUserUsername>
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>
    
    u8 Loc_u8Index = 0;

    /*We increment the address so that it points to the new user password address*/
    Loc_u8Address ++;
     a4a:	0d 5c       	subi	r16, 0xCD	; 205

    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     a4c:	10 e0       	ldi	r17, 0x00	; 0
     a4e:	0b c0       	rjmp	.+22     	; 0xa66 <HC05_AddNewUser+0x4e>
    {
        /*We enter the new user password in memory*/
        Internal_EEPROM_WriteByte((Loc_u8Address + Loc_u8Index), glbl_u8AdminUserPassword[Loc_u8Index]);
     a50:	81 2f       	mov	r24, r17
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	fc 01       	movw	r30, r24
     a56:	ec 5f       	subi	r30, 0xFC	; 252
     a58:	f7 4f       	sbci	r31, 0xF7	; 247
     a5a:	60 81       	ld	r22, Z
     a5c:	80 0f       	add	r24, r16
     a5e:	91 1d       	adc	r25, r1
     a60:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>
    u8 Loc_u8Index = 0;

    /*We increment the address so that it points to the new user password address*/
    Loc_u8Address ++;

    for(Loc_u8Index = 0; Loc_u8Index < HC05_PASSWD_SIZE; Loc_u8Index++)
     a64:	1f 5f       	subi	r17, 0xFF	; 255
     a66:	13 30       	cpi	r17, 0x03	; 3
     a68:	98 f3       	brcs	.-26     	; 0xa50 <HC05_AddNewUser+0x38>
        /*We enter the new user password in memory*/
        Internal_EEPROM_WriteByte((Loc_u8Address + Loc_u8Index), glbl_u8AdminUserPassword[Loc_u8Index]);
    }

    /*Increase the number of users by one and saving the new number of users*/
    Loc_u8NoOfUsers++;
     a6a:	69 81       	ldd	r22, Y+1	; 0x01
     a6c:	6f 5f       	subi	r22, 0xFF	; 255
     a6e:	69 83       	std	Y+1, r22	; 0x01
    Internal_EEPROM_WriteByte(HC05_NO_USERS_MEM_ADDRESS, Loc_u8NoOfUsers);
     a70:	8a e0       	ldi	r24, 0x0A	; 10
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>
    UART_TxString("User Successfully added\n");
     a78:	80 e2       	ldi	r24, 0x20	; 32
     a7a:	92 e0       	ldi	r25, 0x02	; 2
     a7c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
}
     a80:	0f 90       	pop	r0
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	1f 91       	pop	r17
     a88:	0f 91       	pop	r16
     a8a:	08 95       	ret

00000a8c <HC05_DeleteUser>:
/**
 * @brief: Function to delete a user from the EEPROM
 * 
 */
void HC05_DeleteUser(void)
{
     a8c:	ef 92       	push	r14
     a8e:	ff 92       	push	r15
     a90:	0f 93       	push	r16
     a92:	1f 93       	push	r17
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	00 d0       	rcall	.+0      	; 0xa9a <HC05_DeleteUser+0xe>
     a9a:	1f 92       	push	r1
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8NoOfUsers = 0;
     aa0:	19 82       	std	Y+1, r1	; 0x01
    u8 Loc_u8Index = 0;
    u8 Loc_u8UserIndex = 0;
    u8 Loc_u8UserName = 0;
     aa2:	1a 82       	std	Y+2, r1	; 0x02
    u8 Loc_u8Address = 0;

    /*Read the number of users/admin from EEPROM*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
     aa4:	be 01       	movw	r22, r28
     aa6:	6f 5f       	subi	r22, 0xFF	; 255
     aa8:	7f 4f       	sbci	r23, 0xFF	; 255
     aaa:	8a e0       	ldi	r24, 0x0A	; 10
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
    
    /*Check to see if the username entered exists or not*/
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     ab2:	11 e0       	ldi	r17, 0x01	; 1
     ab4:	10 c0       	rjmp	.+32     	; 0xad6 <HC05_DeleteUser+0x4a>
    {
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8Index);
     ab6:	81 2f       	mov	r24, r17
     ab8:	88 0f       	add	r24, r24
     aba:	88 0f       	add	r24, r24
     abc:	8e 5c       	subi	r24, 0xCE	; 206
        Internal_EEPROM_ReadByte(Loc_u8Address, &Loc_u8UserName);
     abe:	be 01       	movw	r22, r28
     ac0:	6e 5f       	subi	r22, 0xFE	; 254
     ac2:	7f 4f       	sbci	r23, 0xFF	; 255
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
        if(Loc_u8UserName == glbl_u8AdminUserUsername[0])
     aca:	90 91 09 08 	lds	r25, 0x0809	; 0x800809 <glbl_u8AdminUserUsername>
     ace:	8a 81       	ldd	r24, Y+2	; 0x02
     ad0:	98 17       	cp	r25, r24
     ad2:	29 f0       	breq	.+10     	; 0xade <HC05_DeleteUser+0x52>

    /*Read the number of users/admin from EEPROM*/
    Internal_EEPROM_ReadByte(HC05_NO_USERS_MEM_ADDRESS, &Loc_u8NoOfUsers);
    
    /*Check to see if the username entered exists or not*/
    for(Loc_u8Index = 1; Loc_u8Index < Loc_u8NoOfUsers; Loc_u8Index++)
     ad4:	1f 5f       	subi	r17, 0xFF	; 255
     ad6:	89 81       	ldd	r24, Y+1	; 0x01
     ad8:	18 17       	cp	r17, r24
     ada:	68 f3       	brcs	.-38     	; 0xab6 <HC05_DeleteUser+0x2a>
 */
void HC05_DeleteUser(void)
{
    u8 Loc_u8NoOfUsers = 0;
    u8 Loc_u8Index = 0;
    u8 Loc_u8UserIndex = 0;
     adc:	10 e0       	ldi	r17, 0x00	; 0
            /*We take the user index and save it to be used in the delete operation*/
            Loc_u8UserIndex = Loc_u8Index; 
            break;
        }
    }
    if(Loc_u8UserIndex != 0)
     ade:	11 23       	and	r17, r17
     ae0:	29 f1       	breq	.+74     	; 0xb2c <HC05_DeleteUser+0xa0>
    {
        /*User is found in EEPROM*/
        u8 Loc_u8SwapVariable = 0;
     ae2:	1b 82       	std	Y+3, r1	; 0x03
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8UserIndex); //Address of user to be deleted
     ae4:	01 2f       	mov	r16, r17
     ae6:	00 0f       	add	r16, r16
     ae8:	00 0f       	add	r16, r16
     aea:	0e 5c       	subi	r16, 0xCE	; 206

        /*Here, we don't literally delete the user from memory, we just overwrite on it with the next in line user's 
        data and we repeat that until all the data are in line and the user to be deleted data is removed*/ 
        for(Loc_u8Index = Loc_u8UserIndex; Loc_u8Index < (Loc_u8NoOfUsers * 4); Loc_u8Index++)
     aec:	0f c0       	rjmp	.+30     	; 0xb0c <HC05_DeleteUser+0x80>
        {
            /*We here get the data from the address + 4 'user size + password size'  and put it in the address*/
            Internal_EEPROM_ReadByte((Loc_u8Address + 4), &Loc_u8SwapVariable);
     aee:	e0 2e       	mov	r14, r16
     af0:	f1 2c       	mov	r15, r1
     af2:	be 01       	movw	r22, r28
     af4:	6d 5f       	subi	r22, 0xFD	; 253
     af6:	7f 4f       	sbci	r23, 0xFF	; 255
     af8:	c7 01       	movw	r24, r14
     afa:	04 96       	adiw	r24, 0x04	; 4
     afc:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
            Internal_EEPROM_WriteByte(Loc_u8Address, Loc_u8SwapVariable);
     b00:	6b 81       	ldd	r22, Y+3	; 0x03
     b02:	c7 01       	movw	r24, r14
     b04:	0e 94 1a 09 	call	0x1234	; 0x1234 <Internal_EEPROM_WriteByte>
            Loc_u8Address++;
     b08:	0f 5f       	subi	r16, 0xFF	; 255
        u8 Loc_u8SwapVariable = 0;
        Loc_u8Address = HC05_ADMIN_MEM_ADDRESS + (4 * Loc_u8UserIndex); //Address of user to be deleted

        /*Here, we don't literally delete the user from memory, we just overwrite on it with the next in line user's 
        data and we repeat that until all the data are in line and the user to be deleted data is removed*/ 
        for(Loc_u8Index = Loc_u8UserIndex; Loc_u8Index < (Loc_u8NoOfUsers * 4); Loc_u8Index++)
     b0a:	1f 5f       	subi	r17, 0xFF	; 255
     b0c:	21 2f       	mov	r18, r17
     b0e:	30 e0       	ldi	r19, 0x00	; 0
     b10:	89 81       	ldd	r24, Y+1	; 0x01
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	88 0f       	add	r24, r24
     b16:	99 1f       	adc	r25, r25
     b18:	88 0f       	add	r24, r24
     b1a:	99 1f       	adc	r25, r25
     b1c:	28 17       	cp	r18, r24
     b1e:	39 07       	cpc	r19, r25
     b20:	34 f3       	brlt	.-52     	; 0xaee <HC05_DeleteUser+0x62>
            /*We here get the data from the address + 4 'user size + password size'  and put it in the address*/
            Internal_EEPROM_ReadByte((Loc_u8Address + 4), &Loc_u8SwapVariable);
            Internal_EEPROM_WriteByte(Loc_u8Address, Loc_u8SwapVariable);
            Loc_u8Address++;
        }
        UART_TxString("User Successfully Deleted\n");
     b22:	89 e3       	ldi	r24, 0x39	; 57
     b24:	92 e0       	ldi	r25, 0x02	; 2
     b26:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
     b2a:	04 c0       	rjmp	.+8      	; 0xb34 <HC05_DeleteUser+0xa8>
    }
    else
    {
        /*User is not found in EEPROM*/
        UART_TxString("Sorry. User Not Found\n");
     b2c:	84 e5       	ldi	r24, 0x54	; 84
     b2e:	92 e0       	ldi	r25, 0x02	; 2
     b30:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    }
}
     b34:	0f 90       	pop	r0
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	1f 91       	pop	r17
     b40:	0f 91       	pop	r16
     b42:	ff 90       	pop	r15
     b44:	ef 90       	pop	r14
     b46:	08 95       	ret

00000b48 <HC05_AdminUserInterface>:
/**
 * @brief: Function to organize the operation of user/admin
 * 
 */
void HC05_AdminUserInterface(void)
{
     b48:	cf 93       	push	r28
    /*Here is the main function of HC05 Bluetooth module. It organizes the operations in the form of states*/
    switch(glbl_u8CurrentScreen)
     b4a:	e0 91 02 08 	lds	r30, 0x0802	; 0x800802 <glbl_u8CurrentScreen>
     b4e:	8e 2f       	mov	r24, r30
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	fc 01       	movw	r30, r24
     b54:	31 97       	sbiw	r30, 0x01	; 1
     b56:	ed 30       	cpi	r30, 0x0D	; 13
     b58:	f1 05       	cpc	r31, r1
     b5a:	08 f0       	brcs	.+2      	; 0xb5e <HC05_AdminUserInterface+0x16>
     b5c:	bb c2       	rjmp	.+1398   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
     b5e:	e6 5d       	subi	r30, 0xD6	; 214
     b60:	ff 4f       	sbci	r31, 0xFF	; 255
     b62:	0c 94 b8 12 	jmp	0x2570	; 0x2570 <__tablejump2__>
    {
        case HC05_WELCOME_SCREEN:
        {
            /*Here, We get the user choice whether it is an admin or a user and save it*/
            UART_RxString(glbl_u8AdminUserChoice);
     b66:	8f e0       	ldi	r24, 0x0F	; 15
     b68:	98 e0       	ldi	r25, 0x08	; 8
     b6a:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>

            /*Then, we check for the user's input*/
			if('1' == glbl_u8AdminUserChoice[0])
     b6e:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
     b72:	81 33       	cpi	r24, 0x31	; 49
     b74:	79 f4       	brne	.+30     	; 0xb94 <HC05_AdminUserInterface+0x4c>
			{
                /*Means that the user has chosen to enter as an admin*/
				glbl_u8AdminMode = ADMIN_MODE_ON;
     b76:	81 e0       	ldi	r24, 0x01	; 1
     b78:	80 93 13 08 	sts	0x0813, r24	; 0x800813 <glbl_u8AdminMode>
				UART_TxString("Hello Admin\n");
     b7c:	8b e6       	ldi	r24, 0x6B	; 107
     b7e:	92 e0       	ldi	r25, 0x02	; 2
     b80:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
				UART_TxString("Please enter your username: \n");
     b84:	88 e7       	ldi	r24, 0x78	; 120
     b86:	92 e0       	ldi	r25, 0x02	; 2
     b88:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>

                /*We here switch the state to be login username screen*/
				glbl_u8CurrentScreen = HC05_LOGIN_USERNAME_SCREEN;
     b8c:	82 e0       	ldi	r24, 0x02	; 2
     b8e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     b92:	a0 c2       	rjmp	.+1344   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
			}
			else if('2' == glbl_u8AdminUserChoice[0])
     b94:	82 33       	cpi	r24, 0x32	; 50
     b96:	79 f4       	brne	.+30     	; 0xbb6 <HC05_AdminUserInterface+0x6e>
			{
                /*Means that the user has chosen to enter as an admin*/
				glbl_u8UserMode = USER_MODE_ON;
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	80 93 12 08 	sts	0x0812, r24	; 0x800812 <glbl_u8UserMode>
				UART_TxString("Hello User\n");
     b9e:	86 e9       	ldi	r24, 0x96	; 150
     ba0:	92 e0       	ldi	r25, 0x02	; 2
     ba2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
				UART_TxString("Please enter your username: \n");
     ba6:	88 e7       	ldi	r24, 0x78	; 120
     ba8:	92 e0       	ldi	r25, 0x02	; 2
     baa:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>

                /*We here switch the state to be login username screen*/
				glbl_u8CurrentScreen = HC05_LOGIN_USERNAME_SCREEN;
     bae:	82 e0       	ldi	r24, 0x02	; 2
     bb0:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     bb4:	8f c2       	rjmp	.+1310   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
			}
			else
			{
                /*User has entered a wrong input*/
                UART_TxString("Sorry, Wrong Input\n");
     bb6:	8c e1       	ldi	r24, 0x1C	; 28
     bb8:	91 e0       	ldi	r25, 0x01	; 1
     bba:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                HC05_WelcomeMessage();
     bbe:	0e 94 c7 03 	call	0x78e	; 0x78e <HC05_WelcomeMessage>
     bc2:	88 c2       	rjmp	.+1296   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
			break;
		}
        case HC05_LOGIN_USERNAME_SCREEN:
        {
            /*Here, we receive the entered login username*/
            UART_RxString(glbl_u8AdminUserUsername);
     bc4:	89 e0       	ldi	r24, 0x09	; 9
     bc6:	98 e0       	ldi	r25, 0x08	; 8
     bc8:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
			UART_TxString("Please enter your password\n");
     bcc:	82 ea       	ldi	r24, 0xA2	; 162
     bce:	92 e0       	ldi	r25, 0x02	; 2
     bd0:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>

            /*Then, we switch the state to be the login password screen*/
            glbl_u8CurrentScreen = HC05_LOGIN_PASSWORD_SCREEN;
     bd4:	83 e0       	ldi	r24, 0x03	; 3
     bd6:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
            break;
     bda:	7c c2       	rjmp	.+1272   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
        }
        case HC05_LOGIN_PASSWORD_SCREEN:
        {
            /*Here, we receive the entered login password*/
            UART_RxString(glbl_u8AdminUserPassword);
     bdc:	84 e0       	ldi	r24, 0x04	; 4
     bde:	98 e0       	ldi	r25, 0x08	; 8
     be0:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>

            /*We check if the entered username and password are correct or not*/
            u8 Loc_u8UserPassCheck = HC05_UsernamePasswordCheck();
     be4:	0e 94 f7 03 	call	0x7ee	; 0x7ee <HC05_UsernamePasswordCheck>

            if(Loc_u8UserPassCheck == HC05_USERNAME_PASSOWRD_CORRECT)
     be8:	81 30       	cpi	r24, 0x01	; 1
     bea:	a9 f4       	brne	.+42     	; 0xc16 <HC05_AdminUserInterface+0xce>
            {
                /*Means that the entered username and password are correct*/
                if(glbl_u8AdminMode == ADMIN_MODE_ON)
     bec:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <glbl_u8AdminMode>
     bf0:	81 30       	cpi	r24, 0x01	; 1
     bf2:	21 f4       	brne	.+8      	; 0xbfc <HC05_AdminUserInterface+0xb4>
                {
                    glbl_u8AdminMode = ADMIN_LOGGED_ON;
     bf4:	87 e0       	ldi	r24, 0x07	; 7
     bf6:	80 93 13 08 	sts	0x0813, r24	; 0x800813 <glbl_u8AdminMode>
     bfa:	07 c0       	rjmp	.+14     	; 0xc0a <HC05_AdminUserInterface+0xc2>
                }
                else if(glbl_u8UserMode == USER_MODE_ON)
     bfc:	80 91 12 08 	lds	r24, 0x0812	; 0x800812 <glbl_u8UserMode>
     c00:	81 30       	cpi	r24, 0x01	; 1
     c02:	19 f4       	brne	.+6      	; 0xc0a <HC05_AdminUserInterface+0xc2>
                {
                    glbl_u8UserMode = USER_LOGGED_ON;
     c04:	87 e0       	ldi	r24, 0x07	; 7
     c06:	80 93 12 08 	sts	0x0812, r24	; 0x800812 <glbl_u8UserMode>
                else
                {
                    /*Do nothing*/
                }
                /*Here, we show the user/admin the list of choices to choose from*/
                HC05_AdminUserChoiceList();
     c0a:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
                /*Then, we switch the state*/
                glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     c0e:	84 e0       	ldi	r24, 0x04	; 4
     c10:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     c14:	0e c0       	rjmp	.+28     	; 0xc32 <HC05_AdminUserInterface+0xea>
			else
			{
                /*Means that the entered username or password or both is incorrect*/
                /*We count the number of failed trials so that if the number of failed trials is 3*/
                /*We fire an alarm and reset the whole operation*/
				glbl_u8UserPasswordWrongCount++;
     c16:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <glbl_u8UserPasswordWrongCount>
     c1a:	8f 5f       	subi	r24, 0xFF	; 255
     c1c:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <glbl_u8UserPasswordWrongCount>
				if (glbl_u8UserPasswordWrongCount != 3)
     c20:	83 30       	cpi	r24, 0x03	; 3
     c22:	21 f0       	breq	.+8      	; 0xc2c <HC05_AdminUserInterface+0xe4>
				{
					UART_TxString("Please enter your username\n");
     c24:	8e eb       	ldi	r24, 0xBE	; 190
     c26:	92 e0       	ldi	r25, 0x02	; 2
     c28:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
				}
                glbl_u8CurrentScreen = HC05_LOGIN_USERNAME_SCREEN;
     c2c:	82 e0       	ldi	r24, 0x02	; 2
     c2e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
			}
			if(glbl_u8UserPasswordWrongCount == 3)
     c32:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <glbl_u8UserPasswordWrongCount>
     c36:	83 30       	cpi	r24, 0x03	; 3
     c38:	09 f0       	breq	.+2      	; 0xc3c <HC05_AdminUserInterface+0xf4>
     c3a:	4c c2       	rjmp	.+1176   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
			{
                /*number of failed trials = 3*/
                /*Fire Alarm*/
				BUZZER_On();
     c3c:	0e 94 88 00 	call	0x110	; 0x110 <BUZZER_On>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c40:	2f ef       	ldi	r18, 0xFF	; 255
     c42:	8b e7       	ldi	r24, 0x7B	; 123
     c44:	92 e9       	ldi	r25, 0x92	; 146
     c46:	21 50       	subi	r18, 0x01	; 1
     c48:	80 40       	sbci	r24, 0x00	; 0
     c4a:	90 40       	sbci	r25, 0x00	; 0
     c4c:	e1 f7       	brne	.-8      	; 0xc46 <HC05_AdminUserInterface+0xfe>
     c4e:	00 c0       	rjmp	.+0      	; 0xc50 <HC05_AdminUserInterface+0x108>
     c50:	00 00       	nop
				_delay_ms(3000);
				BUZZER_Off();
     c52:	0e 94 8e 00 	call	0x11c	; 0x11c <BUZZER_Off>

                /*Reset System ---------------------------------->*/
				HC05_WelcomeMessage();
     c56:	0e 94 c7 03 	call	0x78e	; 0x78e <HC05_WelcomeMessage>
                glbl_u8AdminMode = ADMIN_MODE_OFF;
     c5a:	10 92 13 08 	sts	0x0813, r1	; 0x800813 <glbl_u8AdminMode>
                glbl_u8UserMode = USER_MODE_OFF;
     c5e:	10 92 12 08 	sts	0x0812, r1	; 0x800812 <glbl_u8UserMode>
				glbl_u8UserPasswordWrongCount = 0;
     c62:	10 92 00 08 	sts	0x0800, r1	; 0x800800 <glbl_u8UserPasswordWrongCount>
     c66:	36 c2       	rjmp	.+1132   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            break;
        }
		case HC05_SERVICES_SCREEN:
		{
            /*We receive the user/Admin service choice*/
			UART_RxString(glbl_u8AdminUserChoice);
     c68:	8f e0       	ldi	r24, 0x0F	; 15
     c6a:	98 e0       	ldi	r25, 0x08	; 8
     c6c:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
            
            if('1' == glbl_u8AdminUserChoice[0])
     c70:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
     c74:	81 33       	cpi	r24, 0x31	; 49
     c76:	01 f5       	brne	.+64     	; 0xcb8 <HC05_AdminUserInterface+0x170>
            {
                /*Means the User or admin wants to control door but only admin can control it*/
                if(glbl_u8AdminMode == ADMIN_LOGGED_ON)
     c78:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <glbl_u8AdminMode>
     c7c:	87 30       	cpi	r24, 0x07	; 7
     c7e:	81 f4       	brne	.+32     	; 0xca0 <HC05_AdminUserInterface+0x158>
                {
                    UART_TxString("Please select the type of operation you wish to do:\n");
     c80:	8a ed       	ldi	r24, 0xDA	; 218
     c82:	92 e0       	ldi	r25, 0x02	; 2
     c84:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
					UART_TxString("1: Open Door\n");
     c88:	8f e0       	ldi	r24, 0x0F	; 15
     c8a:	93 e0       	ldi	r25, 0x03	; 3
     c8c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("2: Close Door\n");
     c90:	8d e1       	ldi	r24, 0x1D	; 29
     c92:	93 e0       	ldi	r25, 0x03	; 3
     c94:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    glbl_u8CurrentScreen = HC05_DOOR_CONTROL;
     c98:	88 e0       	ldi	r24, 0x08	; 8
     c9a:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     c9e:	1a c2       	rjmp	.+1076   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if(glbl_u8UserMode == USER_LOGGED_ON)
     ca0:	80 91 12 08 	lds	r24, 0x0812	; 0x800812 <glbl_u8UserMode>
     ca4:	87 30       	cpi	r24, 0x07	; 7
     ca6:	09 f0       	breq	.+2      	; 0xcaa <HC05_AdminUserInterface+0x162>
     ca8:	15 c2       	rjmp	.+1066   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                {
                    UART_TxString("Sorry. Only Admin is allowed to control door\n");
     caa:	8c e2       	ldi	r24, 0x2C	; 44
     cac:	93 e0       	ldi	r25, 0x03	; 3
     cae:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    HC05_AdminUserChoiceList();
     cb2:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
     cb6:	0e c2       	rjmp	.+1052   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                else
                {
                    /*Do nothing*/
                }
            }
            else if('2' == glbl_u8AdminUserChoice[0]) 
     cb8:	82 33       	cpi	r24, 0x32	; 50
     cba:	31 f4       	brne	.+12     	; 0xcc8 <HC05_AdminUserInterface+0x180>
            {
                /*Means that the user/admin wants to control LEDs*/
                HC05_AdminUserLEDChoice();
     cbc:	0e 94 bc 04 	call	0x978	; 0x978 <HC05_AdminUserLEDChoice>
                glbl_u8CurrentScreen = HC05_LEDS_CHOICE;
     cc0:	85 e0       	ldi	r24, 0x05	; 5
     cc2:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     cc6:	06 c2       	rjmp	.+1036   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            }
            else if('3' == glbl_u8AdminUserChoice[0])
     cc8:	83 33       	cpi	r24, 0x33	; 51
     cca:	c1 f4       	brne	.+48     	; 0xcfc <HC05_AdminUserInterface+0x1b4>
            {
                /*Means that the user/admin wants to add a new user*/
                if(glbl_u8AdminMode == ADMIN_LOGGED_ON)
     ccc:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <glbl_u8AdminMode>
     cd0:	87 30       	cpi	r24, 0x07	; 7
     cd2:	41 f4       	brne	.+16     	; 0xce4 <HC05_AdminUserInterface+0x19c>
                {
                    /*Admin wants to add a new user "Allowed"*/
					UART_TxString("Please Enter the new user's ID(max.9)\n");
     cd4:	8a e5       	ldi	r24, 0x5A	; 90
     cd6:	93 e0       	ldi	r25, 0x03	; 3
     cd8:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    glbl_u8CurrentScreen = HC05_ADD_USER_USERNAME_SCREEN;
     cdc:	89 e0       	ldi	r24, 0x09	; 9
     cde:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     ce2:	f8 c1       	rjmp	.+1008   	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if(glbl_u8UserMode == USER_LOGGED_ON)
     ce4:	80 91 12 08 	lds	r24, 0x0812	; 0x800812 <glbl_u8UserMode>
     ce8:	87 30       	cpi	r24, 0x07	; 7
     cea:	09 f0       	breq	.+2      	; 0xcee <HC05_AdminUserInterface+0x1a6>
     cec:	f3 c1       	rjmp	.+998    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                {
                    /*Admin wants to add a new user "NOT Allowed"*/
                    UART_TxString("Sorry. Only Admin is allowed to create new user\n");
     cee:	81 e8       	ldi	r24, 0x81	; 129
     cf0:	93 e0       	ldi	r25, 0x03	; 3
     cf2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    HC05_AdminUserChoiceList();
     cf6:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
     cfa:	ec c1       	rjmp	.+984    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                else
                {
                    /*Do nothing*/
                }
            }
            else if('4' == glbl_u8AdminUserChoice[0])
     cfc:	84 33       	cpi	r24, 0x34	; 52
     cfe:	c1 f4       	brne	.+48     	; 0xd30 <HC05_AdminUserInterface+0x1e8>
            {
                /*Means that the user/admin wants to delete a user*/
                if(glbl_u8AdminMode == ADMIN_LOGGED_ON)
     d00:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <glbl_u8AdminMode>
     d04:	87 30       	cpi	r24, 0x07	; 7
     d06:	41 f4       	brne	.+16     	; 0xd18 <HC05_AdminUserInterface+0x1d0>
                {
                    /*Admin wants to delete a user "Allowed"*/
					UART_TxString("Please enter the user's ID that you wish to delete\n");
     d08:	82 eb       	ldi	r24, 0xB2	; 178
     d0a:	93 e0       	ldi	r25, 0x03	; 3
     d0c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    glbl_u8CurrentScreen = HC05_DELETE_USER_SCREEN;
     d10:	8b e0       	ldi	r24, 0x0B	; 11
     d12:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     d16:	de c1       	rjmp	.+956    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if(glbl_u8UserMode == USER_LOGGED_ON)
     d18:	80 91 12 08 	lds	r24, 0x0812	; 0x800812 <glbl_u8UserMode>
     d1c:	87 30       	cpi	r24, 0x07	; 7
     d1e:	09 f0       	breq	.+2      	; 0xd22 <HC05_AdminUserInterface+0x1da>
     d20:	d9 c1       	rjmp	.+946    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                {
                    /*User wants to delete a  user "NOT Allowed"*/
                    UART_TxString("Sorry. Only Admin is allowed to delete a user\n");
     d22:	86 ee       	ldi	r24, 0xE6	; 230
     d24:	93 e0       	ldi	r25, 0x03	; 3
     d26:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    HC05_AdminUserChoiceList();
     d2a:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
     d2e:	d2 c1       	rjmp	.+932    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                else
                {
                    /*Do nothing*/
                }
            }
            else if('5' == glbl_u8AdminUserChoice[0])
     d30:	85 33       	cpi	r24, 0x35	; 53
     d32:	79 f4       	brne	.+30     	; 0xd52 <HC05_AdminUserInterface+0x20a>
            {
                /*Means that the user/admin wants to log out*/
                glbl_u8AdminMode = ADMIN_MODE_OFF;
     d34:	10 92 13 08 	sts	0x0813, r1	; 0x800813 <glbl_u8AdminMode>
                glbl_u8UserMode = USER_MODE_OFF;
     d38:	10 92 12 08 	sts	0x0812, r1	; 0x800812 <glbl_u8UserMode>
                glbl_u8PreviousScreen = 0;
     d3c:	10 92 03 08 	sts	0x0803, r1	; 0x800803 <glbl_u8PreviousScreen>
                glbl_u8LEDChoice = 0;
     d40:	10 92 01 08 	sts	0x0801, r1	; 0x800801 <glbl_u8LEDChoice>
                UART_TxString("Logged Out Successfully\n");
     d44:	85 e1       	ldi	r24, 0x15	; 21
     d46:	94 e0       	ldi	r25, 0x04	; 4
     d48:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                HC05_WelcomeMessage();
     d4c:	0e 94 c7 03 	call	0x78e	; 0x78e <HC05_WelcomeMessage>
     d50:	c1 c1       	rjmp	.+898    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            }
            else
            {
                UART_TxString("Sorry,Wrong Input\n");
     d52:	8e e2       	ldi	r24, 0x2E	; 46
     d54:	94 e0       	ldi	r25, 0x04	; 4
     d56:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                HC05_AdminUserChoiceList();
     d5a:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
     d5e:	ba c1       	rjmp	.+884    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
		}
        case HC05_DOOR_CONTROL:
        {
            /*The Admin wants to control door*/
            /*We receive the admin response whether he wants to open or close the door*/
            UART_RxString(glbl_u8AdminUserChoice);
     d60:	8f e0       	ldi	r24, 0x0F	; 15
     d62:	98 e0       	ldi	r25, 0x08	; 8
     d64:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
            if('1' == glbl_u8AdminUserChoice[0])
     d68:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
     d6c:	81 33       	cpi	r24, 0x31	; 49
     d6e:	a9 f4       	brne	.+42     	; 0xd9a <HC05_AdminUserInterface+0x252>
            {
                /*Admin wants to open door "Set the angle of the servo motor to be 0 degrees"*/
                TMR_Timer1Stop();
     d70:	0e 94 be 0c 	call	0x197c	; 0x197c <TMR_Timer1Stop>
                SRVM_SetRotationAngle(SRVM_ANGLE_POSITIVE, 0);
     d74:	60 e0       	ldi	r22, 0x00	; 0
     d76:	81 e0       	ldi	r24, 0x01	; 1
     d78:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <SRVM_SetRotationAngle>
                TMR_Timer1Start();
     d7c:	0e 94 b4 0c 	call	0x1968	; 0x1968 <TMR_Timer1Start>
                UART_TxString("Door Opened Successfully\n");
     d80:	81 e4       	ldi	r24, 0x41	; 65
     d82:	94 e0       	ldi	r25, 0x04	; 4
     d84:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                HC05_AdminUserChoiceList();
     d88:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
                glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     d8c:	84 e0       	ldi	r24, 0x04	; 4
     d8e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
                glbl_u8DoorStatus = DOOR_OPENED;
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	80 93 fe 07 	sts	0x07FE, r24	; 0x8007fe <glbl_u8DoorStatus>
     d98:	9d c1       	rjmp	.+826    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            }
            else if('2' == glbl_u8AdminUserChoice[0]) //Close Door
     d9a:	82 33       	cpi	r24, 0x32	; 50
     d9c:	a1 f4       	brne	.+40     	; 0xdc6 <HC05_AdminUserInterface+0x27e>
            {
                /*Admin wants to close door "Set the angle of the servo motor to be -90 degrees"*/
                TMR_Timer1Stop();
     d9e:	0e 94 be 0c 	call	0x197c	; 0x197c <TMR_Timer1Stop>
                SRVM_SetRotationAngle(SRVM_ANGLE_NEGATIVE, 90);
     da2:	6a e5       	ldi	r22, 0x5A	; 90
     da4:	82 e0       	ldi	r24, 0x02	; 2
     da6:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <SRVM_SetRotationAngle>
                TMR_Timer1Start();
     daa:	0e 94 b4 0c 	call	0x1968	; 0x1968 <TMR_Timer1Start>
                UART_TxString("Door Closed Successfully\n");
     dae:	8b e5       	ldi	r24, 0x5B	; 91
     db0:	94 e0       	ldi	r25, 0x04	; 4
     db2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                HC05_AdminUserChoiceList();
     db6:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
                glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     dba:	84 e0       	ldi	r24, 0x04	; 4
     dbc:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
                glbl_u8DoorStatus = DOOR_CLOSED;
     dc0:	10 92 fe 07 	sts	0x07FE, r1	; 0x8007fe <glbl_u8DoorStatus>
     dc4:	87 c1       	rjmp	.+782    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            }
            else
            {
                /*Admin has entered wrong input*/
                UART_TxString("Sorry, Wrong Input\n");
     dc6:	8c e1       	ldi	r24, 0x1C	; 28
     dc8:	91 e0       	ldi	r25, 0x01	; 1
     dca:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("Please select the type of operation you wish to do:\n");
     dce:	8a ed       	ldi	r24, 0xDA	; 218
     dd0:	92 e0       	ldi	r25, 0x02	; 2
     dd2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
				UART_TxString("1: Open Door\n");
     dd6:	8f e0       	ldi	r24, 0x0F	; 15
     dd8:	93 e0       	ldi	r25, 0x03	; 3
     dda:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("2: Close Door\n");
     dde:	8d e1       	ldi	r24, 0x1D	; 29
     de0:	93 e0       	ldi	r25, 0x03	; 3
     de2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
     de6:	76 c1       	rjmp	.+748    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            break;
        }
        case HC05_LEDS_CHOICE:
        {
            /*User/Admin wants to control leds*/
            UART_RxString(glbl_u8AdminUserChoice);
     de8:	8f e0       	ldi	r24, 0x0F	; 15
     dea:	98 e0       	ldi	r25, 0x08	; 8
     dec:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
            if('1' == glbl_u8AdminUserChoice[0])
     df0:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
     df4:	81 33       	cpi	r24, 0x31	; 49
     df6:	79 f4       	brne	.+30     	; 0xe16 <HC05_AdminUserInterface+0x2ce>
            {
                /*User/Admin wants to control LED 1*/
                glbl_u8LEDChoice = HC05_LED_1_CHOICE;
     df8:	81 e0       	ldi	r24, 0x01	; 1
     dfa:	80 93 01 08 	sts	0x0801, r24	; 0x800801 <glbl_u8LEDChoice>
                UART_TxString("1: LED 1 On\n");
     dfe:	85 e7       	ldi	r24, 0x75	; 117
     e00:	94 e0       	ldi	r25, 0x04	; 4
     e02:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("2: LED 1 Off\n");
     e06:	82 e8       	ldi	r24, 0x82	; 130
     e08:	94 e0       	ldi	r25, 0x04	; 4
     e0a:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                glbl_u8CurrentScreen = HC05_LEDS_CONTROL;
     e0e:	86 e0       	ldi	r24, 0x06	; 6
     e10:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     e14:	5f c1       	rjmp	.+702    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            }
            else if('2' == glbl_u8AdminUserChoice[0])
     e16:	82 33       	cpi	r24, 0x32	; 50
     e18:	79 f4       	brne	.+30     	; 0xe38 <HC05_AdminUserInterface+0x2f0>
            {
                /*User/Admin wants to control LED 2*/
                glbl_u8LEDChoice = HC05_LED_2_CHOICE;
     e1a:	82 e0       	ldi	r24, 0x02	; 2
     e1c:	80 93 01 08 	sts	0x0801, r24	; 0x800801 <glbl_u8LEDChoice>
                UART_TxString("1: LED 2 On\n");
     e20:	80 e9       	ldi	r24, 0x90	; 144
     e22:	94 e0       	ldi	r25, 0x04	; 4
     e24:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("2: LED 2 Off\n");
     e28:	8d e9       	ldi	r24, 0x9D	; 157
     e2a:	94 e0       	ldi	r25, 0x04	; 4
     e2c:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                glbl_u8CurrentScreen = HC05_LEDS_CONTROL;
     e30:	86 e0       	ldi	r24, 0x06	; 6
     e32:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     e36:	4e c1       	rjmp	.+668    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            //    glbl_u8LEDChoice = HC05_LED_5_CHOICE;
            //    UART_TxString("1: LED 5 On\n");
            //    UART_TxString("2: LED 5 Off\n");
            //    glbl_u8CurrentScreen = HC05_LEDS_CONTROL;
            //}
            else if('6' == glbl_u8AdminUserChoice[0])
     e38:	86 33       	cpi	r24, 0x36	; 54
     e3a:	11 f5       	brne	.+68     	; 0xe80 <HC05_AdminUserInterface+0x338>
            {
                /*User/Admin wants to control Dimming LED*/
                glbl_u8LEDChoice = HC05_DIMMING_LED_CHOICE;
     e3c:	c6 e0       	ldi	r28, 0x06	; 6
     e3e:	c0 93 01 08 	sts	0x0801, r28	; 0x800801 <glbl_u8LEDChoice>
                UART_TxString("Please Choose the brightness of LED\n");
     e42:	8b ea       	ldi	r24, 0xAB	; 171
     e44:	94 e0       	ldi	r25, 0x04	; 4
     e46:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("1: 0%\n");
     e4a:	80 ed       	ldi	r24, 0xD0	; 208
     e4c:	94 e0       	ldi	r25, 0x04	; 4
     e4e:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("2: 20%\n");
     e52:	87 ed       	ldi	r24, 0xD7	; 215
     e54:	94 e0       	ldi	r25, 0x04	; 4
     e56:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("3: 40%\n");
     e5a:	8f ed       	ldi	r24, 0xDF	; 223
     e5c:	94 e0       	ldi	r25, 0x04	; 4
     e5e:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("4: 60%\n");
     e62:	87 ee       	ldi	r24, 0xE7	; 231
     e64:	94 e0       	ldi	r25, 0x04	; 4
     e66:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("5: 80%\n");
     e6a:	8f ee       	ldi	r24, 0xEF	; 239
     e6c:	94 e0       	ldi	r25, 0x04	; 4
     e6e:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                UART_TxString("6: 100%\n");
     e72:	87 ef       	ldi	r24, 0xF7	; 247
     e74:	94 e0       	ldi	r25, 0x04	; 4
     e76:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                glbl_u8CurrentScreen = HC05_LEDS_CONTROL;
     e7a:	c0 93 02 08 	sts	0x0802, r28	; 0x800802 <glbl_u8CurrentScreen>
     e7e:	2a c1       	rjmp	.+596    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            }
            else
            {
                /*Admin/User has entered wrong input*/
                UART_TxString("Sorry, Wrong Input\n");
     e80:	8c e1       	ldi	r24, 0x1C	; 28
     e82:	91 e0       	ldi	r25, 0x01	; 1
     e84:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                HC05_AdminUserLEDChoice();
     e88:	0e 94 bc 04 	call	0x978	; 0x978 <HC05_AdminUserLEDChoice>
     e8c:	23 c1       	rjmp	.+582    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            }
            break;
        }
        case HC05_LEDS_CONTROL:
        {
            UART_RxString(glbl_u8AdminUserChoice);
     e8e:	8f e0       	ldi	r24, 0x0F	; 15
     e90:	98 e0       	ldi	r25, 0x08	; 8
     e92:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
            if(HC05_LED_1_CHOICE == glbl_u8LEDChoice)
     e96:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <glbl_u8LEDChoice>
     e9a:	81 30       	cpi	r24, 0x01	; 1
     e9c:	79 f5       	brne	.+94     	; 0xefc <HC05_AdminUserInterface+0x3b4>
            {
                if('1' == glbl_u8AdminUserChoice[0])
     e9e:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
     ea2:	81 33       	cpi	r24, 0x31	; 49
     ea4:	71 f4       	brne	.+28     	; 0xec2 <HC05_AdminUserInterface+0x37a>
                {
                    /*Admin/User wants to turn on LED 1*/
                    LED_On(HC05_LED_1_PORT_ID, HC05_LED_1_PIN_ID);
     ea6:	62 e0       	ldi	r22, 0x02	; 2
     ea8:	82 e0       	ldi	r24, 0x02	; 2
     eaa:	0e 94 1e 0b 	call	0x163c	; 0x163c <LED_On>
                    UART_TxString("LED 1 Turned On Successfully\n");
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	95 e0       	ldi	r25, 0x05	; 5
     eb2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    HC05_AdminUserChoiceList();
     eb6:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     eba:	84 e0       	ldi	r24, 0x04	; 4
     ebc:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     ec0:	09 c1       	rjmp	.+530    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if('2' == glbl_u8AdminUserChoice[0])
     ec2:	82 33       	cpi	r24, 0x32	; 50
     ec4:	71 f4       	brne	.+28     	; 0xee2 <HC05_AdminUserInterface+0x39a>
                {
                    /*Admin/User wants to turn off LED 1*/
                    LED_Off(HC05_LED_1_PORT_ID, HC05_LED_1_PIN_ID);
     ec6:	62 e0       	ldi	r22, 0x02	; 2
     ec8:	82 e0       	ldi	r24, 0x02	; 2
     eca:	0e 94 48 0b 	call	0x1690	; 0x1690 <LED_Off>
                    UART_TxString("LED 1 Turned Off Successfully\n");
     ece:	8e e1       	ldi	r24, 0x1E	; 30
     ed0:	95 e0       	ldi	r25, 0x05	; 5
     ed2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    HC05_AdminUserChoiceList();
     ed6:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     eda:	84 e0       	ldi	r24, 0x04	; 4
     edc:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     ee0:	f9 c0       	rjmp	.+498    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else
                {
                    /*Admin/User has entered wrong input*/
                    UART_TxString("Sorry, Wrong Input\n");
     ee2:	8c e1       	ldi	r24, 0x1C	; 28
     ee4:	91 e0       	ldi	r25, 0x01	; 1
     ee6:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("1: LED 1 On\n");
     eea:	85 e7       	ldi	r24, 0x75	; 117
     eec:	94 e0       	ldi	r25, 0x04	; 4
     eee:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("2: LED 1 Off\n");
     ef2:	82 e8       	ldi	r24, 0x82	; 130
     ef4:	94 e0       	ldi	r25, 0x04	; 4
     ef6:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
     efa:	ec c0       	rjmp	.+472    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
            }
            else if(HC05_LED_2_CHOICE == glbl_u8LEDChoice)
     efc:	82 30       	cpi	r24, 0x02	; 2
     efe:	79 f5       	brne	.+94     	; 0xf5e <HC05_AdminUserInterface+0x416>
            {
                if('1' == glbl_u8AdminUserChoice[0])
     f00:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
     f04:	81 33       	cpi	r24, 0x31	; 49
     f06:	71 f4       	brne	.+28     	; 0xf24 <HC05_AdminUserInterface+0x3dc>
                {
                    /*Admin/User wants to turn on LED 2*/
                    LED_On(HC05_LED_2_PORT_ID, HC05_LED_2_PIN_ID);
     f08:	67 e0       	ldi	r22, 0x07	; 7
     f0a:	82 e0       	ldi	r24, 0x02	; 2
     f0c:	0e 94 1e 0b 	call	0x163c	; 0x163c <LED_On>
                    UART_TxString("LED 2 Turned On Successfully\n");
     f10:	8d e3       	ldi	r24, 0x3D	; 61
     f12:	95 e0       	ldi	r25, 0x05	; 5
     f14:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    HC05_AdminUserChoiceList();
     f18:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     f1c:	84 e0       	ldi	r24, 0x04	; 4
     f1e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     f22:	d8 c0       	rjmp	.+432    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if('2' == glbl_u8AdminUserChoice[0])
     f24:	82 33       	cpi	r24, 0x32	; 50
     f26:	71 f4       	brne	.+28     	; 0xf44 <HC05_AdminUserInterface+0x3fc>
                {
                    /*Admin/User wants to turn off LED 2*/
                    LED_Off(HC05_LED_2_PORT_ID, HC05_LED_2_PIN_ID);
     f28:	67 e0       	ldi	r22, 0x07	; 7
     f2a:	82 e0       	ldi	r24, 0x02	; 2
     f2c:	0e 94 48 0b 	call	0x1690	; 0x1690 <LED_Off>
                    UART_TxString("LED 2 Turned Off Successfully\n");
     f30:	8b e5       	ldi	r24, 0x5B	; 91
     f32:	95 e0       	ldi	r25, 0x05	; 5
     f34:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    HC05_AdminUserChoiceList();
     f38:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
                    glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     f3c:	84 e0       	ldi	r24, 0x04	; 4
     f3e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     f42:	c8 c0       	rjmp	.+400    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else
                {
                    /*Admin/User has entered wrong input*/
                    UART_TxString("Sorry, Wrong Input\n");
     f44:	8c e1       	ldi	r24, 0x1C	; 28
     f46:	91 e0       	ldi	r25, 0x01	; 1
     f48:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("1: LED 2 On\n");
     f4c:	80 e9       	ldi	r24, 0x90	; 144
     f4e:	94 e0       	ldi	r25, 0x04	; 4
     f50:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("2: LED 2 Off\n");
     f54:	8d e9       	ldi	r24, 0x9D	; 157
     f56:	94 e0       	ldi	r25, 0x04	; 4
     f58:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
     f5c:	bb c0       	rjmp	.+374    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            //        UART_TxString("Sorry, Wrong Input\n");
            //        UART_TxString("1: LED 5 On\n");
            //        UART_TxString("2: LED 5 Off\n");
            //    }
            //}
            else if(HC05_DIMMING_LED_CHOICE == glbl_u8LEDChoice)
     f5e:	86 30       	cpi	r24, 0x06	; 6
     f60:	09 f0       	breq	.+2      	; 0xf64 <HC05_AdminUserInterface+0x41c>
     f62:	b8 c0       	rjmp	.+368    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
            {
                if('1' == glbl_u8AdminUserChoice[0])
     f64:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
     f68:	81 33       	cpi	r24, 0x31	; 49
     f6a:	71 f4       	brne	.+28     	; 0xf88 <HC05_AdminUserInterface+0x440>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 0*/
                    TMR_Timer2Stop();
     f6c:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
                    LED_Off(HC05_DIMMING_LED_PORT_ID, HC05_DIMMING_LED_PIN_ID);
     f70:	67 e0       	ldi	r22, 0x07	; 7
     f72:	83 e0       	ldi	r24, 0x03	; 3
     f74:	0e 94 48 0b 	call	0x1690	; 0x1690 <LED_Off>
					HC05_AdminUserChoiceList();
     f78:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     f7c:	84 e0       	ldi	r24, 0x04	; 4
     f7e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
                    glbl_u8DimmingLEDStatus = HC05_DIMMING_LED_0;
     f82:	10 92 ff 07 	sts	0x07FF, r1	; 0x8007ff <glbl_u8DimmingLEDStatus>
     f86:	a6 c0       	rjmp	.+332    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if('2' == glbl_u8AdminUserChoice[0])
     f88:	82 33       	cpi	r24, 0x32	; 50
     f8a:	69 f4       	brne	.+26     	; 0xfa6 <HC05_AdminUserInterface+0x45e>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 20%*/
                    TMR_Timer2Stop();
     f8c:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(20);
     f90:	84 e1       	ldi	r24, 0x14	; 20
     f92:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
                    TMR_Timer2Start();
     f96:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
					HC05_AdminUserChoiceList();
     f9a:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     f9e:	84 e0       	ldi	r24, 0x04	; 4
     fa0:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     fa4:	97 c0       	rjmp	.+302    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if('3' == glbl_u8AdminUserChoice[0])
     fa6:	83 33       	cpi	r24, 0x33	; 51
     fa8:	69 f4       	brne	.+26     	; 0xfc4 <HC05_AdminUserInterface+0x47c>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 40%*/
                    TMR_Timer2Stop();
     faa:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(40);
     fae:	88 e2       	ldi	r24, 0x28	; 40
     fb0:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
                    TMR_Timer2Start();
     fb4:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
					HC05_AdminUserChoiceList();
     fb8:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     fbc:	84 e0       	ldi	r24, 0x04	; 4
     fbe:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     fc2:	88 c0       	rjmp	.+272    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if('4' == glbl_u8AdminUserChoice[0])
     fc4:	84 33       	cpi	r24, 0x34	; 52
     fc6:	69 f4       	brne	.+26     	; 0xfe2 <HC05_AdminUserInterface+0x49a>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 60%*/
                    TMR_Timer2Stop();
     fc8:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(60);
     fcc:	8c e3       	ldi	r24, 0x3C	; 60
     fce:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
					TMR_Timer2Start();
     fd2:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
                    HC05_AdminUserChoiceList();
     fd6:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     fda:	84 e0       	ldi	r24, 0x04	; 4
     fdc:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     fe0:	79 c0       	rjmp	.+242    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if('5' == glbl_u8AdminUserChoice[0])
     fe2:	85 33       	cpi	r24, 0x35	; 53
     fe4:	69 f4       	brne	.+26     	; 0x1000 <HC05_AdminUserInterface+0x4b8>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 80%*/
                    TMR_Timer2Stop();
     fe6:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
                    TMR_Timer2Set_PWM_DutyCycle(80);
     fea:	80 e5       	ldi	r24, 0x50	; 80
     fec:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
					TMR_Timer2Start();
     ff0:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
                    HC05_AdminUserChoiceList();
     ff4:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
     ff8:	84 e0       	ldi	r24, 0x04	; 4
     ffa:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
     ffe:	6a c0       	rjmp	.+212    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else if('6' == glbl_u8AdminUserChoice[0])
    1000:	86 33       	cpi	r24, 0x36	; 54
    1002:	61 f4       	brne	.+24     	; 0x101c <HC05_AdminUserInterface+0x4d4>
                {
                    /*Admin/User wants the brigtness of dimming LED to be 100%*/
                    TMR_Timer2Stop();
    1004:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
                    LED_On(HC05_DIMMING_LED_PORT_ID, HC05_DIMMING_LED_PIN_ID);
    1008:	67 e0       	ldi	r22, 0x07	; 7
    100a:	83 e0       	ldi	r24, 0x03	; 3
    100c:	0e 94 1e 0b 	call	0x163c	; 0x163c <LED_On>
                    HC05_AdminUserChoiceList();
    1010:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
					glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    1014:	84 e0       	ldi	r24, 0x04	; 4
    1016:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
    101a:	5c c0       	rjmp	.+184    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
                }
                else
                {
                    UART_TxString("Sorry, Wrong Input");
    101c:	8a e7       	ldi	r24, 0x7A	; 122
    101e:	95 e0       	ldi	r25, 0x05	; 5
    1020:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("Please Choose the brightness of LED\n");
    1024:	8b ea       	ldi	r24, 0xAB	; 171
    1026:	94 e0       	ldi	r25, 0x04	; 4
    1028:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("1: 0%\n");
    102c:	80 ed       	ldi	r24, 0xD0	; 208
    102e:	94 e0       	ldi	r25, 0x04	; 4
    1030:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("2: 20%\n");
    1034:	87 ed       	ldi	r24, 0xD7	; 215
    1036:	94 e0       	ldi	r25, 0x04	; 4
    1038:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("3: 40%\n");
    103c:	8f ed       	ldi	r24, 0xDF	; 223
    103e:	94 e0       	ldi	r25, 0x04	; 4
    1040:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("4: 60%\n");
    1044:	87 ee       	ldi	r24, 0xE7	; 231
    1046:	94 e0       	ldi	r25, 0x04	; 4
    1048:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("5: 80%\n");
    104c:	8f ee       	ldi	r24, 0xEF	; 239
    104e:	94 e0       	ldi	r25, 0x04	; 4
    1050:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
                    UART_TxString("6: 100%\n");
    1054:	87 ef       	ldi	r24, 0xF7	; 247
    1056:	94 e0       	ldi	r25, 0x04	; 4
    1058:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    105c:	3b c0       	rjmp	.+118    	; 0x10d4 <HC05_AdminUserInterface+0x58c>
        }
        case HC05_ADD_USER_USERNAME_SCREEN:
        {
            /*Admin wants to add new user*/
            /*First, we take the new user username from admin*/
            UART_RxString(glbl_u8AdminUserUsername);
    105e:	89 e0       	ldi	r24, 0x09	; 9
    1060:	98 e0       	ldi	r25, 0x08	; 8
    1062:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
            UART_TxString("Please enter the new user's password:\n");
    1066:	8d e8       	ldi	r24, 0x8D	; 141
    1068:	95 e0       	ldi	r25, 0x05	; 5
    106a:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
            glbl_u8CurrentScreen = HC05_ADD_USER_PASSWORD_SCREEN;
    106e:	8a e0       	ldi	r24, 0x0A	; 10
    1070:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
            break;
    1074:	2f c0       	rjmp	.+94     	; 0x10d4 <HC05_AdminUserInterface+0x58c>
        }
        case HC05_ADD_USER_PASSWORD_SCREEN:
        {
            /*Second, We take the new user password*/
            UART_RxString(glbl_u8AdminUserPassword);
    1076:	84 e0       	ldi	r24, 0x04	; 4
    1078:	98 e0       	ldi	r25, 0x08	; 8
    107a:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>

            /*Before we add the new user, we have to check if the user already exists or not*/
            u8 Loc_u8UserExistCheck = HC05_UserNamePasswordExist();
    107e:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <HC05_UserNamePasswordExist>
            if(Loc_u8UserExistCheck == HC05_USER_NOT_EXIST)
    1082:	82 30       	cpi	r24, 0x02	; 2
    1084:	11 f4       	brne	.+4      	; 0x108a <HC05_AdminUserInterface+0x542>
            {
                /*Means that the user doesn't exist in the EEPROM and we are ready to add it*/
                HC05_AddNewUser();
    1086:	0e 94 0c 05 	call	0xa18	; 0xa18 <HC05_AddNewUser>
            }
            else
            {
                /*Do nothing*/
            }
            HC05_AdminUserChoiceList();
    108a:	0e 94 9f 04 	call	0x93e	; 0x93e <HC05_AdminUserChoiceList>
            glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    108e:	84 e0       	ldi	r24, 0x04	; 4
    1090:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
            break;
    1094:	1f c0       	rjmp	.+62     	; 0x10d4 <HC05_AdminUserInterface+0x58c>
        }
        case HC05_DELETE_USER_SCREEN:
        {
            /*Admin wants to delete a user*/
            /*We take the user to be deleted username*/
            UART_RxString(glbl_u8AdminUserUsername);
    1096:	89 e0       	ldi	r24, 0x09	; 9
    1098:	98 e0       	ldi	r25, 0x08	; 8
    109a:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
            /*And then delete it*/
            HC05_DeleteUser();
    109e:	0e 94 46 05 	call	0xa8c	; 0xa8c <HC05_DeleteUser>
            glbl_u8CurrentScreen = HC05_SERVICES_SCREEN;
    10a2:	84 e0       	ldi	r24, 0x04	; 4
    10a4:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
            break;
    10a8:	15 c0       	rjmp	.+42     	; 0x10d4 <HC05_AdminUserInterface+0x58c>
        case HC05_LCD_KPD_SYS_REQUEST_SCREEN:
        {
            /*If User in the LCD/Keypad System wants to do something while admin is logged in, Admin must approve
            First 
            */
            UART_RxString(glbl_u8AdminUserChoice);
    10aa:	8f e0       	ldi	r24, 0x0F	; 15
    10ac:	98 e0       	ldi	r25, 0x08	; 8
    10ae:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UART_RxString>
            if('1' == glbl_u8AdminUserChoice[0])
    10b2:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <glbl_u8AdminUserChoice>
    10b6:	81 33       	cpi	r24, 0x31	; 49
    10b8:	21 f4       	brne	.+8      	; 0x10c2 <HC05_AdminUserInterface+0x57a>
            {
                /*Means that the admin approves*/
                glbl_u8AdminApproval = ADMIN_APPROVE;
    10ba:	81 e0       	ldi	r24, 0x01	; 1
    10bc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    10c0:	05 c0       	rjmp	.+10     	; 0x10cc <HC05_AdminUserInterface+0x584>
            }
            else if('2' == glbl_u8AdminUserChoice[0])
    10c2:	82 33       	cpi	r24, 0x32	; 50
    10c4:	19 f4       	brne	.+6      	; 0x10cc <HC05_AdminUserInterface+0x584>
            {
                /*Means that the admin disapproves*/
                glbl_u8AdminApproval = ADMIN_REFUSE;
    10c6:	82 e0       	ldi	r24, 0x02	; 2
    10c8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
            }
            glbl_u8CurrentScreen = glbl_u8PreviousScreen;
    10cc:	80 91 03 08 	lds	r24, 0x0803	; 0x800803 <glbl_u8PreviousScreen>
    10d0:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
        {
            /*Do nothing*/
            break;
        }
    }
}
    10d4:	cf 91       	pop	r28
    10d6:	08 95       	ret

000010d8 <HC05_ShowRunningDevices>:
/**
 * @brief: Function to show the running devices on LCD if the LCD-Keypad System is not used
 * 
 */
void HC05_ShowRunningDevices(void)
{
    10d8:	cf 93       	push	r28
    10da:	df 93       	push	r29
    10dc:	1f 92       	push	r1
    10de:	cd b7       	in	r28, 0x3d	; 61
    10e0:	de b7       	in	r29, 0x3e	; 62
    u8 Loc_u8LEDStatus = 0;
    10e2:	19 82       	std	Y+1, r1	; 0x01
    DIO_ReadOutputPinValue(HC05_LED_1_PORT_ID, HC05_LED_1_PIN_ID, &Loc_u8LEDStatus);
    10e4:	ae 01       	movw	r20, r28
    10e6:	4f 5f       	subi	r20, 0xFF	; 255
    10e8:	5f 4f       	sbci	r21, 0xFF	; 255
    10ea:	62 e0       	ldi	r22, 0x02	; 2
    10ec:	82 e0       	ldi	r24, 0x02	; 2
    10ee:	0e 94 3b 02 	call	0x476	; 0x476 <DIO_ReadOutputPinValue>
    if(Loc_u8LEDStatus == DIO_PIN_HIGH)
    10f2:	89 81       	ldd	r24, Y+1	; 0x01
    10f4:	81 30       	cpi	r24, 0x01	; 1
    10f6:	29 f4       	brne	.+10     	; 0x1102 <HC05_ShowRunningDevices+0x2a>
    {
        LCD_WriteString("LED 1: On");
    10f8:	84 eb       	ldi	r24, 0xB4	; 180
    10fa:	95 e0       	ldi	r25, 0x05	; 5
    10fc:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1100:	06 c0       	rjmp	.+12     	; 0x110e <HC05_ShowRunningDevices+0x36>
    }
    else if(Loc_u8LEDStatus == DIO_PIN_LOW)
    1102:	81 11       	cpse	r24, r1
    1104:	04 c0       	rjmp	.+8      	; 0x110e <HC05_ShowRunningDevices+0x36>
    {
        LCD_WriteString("LED 1: Off");
    1106:	8e eb       	ldi	r24, 0xBE	; 190
    1108:	95 e0       	ldi	r25, 0x05	; 5
    110a:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    else
    {
        /*Do nothing*/
    }

    LCD_SetCursorPosition(LCD_SECOND_ROW, 0);
    110e:	60 e0       	ldi	r22, 0x00	; 0
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <LCD_SetCursorPosition>
    
    DIO_ReadOutputPinValue(HC05_LED_2_PORT_ID, HC05_LED_2_PIN_ID, &Loc_u8LEDStatus);
    1116:	ae 01       	movw	r20, r28
    1118:	4f 5f       	subi	r20, 0xFF	; 255
    111a:	5f 4f       	sbci	r21, 0xFF	; 255
    111c:	67 e0       	ldi	r22, 0x07	; 7
    111e:	82 e0       	ldi	r24, 0x02	; 2
    1120:	0e 94 3b 02 	call	0x476	; 0x476 <DIO_ReadOutputPinValue>
    if(Loc_u8LEDStatus == DIO_PIN_HIGH)
    1124:	89 81       	ldd	r24, Y+1	; 0x01
    1126:	81 30       	cpi	r24, 0x01	; 1
    1128:	29 f4       	brne	.+10     	; 0x1134 <HC05_ShowRunningDevices+0x5c>
    {
        LCD_WriteString("LED 2: On");
    112a:	89 ec       	ldi	r24, 0xC9	; 201
    112c:	95 e0       	ldi	r25, 0x05	; 5
    112e:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1132:	06 c0       	rjmp	.+12     	; 0x1140 <HC05_ShowRunningDevices+0x68>
    }
    else if(Loc_u8LEDStatus == DIO_PIN_LOW)
    1134:	81 11       	cpse	r24, r1
    1136:	04 c0       	rjmp	.+8      	; 0x1140 <HC05_ShowRunningDevices+0x68>
    {
        LCD_WriteString("LED 2: Off");
    1138:	83 ed       	ldi	r24, 0xD3	; 211
    113a:	95 e0       	ldi	r25, 0x05	; 5
    113c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1140:	2f ef       	ldi	r18, 0xFF	; 255
    1142:	83 ed       	ldi	r24, 0xD3	; 211
    1144:	90 e3       	ldi	r25, 0x30	; 48
    1146:	21 50       	subi	r18, 0x01	; 1
    1148:	80 40       	sbci	r24, 0x00	; 0
    114a:	90 40       	sbci	r25, 0x00	; 0
    114c:	e1 f7       	brne	.-8      	; 0x1146 <HC05_ShowRunningDevices+0x6e>
    114e:	00 c0       	rjmp	.+0      	; 0x1150 <HC05_ShowRunningDevices+0x78>
    1150:	00 00       	nop
    {
        /*Do nothing*/
    }

    _delay_ms(1000);
    LCD_ClearDisplay();
    1152:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    //    /*Do nothing*/
    //}

    //LCD_SetCursorPosition(LCD_SECOND_ROW, 0);

    switch(glbl_u8DimmingLEDStatus)
    1156:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <glbl_u8DimmingLEDStatus>
    115a:	82 30       	cpi	r24, 0x02	; 2
    115c:	b1 f0       	breq	.+44     	; 0x118a <HC05_ShowRunningDevices+0xb2>
    115e:	28 f4       	brcc	.+10     	; 0x116a <HC05_ShowRunningDevices+0x92>
    1160:	88 23       	and	r24, r24
    1162:	49 f0       	breq	.+18     	; 0x1176 <HC05_ShowRunningDevices+0x9e>
    1164:	81 30       	cpi	r24, 0x01	; 1
    1166:	61 f0       	breq	.+24     	; 0x1180 <HC05_ShowRunningDevices+0xa8>
    1168:	23 c0       	rjmp	.+70     	; 0x11b0 <HC05_ShowRunningDevices+0xd8>
    116a:	84 30       	cpi	r24, 0x04	; 4
    116c:	c1 f0       	breq	.+48     	; 0x119e <HC05_ShowRunningDevices+0xc6>
    116e:	90 f0       	brcs	.+36     	; 0x1194 <HC05_ShowRunningDevices+0xbc>
    1170:	85 30       	cpi	r24, 0x05	; 5
    1172:	d1 f0       	breq	.+52     	; 0x11a8 <HC05_ShowRunningDevices+0xd0>
    1174:	1d c0       	rjmp	.+58     	; 0x11b0 <HC05_ShowRunningDevices+0xd8>
    {
        case HC05_DIMMING_LED_0:
        {
            LCD_WriteString("Dimming LED: 0");
    1176:	8e ed       	ldi	r24, 0xDE	; 222
    1178:	95 e0       	ldi	r25, 0x05	; 5
    117a:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
            break;
    117e:	18 c0       	rjmp	.+48     	; 0x11b0 <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_20:
        {
            LCD_WriteString("Dimming LED: 20%");
    1180:	8d ee       	ldi	r24, 0xED	; 237
    1182:	95 e0       	ldi	r25, 0x05	; 5
    1184:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
            break;
    1188:	13 c0       	rjmp	.+38     	; 0x11b0 <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_40:
        {
            LCD_WriteString("Dimming LED: 40%");
    118a:	8e ef       	ldi	r24, 0xFE	; 254
    118c:	95 e0       	ldi	r25, 0x05	; 5
    118e:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
            break;
    1192:	0e c0       	rjmp	.+28     	; 0x11b0 <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_60:
        {
            LCD_WriteString("Dimming LED: 60%");
    1194:	8f e0       	ldi	r24, 0x0F	; 15
    1196:	96 e0       	ldi	r25, 0x06	; 6
    1198:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
            break;
    119c:	09 c0       	rjmp	.+18     	; 0x11b0 <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_80:
        {
            LCD_WriteString("Dimming LED: 80%");
    119e:	80 e2       	ldi	r24, 0x20	; 32
    11a0:	96 e0       	ldi	r25, 0x06	; 6
    11a2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
            break;
    11a6:	04 c0       	rjmp	.+8      	; 0x11b0 <HC05_ShowRunningDevices+0xd8>
        }
        case HC05_DIMMING_LED_100:
        {
            LCD_WriteString("Dimming LED:100%");
    11a8:	81 e3       	ldi	r24, 0x31	; 49
    11aa:	96 e0       	ldi	r25, 0x06	; 6
    11ac:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    11b0:	2f ef       	ldi	r18, 0xFF	; 255
    11b2:	83 ed       	ldi	r24, 0xD3	; 211
    11b4:	90 e3       	ldi	r25, 0x30	; 48
    11b6:	21 50       	subi	r18, 0x01	; 1
    11b8:	80 40       	sbci	r24, 0x00	; 0
    11ba:	90 40       	sbci	r25, 0x00	; 0
    11bc:	e1 f7       	brne	.-8      	; 0x11b6 <HC05_ShowRunningDevices+0xde>
    11be:	00 c0       	rjmp	.+0      	; 0x11c0 <HC05_ShowRunningDevices+0xe8>
    11c0:	00 00       	nop
            break;
        }
    }

    _delay_ms(1000);
    LCD_ClearDisplay();
    11c2:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    
    if(glbl_u8DoorStatus == DOOR_CLOSED)
    11c6:	80 91 fe 07 	lds	r24, 0x07FE	; 0x8007fe <glbl_u8DoorStatus>
    11ca:	81 11       	cpse	r24, r1
    11cc:	05 c0       	rjmp	.+10     	; 0x11d8 <HC05_ShowRunningDevices+0x100>
    {
        LCD_WriteString("Door Closed");
    11ce:	82 e4       	ldi	r24, 0x42	; 66
    11d0:	96 e0       	ldi	r25, 0x06	; 6
    11d2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    11d6:	06 c0       	rjmp	.+12     	; 0x11e4 <HC05_ShowRunningDevices+0x10c>
    }
    else if(glbl_u8DoorStatus == DOOR_OPENED)
    11d8:	81 30       	cpi	r24, 0x01	; 1
    11da:	21 f4       	brne	.+8      	; 0x11e4 <HC05_ShowRunningDevices+0x10c>
    {
        LCD_WriteString("Door Opened");
    11dc:	8e e4       	ldi	r24, 0x4E	; 78
    11de:	96 e0       	ldi	r25, 0x06	; 6
    11e0:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    11e4:	2f ef       	ldi	r18, 0xFF	; 255
    11e6:	83 ed       	ldi	r24, 0xD3	; 211
    11e8:	90 e3       	ldi	r25, 0x30	; 48
    11ea:	21 50       	subi	r18, 0x01	; 1
    11ec:	80 40       	sbci	r24, 0x00	; 0
    11ee:	90 40       	sbci	r25, 0x00	; 0
    11f0:	e1 f7       	brne	.-8      	; 0x11ea <HC05_ShowRunningDevices+0x112>
    11f2:	00 c0       	rjmp	.+0      	; 0x11f4 <HC05_ShowRunningDevices+0x11c>
    11f4:	00 00       	nop
    else
    {
        /*Do nothing*/
    }
    _delay_ms(1000);
    LCD_ClearDisplay();
    11f6:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
}
    11fa:	0f 90       	pop	r0
    11fc:	df 91       	pop	r29
    11fe:	cf 91       	pop	r28
    1200:	08 95       	ret

00001202 <HC05_AdminApproval>:
 * 
 * @return u8: Approval or Refuse 
 */
u8 HC05_AdminApproval(void)
{
    switch (glbl_u8AdminApproval)
    1202:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    1206:	81 30       	cpi	r24, 0x01	; 1
    1208:	19 f0       	breq	.+6      	; 0x1210 <HC05_AdminApproval+0xe>
    120a:	82 30       	cpi	r24, 0x02	; 2
    120c:	29 f0       	breq	.+10     	; 0x1218 <HC05_AdminApproval+0x16>
    120e:	08 c0       	rjmp	.+16     	; 0x1220 <HC05_AdminApproval+0x1e>
    {
    case ADMIN_APPROVE:
        {
            glbl_u8AdminApproval = ADMIN_NOT_REPLIED;
    1210:	93 e0       	ldi	r25, 0x03	; 3
    1212:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
            return ADMIN_APPROVE;
    1216:	08 95       	ret
            break;
        }
    case ADMIN_REFUSE:
        {
            glbl_u8AdminApproval = ADMIN_NOT_REPLIED;
    1218:	93 e0       	ldi	r25, 0x03	; 3
    121a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
            return ADMIN_REFUSE;
    121e:	08 95       	ret
            break;
        }
    default:
        {
            return ADMIN_NOT_REPLIED;
    1220:	83 e0       	ldi	r24, 0x03	; 3
            break;
        }
    }
}
    1222:	08 95       	ret

00001224 <HC05_ScreenChangeToAdminResponse>:
 * @brief: Function to change the screen to admin response screen so that admin can choose to approve or disapprove
 * 
 */
void HC05_ScreenChangeToAdminResponse(void)
{
    glbl_u8PreviousScreen = glbl_u8CurrentScreen;
    1224:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <glbl_u8CurrentScreen>
    1228:	80 93 03 08 	sts	0x0803, r24	; 0x800803 <glbl_u8PreviousScreen>
    glbl_u8CurrentScreen = HC05_LCD_KPD_SYS_REQUEST_SCREEN;
    122c:	8d e0       	ldi	r24, 0x0D	; 13
    122e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <glbl_u8CurrentScreen>
    1232:	08 95       	ret

00001234 <Internal_EEPROM_WriteByte>:
 * @param Copy_u16ByteAddress: The EEPROM Byte Address in which the data byte will be stored
 * @param Copy_u8DataByte: The Data byte to be stored
 */
void Internal_EEPROM_WriteByte(u16 Copy_u16ByteAddress, u8 Copy_u8DataByte)
{
    if((Copy_u16ByteAddress >= 0) && (Copy_u16ByteAddress <= INTERNAL_EEPROM_MAX_ADDRESS))
    1234:	81 15       	cp	r24, r1
    1236:	24 e0       	ldi	r18, 0x04	; 4
    1238:	92 07       	cpc	r25, r18
    123a:	58 f4       	brcc	.+22     	; 0x1252 <Internal_EEPROM_WriteByte+0x1e>
    {
        /*Waiting for the previous write to be completed*/
        while(1 == GET_BIT(EECR, EEWE));
    123c:	e1 99       	sbic	0x1c, 1	; 28
    123e:	fe cf       	rjmp	.-4      	; 0x123c <Internal_EEPROM_WriteByte+0x8>

        /*Writing EEPROM Address in which we want to write the byte*/
        EEAR_u16 = Copy_u16ByteAddress;
    1240:	9f bb       	out	0x1f, r25	; 31
    1242:	8e bb       	out	0x1e, r24	; 30

        /*Writing the byte which we want to write*/
        EEDR = Copy_u8DataByte;
    1244:	6d bb       	out	0x1d, r22	; 29
        
        /*Setting EEMWE Bit in EECR Register to allow me to write in EEPROM*/
        /*By setting EEWE Bit in the EECR register*/
        EECR |= (1 << EEMWE);
    1246:	8c b3       	in	r24, 0x1c	; 28
    1248:	84 60       	ori	r24, 0x04	; 4
    124a:	8c bb       	out	0x1c, r24	; 28
		EECR |= (1 << EEWE); 
    124c:	8c b3       	in	r24, 0x1c	; 28
    124e:	82 60       	ori	r24, 0x02	; 2
    1250:	8c bb       	out	0x1c, r24	; 28
    1252:	08 95       	ret

00001254 <Internal_EEPROM_ReadByte>:
 * @param Copy_u16ByteAddress: The EEPROM Byte Address from which the data byte will be read
 * @param P_u8DataByte: Pointer to store the data byte read from EEPROM 
 */
void Internal_EEPROM_ReadByte(u16 Copy_u16ByteAddress, u8* P_u8DataByte)
{
    if(P_u8DataByte != NULL)
    1254:	61 15       	cp	r22, r1
    1256:	71 05       	cpc	r23, r1
    1258:	71 f0       	breq	.+28     	; 0x1276 <Internal_EEPROM_ReadByte+0x22>
    {
        if((Copy_u16ByteAddress >= 0) && (Copy_u16ByteAddress <= INTERNAL_EEPROM_MAX_ADDRESS))
    125a:	81 15       	cp	r24, r1
    125c:	24 e0       	ldi	r18, 0x04	; 4
    125e:	92 07       	cpc	r25, r18
    1260:	50 f4       	brcc	.+20     	; 0x1276 <Internal_EEPROM_ReadByte+0x22>
        {
            /*As we can't read from EEPROM while writing into it*/
            /*We have to wait for the previous write to be completed*/
            while(1 == GET_BIT(EECR, EEWE));
    1262:	e1 99       	sbic	0x1c, 1	; 28
    1264:	fe cf       	rjmp	.-4      	; 0x1262 <Internal_EEPROM_ReadByte+0xe>

            /*Writing EEPROM Address in which we want to read the byte stored*/
            EEAR_u16 = Copy_u16ByteAddress;
    1266:	9f bb       	out	0x1f, r25	; 31
    1268:	8e bb       	out	0x1e, r24	; 30
            
            /*Setting this bit will start the EEPROM Read operation*/
            EECR |= (1 << EERE);
    126a:	8c b3       	in	r24, 0x1c	; 28
    126c:	81 60       	ori	r24, 0x01	; 1
    126e:	8c bb       	out	0x1c, r24	; 28

            *P_u8DataByte = EEDR;
    1270:	8d b3       	in	r24, 0x1d	; 29
    1272:	fb 01       	movw	r30, r22
    1274:	80 83       	st	Z, r24
    1276:	08 95       	ret

00001278 <KPD_Init>:
 *         (Set the directions and the initial values of the pins connected to the keypad)
 * 
 */
void KPD_Init(void)
{
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL0_PIN, DIO_PIN_OUTPUT);
    1278:	41 e0       	ldi	r20, 0x01	; 1
    127a:	64 e0       	ldi	r22, 0x04	; 4
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL1_PIN, DIO_PIN_OUTPUT);
    1282:	41 e0       	ldi	r20, 0x01	; 1
    1284:	65 e0       	ldi	r22, 0x05	; 5
    1286:	81 e0       	ldi	r24, 0x01	; 1
    1288:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL2_PIN, DIO_PIN_OUTPUT);
    128c:	41 e0       	ldi	r20, 0x01	; 1
    128e:	66 e0       	ldi	r22, 0x06	; 6
    1290:	81 e0       	ldi	r24, 0x01	; 1
    1292:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_COLS_PORT, KPD_COL3_PIN, DIO_PIN_OUTPUT);
    1296:	41 e0       	ldi	r20, 0x01	; 1
    1298:	67 e0       	ldi	r22, 0x07	; 7
    129a:	81 e0       	ldi	r24, 0x01	; 1
    129c:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>

    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW0_PIN, DIO_PIN_INPUT);
    12a0:	40 e0       	ldi	r20, 0x00	; 0
    12a2:	63 e0       	ldi	r22, 0x03	; 3
    12a4:	82 e0       	ldi	r24, 0x02	; 2
    12a6:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW1_PIN, DIO_PIN_INPUT);
    12aa:	40 e0       	ldi	r20, 0x00	; 0
    12ac:	64 e0       	ldi	r22, 0x04	; 4
    12ae:	82 e0       	ldi	r24, 0x02	; 2
    12b0:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW2_PIN, DIO_PIN_INPUT);
    12b4:	40 e0       	ldi	r20, 0x00	; 0
    12b6:	65 e0       	ldi	r22, 0x05	; 5
    12b8:	82 e0       	ldi	r24, 0x02	; 2
    12ba:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(KPD_ROWS_PORT, KPD_ROW3_PIN, DIO_PIN_INPUT);
    12be:	40 e0       	ldi	r20, 0x00	; 0
    12c0:	66 e0       	ldi	r22, 0x06	; 6
    12c2:	82 e0       	ldi	r24, 0x02	; 2
    12c4:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>

    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL0_PIN, DIO_PIN_HIGH);
    12c8:	41 e0       	ldi	r20, 0x01	; 1
    12ca:	64 e0       	ldi	r22, 0x04	; 4
    12cc:	81 e0       	ldi	r24, 0x01	; 1
    12ce:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL1_PIN, DIO_PIN_HIGH);
    12d2:	41 e0       	ldi	r20, 0x01	; 1
    12d4:	65 e0       	ldi	r22, 0x05	; 5
    12d6:	81 e0       	ldi	r24, 0x01	; 1
    12d8:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL2_PIN, DIO_PIN_HIGH);
    12dc:	41 e0       	ldi	r20, 0x01	; 1
    12de:	66 e0       	ldi	r22, 0x06	; 6
    12e0:	81 e0       	ldi	r24, 0x01	; 1
    12e2:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    DIO_SetPinValue(KPD_COLS_PORT, KPD_COL3_PIN, DIO_PIN_HIGH);
    12e6:	41 e0       	ldi	r20, 0x01	; 1
    12e8:	67 e0       	ldi	r22, 0x07	; 7
    12ea:	81 e0       	ldi	r24, 0x01	; 1
    12ec:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>

    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW0_PIN);
    12f0:	63 e0       	ldi	r22, 0x03	; 3
    12f2:	82 e0       	ldi	r24, 0x02	; 2
    12f4:	0e 94 e5 02 	call	0x5ca	; 0x5ca <DIO_ActivatePullUp>
    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW1_PIN);
    12f8:	64 e0       	ldi	r22, 0x04	; 4
    12fa:	82 e0       	ldi	r24, 0x02	; 2
    12fc:	0e 94 e5 02 	call	0x5ca	; 0x5ca <DIO_ActivatePullUp>
    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW2_PIN);
    1300:	65 e0       	ldi	r22, 0x05	; 5
    1302:	82 e0       	ldi	r24, 0x02	; 2
    1304:	0e 94 e5 02 	call	0x5ca	; 0x5ca <DIO_ActivatePullUp>
    DIO_ActivatePullUp(KPD_ROWS_PORT, KPD_ROW3_PIN);
    1308:	66 e0       	ldi	r22, 0x06	; 6
    130a:	82 e0       	ldi	r24, 0x02	; 2
    130c:	0e 94 e5 02 	call	0x5ca	; 0x5ca <DIO_ActivatePullUp>
    1310:	08 95       	ret

00001312 <KPD_GetValue>:
 * @brief: Function to get the pressed button in the keypad
 * 
 * @param P_u8ReturnedValue: Pointer to put the pressed button in it 
 */
void KPD_GetValue(u8* P_u8ReturnedValue)
{
    1312:	9f 92       	push	r9
    1314:	af 92       	push	r10
    1316:	bf 92       	push	r11
    1318:	cf 92       	push	r12
    131a:	df 92       	push	r13
    131c:	ef 92       	push	r14
    131e:	ff 92       	push	r15
    1320:	0f 93       	push	r16
    1322:	1f 93       	push	r17
    1324:	cf 93       	push	r28
    1326:	df 93       	push	r29
    1328:	cd b7       	in	r28, 0x3d	; 61
    132a:	de b7       	in	r29, 0x3e	; 62
    132c:	61 97       	sbiw	r28, 0x11	; 17
    132e:	0f b6       	in	r0, 0x3f	; 63
    1330:	f8 94       	cli
    1332:	de bf       	out	0x3e, r29	; 62
    1334:	0f be       	out	0x3f, r0	; 63
    1336:	cd bf       	out	0x3d, r28	; 61
    if(P_u8ReturnedValue != NULL)
    1338:	00 97       	sbiw	r24, 0x00	; 0
    133a:	09 f4       	brne	.+2      	; 0x133e <KPD_GetValue+0x2c>
    133c:	5e c0       	rjmp	.+188    	; 0x13fa <KPD_GetValue+0xe8>
    133e:	5c 01       	movw	r10, r24
    {
        u8 Loc_u8KPD_Keys[NO_COLUMNS][NO_ROWS] = {
    1340:	80 e1       	ldi	r24, 0x10	; 16
    1342:	e1 e6       	ldi	r30, 0x61	; 97
    1344:	f0 e0       	ldi	r31, 0x00	; 0
    1346:	de 01       	movw	r26, r28
    1348:	11 96       	adiw	r26, 0x01	; 1
    134a:	01 90       	ld	r0, Z+
    134c:	0d 92       	st	X+, r0
    134e:	8a 95       	dec	r24
    1350:	e1 f7       	brne	.-8      	; 0x134a <KPD_GetValue+0x38>
                                                    {'1', '2', '3', 'A'},
                                                    {'4', '5', '6', 'B'},
                                                    {'7', '8', '9', 'C'},
                                                    {'*', '0', '#', 'D'}
                                                };
		*P_u8ReturnedValue = KPD_NOT_PRESSED;
    1352:	8f ef       	ldi	r24, 0xFF	; 255
    1354:	f5 01       	movw	r30, r10
    1356:	80 83       	st	Z, r24
        u8 Loc_u8ColsCounter = 0, Loc_u8RowsCounter = 0, Loc_u8PinValue, Loc_u8PinFlag = 0;
    1358:	91 2c       	mov	r9, r1
        for(Loc_u8ColsCounter = 0; Loc_u8ColsCounter < NO_COLUMNS; Loc_u8ColsCounter++)
    135a:	00 e0       	ldi	r16, 0x00	; 0
    135c:	4b c0       	rjmp	.+150    	; 0x13f4 <KPD_GetValue+0xe2>
        {
            //Activate column
            DIO_SetPinValue(KPD_COLS_PORT, KPD_ColumnsPins[Loc_u8ColsCounter], DIO_PIN_LOW);
    135e:	c0 2e       	mov	r12, r16
    1360:	d1 2c       	mov	r13, r1
    1362:	f6 01       	movw	r30, r12
    1364:	ef 59       	subi	r30, 0x9F	; 159
    1366:	f9 4f       	sbci	r31, 0xF9	; 249
    1368:	40 e0       	ldi	r20, 0x00	; 0
    136a:	60 81       	ld	r22, Z
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>

            /*Read the value of the rows and find the pressed button*/
            for(Loc_u8RowsCounter = 0; Loc_u8RowsCounter < NO_ROWS; Loc_u8RowsCounter++)
    1372:	10 e0       	ldi	r17, 0x00	; 0
    1374:	31 c0       	rjmp	.+98     	; 0x13d8 <KPD_GetValue+0xc6>
            {
                DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
    1376:	e1 2e       	mov	r14, r17
    1378:	f1 2c       	mov	r15, r1
    137a:	f7 01       	movw	r30, r14
    137c:	e3 5a       	subi	r30, 0xA3	; 163
    137e:	f9 4f       	sbci	r31, 0xF9	; 249
    1380:	ae 01       	movw	r20, r28
    1382:	4f 5e       	subi	r20, 0xEF	; 239
    1384:	5f 4f       	sbci	r21, 0xFF	; 255
    1386:	60 81       	ld	r22, Z
    1388:	82 e0       	ldi	r24, 0x02	; 2
    138a:	0e 94 c0 01 	call	0x380	; 0x380 <DIO_ReadPinValue>
                if(KPD_PRESSED == Loc_u8PinValue)
    138e:	99 89       	ldd	r25, Y+17	; 0x11
    1390:	91 11       	cpse	r25, r1
    1392:	21 c0       	rjmp	.+66     	; 0x13d6 <KPD_GetValue+0xc4>
                {
                    *P_u8ReturnedValue = Loc_u8KPD_Keys[Loc_u8RowsCounter][Loc_u8ColsCounter];
    1394:	f7 01       	movw	r30, r14
    1396:	ee 0f       	add	r30, r30
    1398:	ff 1f       	adc	r31, r31
    139a:	ee 0f       	add	r30, r30
    139c:	ff 1f       	adc	r31, r31
    139e:	81 e0       	ldi	r24, 0x01	; 1
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	8c 0f       	add	r24, r28
    13a4:	9d 1f       	adc	r25, r29
    13a6:	e8 0f       	add	r30, r24
    13a8:	f9 1f       	adc	r31, r25
    13aa:	ec 0d       	add	r30, r12
    13ac:	fd 1d       	adc	r31, r13
    13ae:	80 81       	ld	r24, Z
    13b0:	f5 01       	movw	r30, r10
    13b2:	80 83       	st	Z, r24
                    while(Loc_u8PinValue == 0)
    13b4:	0a c0       	rjmp	.+20     	; 0x13ca <KPD_GetValue+0xb8>
                    {
                        DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
    13b6:	ae 01       	movw	r20, r28
    13b8:	4f 5e       	subi	r20, 0xEF	; 239
    13ba:	5f 4f       	sbci	r21, 0xFF	; 255
    13bc:	f7 01       	movw	r30, r14
    13be:	e3 5a       	subi	r30, 0xA3	; 163
    13c0:	f9 4f       	sbci	r31, 0xF9	; 249
    13c2:	60 81       	ld	r22, Z
    13c4:	82 e0       	ldi	r24, 0x02	; 2
    13c6:	0e 94 c0 01 	call	0x380	; 0x380 <DIO_ReadPinValue>
            {
                DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
                if(KPD_PRESSED == Loc_u8PinValue)
                {
                    *P_u8ReturnedValue = Loc_u8KPD_Keys[Loc_u8RowsCounter][Loc_u8ColsCounter];
                    while(Loc_u8PinValue == 0)
    13ca:	89 89       	ldd	r24, Y+17	; 0x11
    13cc:	88 23       	and	r24, r24
    13ce:	99 f3       	breq	.-26     	; 0x13b6 <KPD_GetValue+0xa4>
                    {
                        DIO_ReadPinValue(KPD_ROWS_PORT, KPD_RowsPins[Loc_u8RowsCounter], &Loc_u8PinValue);
                    }
                    Loc_u8PinFlag = 1;
    13d0:	99 24       	eor	r9, r9
    13d2:	93 94       	inc	r9
    13d4:	03 c0       	rjmp	.+6      	; 0x13dc <KPD_GetValue+0xca>
        {
            //Activate column
            DIO_SetPinValue(KPD_COLS_PORT, KPD_ColumnsPins[Loc_u8ColsCounter], DIO_PIN_LOW);

            /*Read the value of the rows and find the pressed button*/
            for(Loc_u8RowsCounter = 0; Loc_u8RowsCounter < NO_ROWS; Loc_u8RowsCounter++)
    13d6:	1f 5f       	subi	r17, 0xFF	; 255
    13d8:	14 30       	cpi	r17, 0x04	; 4
    13da:	68 f2       	brcs	.-102    	; 0x1376 <KPD_GetValue+0x64>
                {
                    /*Do nothing*/
                }
            }
            //Deactivate column
            DIO_SetPinValue(KPD_COLS_PORT, KPD_ColumnsPins[Loc_u8ColsCounter], DIO_PIN_HIGH);
    13dc:	f6 01       	movw	r30, r12
    13de:	ef 59       	subi	r30, 0x9F	; 159
    13e0:	f9 4f       	sbci	r31, 0xF9	; 249
    13e2:	41 e0       	ldi	r20, 0x01	; 1
    13e4:	60 81       	ld	r22, Z
    13e6:	81 e0       	ldi	r24, 0x01	; 1
    13e8:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>

            if(Loc_u8PinFlag == 1)
    13ec:	f1 e0       	ldi	r31, 0x01	; 1
    13ee:	9f 16       	cp	r9, r31
    13f0:	21 f0       	breq	.+8      	; 0x13fa <KPD_GetValue+0xe8>
                                                    {'7', '8', '9', 'C'},
                                                    {'*', '0', '#', 'D'}
                                                };
		*P_u8ReturnedValue = KPD_NOT_PRESSED;
        u8 Loc_u8ColsCounter = 0, Loc_u8RowsCounter = 0, Loc_u8PinValue, Loc_u8PinFlag = 0;
        for(Loc_u8ColsCounter = 0; Loc_u8ColsCounter < NO_COLUMNS; Loc_u8ColsCounter++)
    13f2:	0f 5f       	subi	r16, 0xFF	; 255
    13f4:	04 30       	cpi	r16, 0x04	; 4
    13f6:	08 f4       	brcc	.+2      	; 0x13fa <KPD_GetValue+0xe8>
    13f8:	b2 cf       	rjmp	.-156    	; 0x135e <KPD_GetValue+0x4c>
    }
    else
    {
        /*Do nothing*/
    }
    13fa:	61 96       	adiw	r28, 0x11	; 17
    13fc:	0f b6       	in	r0, 0x3f	; 63
    13fe:	f8 94       	cli
    1400:	de bf       	out	0x3e, r29	; 62
    1402:	0f be       	out	0x3f, r0	; 63
    1404:	cd bf       	out	0x3d, r28	; 61
    1406:	df 91       	pop	r29
    1408:	cf 91       	pop	r28
    140a:	1f 91       	pop	r17
    140c:	0f 91       	pop	r16
    140e:	ff 90       	pop	r15
    1410:	ef 90       	pop	r14
    1412:	df 90       	pop	r13
    1414:	cf 90       	pop	r12
    1416:	bf 90       	pop	r11
    1418:	af 90       	pop	r10
    141a:	9f 90       	pop	r9
    141c:	08 95       	ret

0000141e <LCD_Peek>:
        for(Loc_u8Index = 0; Loc_u8Index < Loc_u8Count; Loc_u8Index++)
        {
            LCD_WriteChar4Bit(Loc_u8CharArray[Loc_u8Count - Loc_u8Index - 1]);
        }
    }
}
    141e:	41 e0       	ldi	r20, 0x01	; 1
    1420:	63 e0       	ldi	r22, 0x03	; 3
    1422:	81 e0       	ldi	r24, 0x01	; 1
    1424:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    1428:	8f e9       	ldi	r24, 0x9F	; 159
    142a:	9f e0       	ldi	r25, 0x0F	; 15
    142c:	01 97       	sbiw	r24, 0x01	; 1
    142e:	f1 f7       	brne	.-4      	; 0x142c <LCD_Peek+0xe>
    1430:	00 c0       	rjmp	.+0      	; 0x1432 <LCD_Peek+0x14>
    1432:	00 00       	nop
    1434:	40 e0       	ldi	r20, 0x00	; 0
    1436:	63 e0       	ldi	r22, 0x03	; 3
    1438:	81 e0       	ldi	r24, 0x01	; 1
    143a:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    143e:	08 95       	ret

00001440 <LCD_WriteCommand4Bit>:
    1440:	cf 93       	push	r28
    1442:	c8 2f       	mov	r28, r24
    1444:	40 e0       	ldi	r20, 0x00	; 0
    1446:	61 e0       	ldi	r22, 0x01	; 1
    1448:	81 e0       	ldi	r24, 0x01	; 1
    144a:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    144e:	40 e0       	ldi	r20, 0x00	; 0
    1450:	62 e0       	ldi	r22, 0x02	; 2
    1452:	81 e0       	ldi	r24, 0x01	; 1
    1454:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    1458:	8f e3       	ldi	r24, 0x3F	; 63
    145a:	9f e1       	ldi	r25, 0x1F	; 31
    145c:	01 97       	sbiw	r24, 0x01	; 1
    145e:	f1 f7       	brne	.-4      	; 0x145c <LCD_WriteCommand4Bit+0x1c>
    1460:	00 c0       	rjmp	.+0      	; 0x1462 <LCD_WriteCommand4Bit+0x22>
    1462:	00 00       	nop
    1464:	4c 2f       	mov	r20, r28
    1466:	42 95       	swap	r20
    1468:	4f 70       	andi	r20, 0x0F	; 15
    146a:	64 e0       	ldi	r22, 0x04	; 4
    146c:	80 e0       	ldi	r24, 0x00	; 0
    146e:	0e 94 b6 02 	call	0x56c	; 0x56c <DIO_WriteHalfPort>
    1472:	8f e3       	ldi	r24, 0x3F	; 63
    1474:	9f e1       	ldi	r25, 0x1F	; 31
    1476:	01 97       	sbiw	r24, 0x01	; 1
    1478:	f1 f7       	brne	.-4      	; 0x1476 <LCD_WriteCommand4Bit+0x36>
    147a:	00 c0       	rjmp	.+0      	; 0x147c <LCD_WriteCommand4Bit+0x3c>
    147c:	00 00       	nop
    147e:	0e 94 0f 0a 	call	0x141e	; 0x141e <LCD_Peek>
    1482:	8f e3       	ldi	r24, 0x3F	; 63
    1484:	9f e1       	ldi	r25, 0x1F	; 31
    1486:	01 97       	sbiw	r24, 0x01	; 1
    1488:	f1 f7       	brne	.-4      	; 0x1486 <LCD_WriteCommand4Bit+0x46>
    148a:	00 c0       	rjmp	.+0      	; 0x148c <LCD_WriteCommand4Bit+0x4c>
    148c:	00 00       	nop
    148e:	4c 2f       	mov	r20, r28
    1490:	4f 70       	andi	r20, 0x0F	; 15
    1492:	64 e0       	ldi	r22, 0x04	; 4
    1494:	80 e0       	ldi	r24, 0x00	; 0
    1496:	0e 94 b6 02 	call	0x56c	; 0x56c <DIO_WriteHalfPort>
    149a:	8f e3       	ldi	r24, 0x3F	; 63
    149c:	9f e1       	ldi	r25, 0x1F	; 31
    149e:	01 97       	sbiw	r24, 0x01	; 1
    14a0:	f1 f7       	brne	.-4      	; 0x149e <LCD_WriteCommand4Bit+0x5e>
    14a2:	00 c0       	rjmp	.+0      	; 0x14a4 <LCD_WriteCommand4Bit+0x64>
    14a4:	00 00       	nop
    14a6:	0e 94 0f 0a 	call	0x141e	; 0x141e <LCD_Peek>
    14aa:	8f e3       	ldi	r24, 0x3F	; 63
    14ac:	9f e1       	ldi	r25, 0x1F	; 31
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	f1 f7       	brne	.-4      	; 0x14ae <LCD_WriteCommand4Bit+0x6e>
    14b2:	00 c0       	rjmp	.+0      	; 0x14b4 <LCD_WriteCommand4Bit+0x74>
    14b4:	00 00       	nop
    14b6:	cf 91       	pop	r28
    14b8:	08 95       	ret

000014ba <LCD_SetCursorPosition>:
    14ba:	82 30       	cpi	r24, 0x02	; 2
    14bc:	70 f4       	brcc	.+28     	; 0x14da <LCD_SetCursorPosition+0x20>
    14be:	60 31       	cpi	r22, 0x10	; 16
    14c0:	60 f4       	brcc	.+24     	; 0x14da <LCD_SetCursorPosition+0x20>
    14c2:	88 23       	and	r24, r24
    14c4:	31 f0       	breq	.+12     	; 0x14d2 <LCD_SetCursorPosition+0x18>
    14c6:	81 30       	cpi	r24, 0x01	; 1
    14c8:	11 f0       	breq	.+4      	; 0x14ce <LCD_SetCursorPosition+0x14>
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	03 c0       	rjmp	.+6      	; 0x14d4 <LCD_SetCursorPosition+0x1a>
    14ce:	80 ec       	ldi	r24, 0xC0	; 192
    14d0:	01 c0       	rjmp	.+2      	; 0x14d4 <LCD_SetCursorPosition+0x1a>
    14d2:	80 e8       	ldi	r24, 0x80	; 128
    14d4:	86 0f       	add	r24, r22
    14d6:	0e 94 20 0a 	call	0x1440	; 0x1440 <LCD_WriteCommand4Bit>
    14da:	08 95       	ret

000014dc <LCD_WriteChar4Bit>:
    14dc:	cf 93       	push	r28
    14de:	c8 2f       	mov	r28, r24
    14e0:	41 e0       	ldi	r20, 0x01	; 1
    14e2:	61 e0       	ldi	r22, 0x01	; 1
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    14ea:	40 e0       	ldi	r20, 0x00	; 0
    14ec:	62 e0       	ldi	r22, 0x02	; 2
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    14f4:	8f e3       	ldi	r24, 0x3F	; 63
    14f6:	9f e1       	ldi	r25, 0x1F	; 31
    14f8:	01 97       	sbiw	r24, 0x01	; 1
    14fa:	f1 f7       	brne	.-4      	; 0x14f8 <LCD_WriteChar4Bit+0x1c>
    14fc:	00 c0       	rjmp	.+0      	; 0x14fe <LCD_WriteChar4Bit+0x22>
    14fe:	00 00       	nop
    1500:	4c 2f       	mov	r20, r28
    1502:	42 95       	swap	r20
    1504:	4f 70       	andi	r20, 0x0F	; 15
    1506:	64 e0       	ldi	r22, 0x04	; 4
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	0e 94 b6 02 	call	0x56c	; 0x56c <DIO_WriteHalfPort>
    150e:	8f e3       	ldi	r24, 0x3F	; 63
    1510:	9f e1       	ldi	r25, 0x1F	; 31
    1512:	01 97       	sbiw	r24, 0x01	; 1
    1514:	f1 f7       	brne	.-4      	; 0x1512 <LCD_WriteChar4Bit+0x36>
    1516:	00 c0       	rjmp	.+0      	; 0x1518 <LCD_WriteChar4Bit+0x3c>
    1518:	00 00       	nop
    151a:	0e 94 0f 0a 	call	0x141e	; 0x141e <LCD_Peek>
    151e:	8f e3       	ldi	r24, 0x3F	; 63
    1520:	9f e1       	ldi	r25, 0x1F	; 31
    1522:	01 97       	sbiw	r24, 0x01	; 1
    1524:	f1 f7       	brne	.-4      	; 0x1522 <LCD_WriteChar4Bit+0x46>
    1526:	00 c0       	rjmp	.+0      	; 0x1528 <LCD_WriteChar4Bit+0x4c>
    1528:	00 00       	nop
    152a:	4c 2f       	mov	r20, r28
    152c:	4f 70       	andi	r20, 0x0F	; 15
    152e:	64 e0       	ldi	r22, 0x04	; 4
    1530:	80 e0       	ldi	r24, 0x00	; 0
    1532:	0e 94 b6 02 	call	0x56c	; 0x56c <DIO_WriteHalfPort>
    1536:	8f e3       	ldi	r24, 0x3F	; 63
    1538:	9f e1       	ldi	r25, 0x1F	; 31
    153a:	01 97       	sbiw	r24, 0x01	; 1
    153c:	f1 f7       	brne	.-4      	; 0x153a <LCD_WriteChar4Bit+0x5e>
    153e:	00 c0       	rjmp	.+0      	; 0x1540 <LCD_WriteChar4Bit+0x64>
    1540:	00 00       	nop
    1542:	0e 94 0f 0a 	call	0x141e	; 0x141e <LCD_Peek>
    1546:	8f e3       	ldi	r24, 0x3F	; 63
    1548:	9f e1       	ldi	r25, 0x1F	; 31
    154a:	01 97       	sbiw	r24, 0x01	; 1
    154c:	f1 f7       	brne	.-4      	; 0x154a <LCD_WriteChar4Bit+0x6e>
    154e:	00 c0       	rjmp	.+0      	; 0x1550 <LCD_WriteChar4Bit+0x74>
    1550:	00 00       	nop
    1552:	cf 91       	pop	r28
    1554:	08 95       	ret

00001556 <LCD_WriteString>:
    1556:	0f 93       	push	r16
    1558:	1f 93       	push	r17
    155a:	cf 93       	push	r28
    155c:	00 97       	sbiw	r24, 0x00	; 0
    155e:	29 f4       	brne	.+10     	; 0x156a <LCD_WriteString+0x14>
    1560:	0c c0       	rjmp	.+24     	; 0x157a <LCD_WriteString+0x24>
    1562:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <LCD_WriteChar4Bit>
    1566:	cf 5f       	subi	r28, 0xFF	; 255
    1568:	02 c0       	rjmp	.+4      	; 0x156e <LCD_WriteString+0x18>
    156a:	8c 01       	movw	r16, r24
    156c:	c0 e0       	ldi	r28, 0x00	; 0
    156e:	f8 01       	movw	r30, r16
    1570:	ec 0f       	add	r30, r28
    1572:	f1 1d       	adc	r31, r1
    1574:	80 81       	ld	r24, Z
    1576:	81 11       	cpse	r24, r1
    1578:	f4 cf       	rjmp	.-24     	; 0x1562 <LCD_WriteString+0xc>
    157a:	cf 91       	pop	r28
    157c:	1f 91       	pop	r17
    157e:	0f 91       	pop	r16
    1580:	08 95       	ret

00001582 <LCD_ClearDisplay>:
 * @brief: Function to clear the LCD display
 * 
 */
void LCD_ClearDisplay(void)
{
    LCD_WriteCommand4Bit(CLEAR_DISPLAY);
    1582:	81 e0       	ldi	r24, 0x01	; 1
    1584:	0e 94 20 0a 	call	0x1440	; 0x1440 <LCD_WriteCommand4Bit>
    1588:	08 95       	ret

0000158a <LCD_Init>:
 * @brief: Function to initialize the LCD
 * 
 */
void LCD_Init(void)
{
    DIO_SetPinDirection(LCD_RS_PORT_ID, LCD_RS_PIN_ID, DIO_PIN_OUTPUT);
    158a:	41 e0       	ldi	r20, 0x01	; 1
    158c:	61 e0       	ldi	r22, 0x01	; 1
    158e:	81 e0       	ldi	r24, 0x01	; 1
    1590:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_RW_PORT_ID, LCD_RW_PIN_ID, DIO_PIN_OUTPUT);
    1594:	41 e0       	ldi	r20, 0x01	; 1
    1596:	62 e0       	ldi	r22, 0x02	; 2
    1598:	81 e0       	ldi	r24, 0x01	; 1
    159a:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_E_PORT_ID, LCD_E_PIN_ID, DIO_PIN_OUTPUT);
    159e:	41 e0       	ldi	r20, 0x01	; 1
    15a0:	63 e0       	ldi	r22, 0x03	; 3
    15a2:	81 e0       	ldi	r24, 0x01	; 1
    15a4:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D4_PIN_ID, DIO_PIN_OUTPUT);
    15a8:	41 e0       	ldi	r20, 0x01	; 1
    15aa:	64 e0       	ldi	r22, 0x04	; 4
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D5_PIN_ID, DIO_PIN_OUTPUT);
    15b2:	41 e0       	ldi	r20, 0x01	; 1
    15b4:	65 e0       	ldi	r22, 0x05	; 5
    15b6:	80 e0       	ldi	r24, 0x00	; 0
    15b8:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D6_PIN_ID, DIO_PIN_OUTPUT);
    15bc:	41 e0       	ldi	r20, 0x01	; 1
    15be:	66 e0       	ldi	r22, 0x06	; 6
    15c0:	80 e0       	ldi	r24, 0x00	; 0
    15c2:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_INPUT_PORTS_ID, LCD_D7_PIN_ID, DIO_PIN_OUTPUT);
    15c6:	41 e0       	ldi	r20, 0x01	; 1
    15c8:	67 e0       	ldi	r22, 0x07	; 7
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    15d0:	2f e7       	ldi	r18, 0x7F	; 127
    15d2:	85 eb       	ldi	r24, 0xB5	; 181
    15d4:	91 e0       	ldi	r25, 0x01	; 1
    15d6:	21 50       	subi	r18, 0x01	; 1
    15d8:	80 40       	sbci	r24, 0x00	; 0
    15da:	90 40       	sbci	r25, 0x00	; 0
    15dc:	e1 f7       	brne	.-8      	; 0x15d6 <LCD_Init+0x4c>
    15de:	00 c0       	rjmp	.+0      	; 0x15e0 <LCD_Init+0x56>
    15e0:	00 00       	nop
    _delay_ms(35);

    LCD_WriteCommand4Bit(MODE_4_BIT);
    15e2:	82 e0       	ldi	r24, 0x02	; 2
    15e4:	0e 94 20 0a 	call	0x1440	; 0x1440 <LCD_WriteCommand4Bit>
    15e8:	8f e9       	ldi	r24, 0x9F	; 159
    15ea:	9f e0       	ldi	r25, 0x0F	; 15
    15ec:	01 97       	sbiw	r24, 0x01	; 1
    15ee:	f1 f7       	brne	.-4      	; 0x15ec <LCD_Init+0x62>
    15f0:	00 c0       	rjmp	.+0      	; 0x15f2 <LCD_Init+0x68>
    15f2:	00 00       	nop
    _delay_ms(1);
    
    LCD_WriteCommand4Bit(FUNCTION_SET_COMMAND);
    15f4:	88 e2       	ldi	r24, 0x28	; 40
    15f6:	0e 94 20 0a 	call	0x1440	; 0x1440 <LCD_WriteCommand4Bit>
    15fa:	8f e9       	ldi	r24, 0x9F	; 159
    15fc:	9f e0       	ldi	r25, 0x0F	; 15
    15fe:	01 97       	sbiw	r24, 0x01	; 1
    1600:	f1 f7       	brne	.-4      	; 0x15fe <LCD_Init+0x74>
    1602:	00 c0       	rjmp	.+0      	; 0x1604 <LCD_Init+0x7a>
    1604:	00 00       	nop
    _delay_ms(1);

    LCD_WriteCommand4Bit(DISPLAY_SET_COMMAND);
    1606:	8f e0       	ldi	r24, 0x0F	; 15
    1608:	0e 94 20 0a 	call	0x1440	; 0x1440 <LCD_WriteCommand4Bit>
    160c:	8f e9       	ldi	r24, 0x9F	; 159
    160e:	9f e0       	ldi	r25, 0x0F	; 15
    1610:	01 97       	sbiw	r24, 0x01	; 1
    1612:	f1 f7       	brne	.-4      	; 0x1610 <LCD_Init+0x86>
    1614:	00 c0       	rjmp	.+0      	; 0x1616 <LCD_Init+0x8c>
    1616:	00 00       	nop
    _delay_ms(1);

    LCD_ClearDisplay();
    1618:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    161c:	8f e3       	ldi	r24, 0x3F	; 63
    161e:	9f e1       	ldi	r25, 0x1F	; 31
    1620:	01 97       	sbiw	r24, 0x01	; 1
    1622:	f1 f7       	brne	.-4      	; 0x1620 <LCD_Init+0x96>
    1624:	00 c0       	rjmp	.+0      	; 0x1626 <LCD_Init+0x9c>
    1626:	00 00       	nop
    _delay_ms(2);

    LCD_WriteCommand4Bit(FIRST_LINE_OFFSET);
    1628:	80 e8       	ldi	r24, 0x80	; 128
    162a:	0e 94 20 0a 	call	0x1440	; 0x1440 <LCD_WriteCommand4Bit>
    162e:	8f e3       	ldi	r24, 0x3F	; 63
    1630:	9f e1       	ldi	r25, 0x1F	; 31
    1632:	01 97       	sbiw	r24, 0x01	; 1
    1634:	f1 f7       	brne	.-4      	; 0x1632 <LCD_Init+0xa8>
    1636:	00 c0       	rjmp	.+0      	; 0x1638 <LCD_Init+0xae>
    1638:	00 00       	nop
    163a:	08 95       	ret

0000163c <LED_On>:
 * 
 * @param Copy_u8PortID: Port ID to which the LED is connected
 * @param Copy_u8PinID: Pin ID to which the LED is connected
 */
void LED_On(u8 Copy_u8PortID, u8 Copy_u8PinID)
{
    163c:	0f 93       	push	r16
    163e:	1f 93       	push	r17
    1640:	cf 93       	push	r28
    1642:	df 93       	push	r29
    1644:	1f 92       	push	r1
    1646:	cd b7       	in	r28, 0x3d	; 61
    1648:	de b7       	in	r29, 0x3e	; 62
    if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
    164a:	84 30       	cpi	r24, 0x04	; 4
    164c:	d8 f4       	brcc	.+54     	; 0x1684 <LED_On+0x48>
    {
        if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
    164e:	68 30       	cpi	r22, 0x08	; 8
    1650:	c8 f4       	brcc	.+50     	; 0x1684 <LED_On+0x48>
    1652:	06 2f       	mov	r16, r22
    1654:	18 2f       	mov	r17, r24
        {
            u8 Loc_u8PinDirStatus = 7;
    1656:	87 e0       	ldi	r24, 0x07	; 7
    1658:	89 83       	std	Y+1, r24	; 0x01
            DIO_ReadDDRPinValue(Copy_u8PortID, Copy_u8PinID, &Loc_u8PinDirStatus);
    165a:	ae 01       	movw	r20, r28
    165c:	4f 5f       	subi	r20, 0xFF	; 255
    165e:	5f 4f       	sbci	r21, 0xFF	; 255
    1660:	81 2f       	mov	r24, r17
    1662:	0e 94 48 03 	call	0x690	; 0x690 <DIO_ReadDDRPinValue>
            if(Loc_u8PinDirStatus == DIO_PIN_OUTPUT || Loc_u8PinDirStatus == DIO_PIN_INPUT)
    1666:	89 81       	ldd	r24, Y+1	; 0x01
    1668:	82 30       	cpi	r24, 0x02	; 2
    166a:	60 f4       	brcc	.+24     	; 0x1684 <LED_On+0x48>
            {
                if(Loc_u8PinDirStatus == DIO_PIN_INPUT)
    166c:	81 11       	cpse	r24, r1
    166e:	05 c0       	rjmp	.+10     	; 0x167a <LED_On+0x3e>
                {
                    DIO_SetPinDirection(Copy_u8PortID, Copy_u8PinID, DIO_PIN_OUTPUT);
    1670:	41 e0       	ldi	r20, 0x01	; 1
    1672:	60 2f       	mov	r22, r16
    1674:	81 2f       	mov	r24, r17
    1676:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
                else
                {
                    /*Do nothing*/
                }

                DIO_SetPinValue(Copy_u8PortID, Copy_u8PinID, DIO_PIN_HIGH);
    167a:	41 e0       	ldi	r20, 0x01	; 1
    167c:	60 2f       	mov	r22, r16
    167e:	81 2f       	mov	r24, r17
    1680:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    }
    else
    {
        /*Do nothing*/
    }
}
    1684:	0f 90       	pop	r0
    1686:	df 91       	pop	r29
    1688:	cf 91       	pop	r28
    168a:	1f 91       	pop	r17
    168c:	0f 91       	pop	r16
    168e:	08 95       	ret

00001690 <LED_Off>:
 * 
 * @param Copy_u8PortID:  Port ID to which the LED is connected 
 * @param Copy_u8PinID: Pin ID to which the LED is connected
 */
void LED_Off(u8 Copy_u8PortID, u8 Copy_u8PinID)
{
    1690:	0f 93       	push	r16
    1692:	1f 93       	push	r17
    1694:	cf 93       	push	r28
    1696:	df 93       	push	r29
    1698:	1f 92       	push	r1
    169a:	cd b7       	in	r28, 0x3d	; 61
    169c:	de b7       	in	r29, 0x3e	; 62
        if(Copy_u8PortID >= DIO_PORTA && Copy_u8PortID <= DIO_PORTD)
    169e:	84 30       	cpi	r24, 0x04	; 4
    16a0:	d8 f4       	brcc	.+54     	; 0x16d8 <LED_Off+0x48>
    {
        if(Copy_u8PinID >= DIO_PIN0 && Copy_u8PinID <= DIO_PIN7)
    16a2:	68 30       	cpi	r22, 0x08	; 8
    16a4:	c8 f4       	brcc	.+50     	; 0x16d8 <LED_Off+0x48>
    16a6:	06 2f       	mov	r16, r22
    16a8:	18 2f       	mov	r17, r24
        {
            u8 Loc_u8PinDirStatus = 7;
    16aa:	87 e0       	ldi	r24, 0x07	; 7
    16ac:	89 83       	std	Y+1, r24	; 0x01
            DIO_ReadDDRPinValue(Copy_u8PortID, Copy_u8PinID, &Loc_u8PinDirStatus);
    16ae:	ae 01       	movw	r20, r28
    16b0:	4f 5f       	subi	r20, 0xFF	; 255
    16b2:	5f 4f       	sbci	r21, 0xFF	; 255
    16b4:	81 2f       	mov	r24, r17
    16b6:	0e 94 48 03 	call	0x690	; 0x690 <DIO_ReadDDRPinValue>
            if(Loc_u8PinDirStatus == DIO_PIN_HIGH || Loc_u8PinDirStatus == DIO_PIN_LOW)
    16ba:	89 81       	ldd	r24, Y+1	; 0x01
    16bc:	82 30       	cpi	r24, 0x02	; 2
    16be:	60 f4       	brcc	.+24     	; 0x16d8 <LED_Off+0x48>
            {
                if(Loc_u8PinDirStatus == DIO_PIN_LOW)
    16c0:	81 11       	cpse	r24, r1
    16c2:	05 c0       	rjmp	.+10     	; 0x16ce <LED_Off+0x3e>
                {
                    DIO_SetPinDirection(Copy_u8PortID, Copy_u8PinID, DIO_PIN_OUTPUT);
    16c4:	41 e0       	ldi	r20, 0x01	; 1
    16c6:	60 2f       	mov	r22, r16
    16c8:	81 2f       	mov	r24, r17
    16ca:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
                }
                else
                {
                    /*Do nothing*/
                }
                DIO_SetPinValue(Copy_u8PortID, Copy_u8PinID, DIO_PIN_LOW);   
    16ce:	40 e0       	ldi	r20, 0x00	; 0
    16d0:	60 2f       	mov	r22, r16
    16d2:	81 2f       	mov	r24, r17
    16d4:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    }
    else
    {
        /*Do nothing*/
    }
}
    16d8:	0f 90       	pop	r0
    16da:	df 91       	pop	r29
    16dc:	cf 91       	pop	r28
    16de:	1f 91       	pop	r17
    16e0:	0f 91       	pop	r16
    16e2:	08 95       	ret

000016e4 <main>:
#include "HC05_Interface.h"

#define F_CPU 16000000UL
#include <util/delay.h>
int main(void)
{
    16e4:	cf 93       	push	r28
    16e6:	df 93       	push	r29
    16e8:	00 d0       	rcall	.+0      	; 0x16ea <main+0x6>
    16ea:	cd b7       	in	r28, 0x3d	; 61
    16ec:	de b7       	in	r29, 0x3e	; 62
	u8 Loc_u8Value = 0;
    16ee:	19 82       	std	Y+1, r1	; 0x01
	LCD_Init();
    16f0:	0e 94 c5 0a 	call	0x158a	; 0x158a <LCD_Init>
	SRVM_Init();
    16f4:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <SRVM_Init>
	ADC_Init();
    16f8:	0e 94 56 00 	call	0xac	; 0xac <ADC_Init>
	KPD_Init();
    16fc:	0e 94 3c 09 	call	0x1278	; 0x1278 <KPD_Init>
	
	TMR_Timer2Init();
    1700:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <TMR_Timer2Init>
	TMR_Timer2Start();
    1704:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
	DIO_SetPinDirection(DIO_PORTD, DIO_PIN0, DIO_PIN_INPUT); //Rx
    1708:	40 e0       	ldi	r20, 0x00	; 0
    170a:	60 e0       	ldi	r22, 0x00	; 0
    170c:	83 e0       	ldi	r24, 0x03	; 3
    170e:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PORTD, DIO_PIN1, DIO_PIN_OUTPUT); //Tx
    1712:	41 e0       	ldi	r20, 0x01	; 1
    1714:	61 e0       	ldi	r22, 0x01	; 1
    1716:	83 e0       	ldi	r24, 0x03	; 3
    1718:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PORTC, DIO_PIN2, DIO_PIN_OUTPUT);
    171c:	41 e0       	ldi	r20, 0x01	; 1
    171e:	62 e0       	ldi	r22, 0x02	; 2
    1720:	82 e0       	ldi	r24, 0x02	; 2
    1722:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
	GI_Enable();
    1726:	0e 94 c3 03 	call	0x786	; 0x786 <GI_Enable>
	UART_RxCompleteSetCallback(HC05_AdminUserInterface);
    172a:	84 ea       	ldi	r24, 0xA4	; 164
    172c:	95 e0       	ldi	r25, 0x05	; 5
    172e:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <UART_RxCompleteSetCallback>
	UART_Init();
    1732:	0e 94 1d 0e 	call	0x1c3a	; 0x1c3a <UART_Init>
	Internal_EEPROM_ReadByte(HC05_ADMIN_SAVED_STATUS_MEM_ADDRESS, &Loc_u8Value);
    1736:	be 01       	movw	r22, r28
    1738:	6f 5f       	subi	r22, 0xFF	; 255
    173a:	7f 4f       	sbci	r23, 0xFF	; 255
    173c:	80 e5       	ldi	r24, 0x50	; 80
    173e:	90 e0       	ldi	r25, 0x00	; 0
    1740:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
	if (1 != Loc_u8Value)
    1744:	89 81       	ldd	r24, Y+1	; 0x01
    1746:	81 30       	cpi	r24, 0x01	; 1
    1748:	89 f0       	breq	.+34     	; 0x176c <main+0x88>
	{
		LCD_WriteString("First Entry");
    174a:	85 e6       	ldi	r24, 0x65	; 101
    174c:	96 e0       	ldi	r25, 0x06	; 6
    174e:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1752:	2f ef       	ldi	r18, 0xFF	; 255
    1754:	87 ea       	ldi	r24, 0xA7	; 167
    1756:	91 e6       	ldi	r25, 0x61	; 97
    1758:	21 50       	subi	r18, 0x01	; 1
    175a:	80 40       	sbci	r24, 0x00	; 0
    175c:	90 40       	sbci	r25, 0x00	; 0
    175e:	e1 f7       	brne	.-8      	; 0x1758 <main+0x74>
    1760:	00 c0       	rjmp	.+0      	; 0x1762 <main+0x7e>
    1762:	00 00       	nop
		_delay_ms(2000);
		LCD_ClearDisplay();
    1764:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
		HC05_AdminUsernamePasswordSaver();
    1768:	0e 94 d7 03 	call	0x7ae	; 0x7ae <HC05_AdminUsernamePasswordSaver>
	}
	USER_PROGRAM_START();
    176c:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <USER_PROGRAM_START>
	HC05_WelcomeMessage();
    1770:	0e 94 c7 03 	call	0x78e	; 0x78e <HC05_WelcomeMessage>
	u8 user_input = KPD_NOT_PRESSED;
    1774:	8f ef       	ldi	r24, 0xFF	; 255
    1776:	8a 83       	std	Y+2, r24	; 0x02
    while (1) 
    {
		LCD_WriteString("WANT TO");
    1778:	81 e7       	ldi	r24, 0x71	; 113
    177a:	96 e0       	ldi	r25, 0x06	; 6
    177c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
		LCD_SetCursorPosition(LCD_SECOND_ROW, 0);
    1780:	60 e0       	ldi	r22, 0x00	; 0
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <LCD_SetCursorPosition>
		LCD_WriteString("LOGIN?");
    1788:	89 e7       	ldi	r24, 0x79	; 121
    178a:	96 e0       	ldi	r25, 0x06	; 6
    178c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1790:	2f ef       	ldi	r18, 0xFF	; 255
    1792:	83 ed       	ldi	r24, 0xD3	; 211
    1794:	90 e3       	ldi	r25, 0x30	; 48
    1796:	21 50       	subi	r18, 0x01	; 1
    1798:	80 40       	sbci	r24, 0x00	; 0
    179a:	90 40       	sbci	r25, 0x00	; 0
    179c:	e1 f7       	brne	.-8      	; 0x1796 <main+0xb2>
    179e:	00 c0       	rjmp	.+0      	; 0x17a0 <main+0xbc>
    17a0:	00 00       	nop
		_delay_ms(1000);
		LCD_ClearDisplay();
    17a2:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
		LCD_WriteString("1.Yes    2.No");
    17a6:	80 e8       	ldi	r24, 0x80	; 128
    17a8:	96 e0       	ldi	r25, 0x06	; 6
    17aa:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
		LCD_SetCursorPosition(LCD_SECOND_ROW, 0);
    17ae:	60 e0       	ldi	r22, 0x00	; 0
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <LCD_SetCursorPosition>
		while(1)
		{
			if(user_input==KPD_NOT_PRESSED)
    17b6:	8a 81       	ldd	r24, Y+2	; 0x02
    17b8:	8f 3f       	cpi	r24, 0xFF	; 255
    17ba:	29 f4       	brne	.+10     	; 0x17c6 <main+0xe2>
			{
				KPD_GetValue(&user_input);
    17bc:	ce 01       	movw	r24, r28
    17be:	02 96       	adiw	r24, 0x02	; 2
    17c0:	0e 94 89 09 	call	0x1312	; 0x1312 <KPD_GetValue>
			}
			else
			{
				break;
			}
		}
    17c4:	f8 cf       	rjmp	.-16     	; 0x17b6 <main+0xd2>
		if(user_input == '1')
    17c6:	81 33       	cpi	r24, 0x31	; 49
    17c8:	19 f4       	brne	.+6      	; 0x17d0 <main+0xec>
		{
			USER_APP();
    17ca:	0e 94 88 12 	call	0x2510	; 0x2510 <USER_APP>
    17ce:	d4 cf       	rjmp	.-88     	; 0x1778 <main+0x94>
		}
		else if(user_input == '2')
    17d0:	82 33       	cpi	r24, 0x32	; 50
    17d2:	91 f6       	brne	.-92     	; 0x1778 <main+0x94>
		{
			user_input = KPD_NOT_PRESSED;
    17d4:	8f ef       	ldi	r24, 0xFF	; 255
    17d6:	8a 83       	std	Y+2, r24	; 0x02
			AC_Auto();
    17d8:	0e 94 94 00 	call	0x128	; 0x128 <AC_Auto>
			HC05_ShowRunningDevices();
    17dc:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <HC05_ShowRunningDevices>
    17e0:	cb cf       	rjmp	.-106    	; 0x1778 <main+0x94>

000017e2 <SRVM_Init>:
 * @brief: Function to initialize the Servo motor Peripheral
 * 
 */
void SRVM_Init(void)
{
    TMR_Timer1Init();
    17e2:	0e 94 9b 0c 	call	0x1936	; 0x1936 <TMR_Timer1Init>
    TMR_Timer1SetFastPWMFreq(50);
    17e6:	62 e3       	ldi	r22, 0x32	; 50
    17e8:	70 e0       	ldi	r23, 0x00	; 0
    17ea:	80 e0       	ldi	r24, 0x00	; 0
    17ec:	90 e0       	ldi	r25, 0x00	; 0
    17ee:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <TMR_Timer1SetFastPWMFreq>
    TMR_Timer1Start();
    17f2:	0e 94 b4 0c 	call	0x1968	; 0x1968 <TMR_Timer1Start>
    17f6:	08 95       	ret

000017f8 <SRVM_SetRotationAngle>:
 * 
 * @param Copy_u8RotationAngleSign: Sign of angle of servo motor 
 * @param Copy_u8RotationAngle: : Angle of Servo motor 
 */
void SRVM_SetRotationAngle(u8 Copy_u8RotationAngleSign,u8 Copy_u8RotationAngle)
{
    17f8:	0f 93       	push	r16
    17fa:	1f 93       	push	r17
    
                  540 + (2 x Angle)
    DutyCycle = --------------------  Note: Angle can be positive or negative
                        72
*/
    if((Copy_u8RotationAngle >= 0) && (Copy_u8RotationAngle <= 90))
    17fc:	6b 35       	cpi	r22, 0x5B	; 91
    17fe:	08 f0       	brcs	.+2      	; 0x1802 <SRVM_SetRotationAngle+0xa>
    1800:	45 c0       	rjmp	.+138    	; 0x188c <SRVM_SetRotationAngle+0x94>
    {
        if(Copy_u8RotationAngle == 0)
    1802:	61 11       	cpse	r22, r1
    1804:	04 c0       	rjmp	.+8      	; 0x180e <SRVM_SetRotationAngle+0x16>
        {
            TMR_Timer1SetPWMDutyCycle(SRVM_OC_CONNECTED, TMR_TIMER1_ZERO_POSITION);
    1806:	81 e0       	ldi	r24, 0x01	; 1
    1808:	0e 94 c8 0c 	call	0x1990	; 0x1990 <TMR_Timer1SetPWMDutyCycle>
    180c:	3f c0       	rjmp	.+126    	; 0x188c <SRVM_SetRotationAngle+0x94>
        }
        else
        {
            u8 Loc_u8DutyCycle = 0;
            switch(Copy_u8RotationAngleSign)
    180e:	81 30       	cpi	r24, 0x01	; 1
    1810:	19 f0       	breq	.+6      	; 0x1818 <SRVM_SetRotationAngle+0x20>
    1812:	82 30       	cpi	r24, 0x02	; 2
    1814:	d1 f0       	breq	.+52     	; 0x184a <SRVM_SetRotationAngle+0x52>
    1816:	3a c0       	rjmp	.+116    	; 0x188c <SRVM_SetRotationAngle+0x94>
            {
                case SRVM_ANGLE_POSITIVE:
                {
                    Loc_u8DutyCycle = (u32)(((u32)(540 + (u32)(2 * (u32)Copy_u8RotationAngle))) / 72);
    1818:	86 2f       	mov	r24, r22
    181a:	90 e0       	ldi	r25, 0x00	; 0
    181c:	a0 e0       	ldi	r26, 0x00	; 0
    181e:	b0 e0       	ldi	r27, 0x00	; 0
    1820:	82 5f       	subi	r24, 0xF2	; 242
    1822:	9e 4f       	sbci	r25, 0xFE	; 254
    1824:	af 4f       	sbci	r26, 0xFF	; 255
    1826:	bf 4f       	sbci	r27, 0xFF	; 255
    1828:	bc 01       	movw	r22, r24
    182a:	cd 01       	movw	r24, r26
    182c:	66 0f       	add	r22, r22
    182e:	77 1f       	adc	r23, r23
    1830:	88 1f       	adc	r24, r24
    1832:	99 1f       	adc	r25, r25
    1834:	28 e4       	ldi	r18, 0x48	; 72
    1836:	30 e0       	ldi	r19, 0x00	; 0
    1838:	40 e0       	ldi	r20, 0x00	; 0
    183a:	50 e0       	ldi	r21, 0x00	; 0
    183c:	0e 94 96 12 	call	0x252c	; 0x252c <__udivmodsi4>
                    TMR_Timer1SetPWMDutyCycle(SRVM_OC_CONNECTED, Loc_u8DutyCycle);
    1840:	62 2f       	mov	r22, r18
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	0e 94 c8 0c 	call	0x1990	; 0x1990 <TMR_Timer1SetPWMDutyCycle>
                    break;
    1848:	21 c0       	rjmp	.+66     	; 0x188c <SRVM_SetRotationAngle+0x94>
                }
                case SRVM_ANGLE_NEGATIVE:
                {
                    Loc_u8DutyCycle = (u32)(((u32)(540 - (u32)(2 * (u32)Copy_u8RotationAngle))) / 72);
    184a:	86 2f       	mov	r24, r22
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	a0 e0       	ldi	r26, 0x00	; 0
    1850:	b0 e0       	ldi	r27, 0x00	; 0
    1852:	00 e0       	ldi	r16, 0x00	; 0
    1854:	10 e0       	ldi	r17, 0x00	; 0
    1856:	98 01       	movw	r18, r16
    1858:	08 1b       	sub	r16, r24
    185a:	19 0b       	sbc	r17, r25
    185c:	2a 0b       	sbc	r18, r26
    185e:	3b 0b       	sbc	r19, r27
    1860:	d9 01       	movw	r26, r18
    1862:	c8 01       	movw	r24, r16
    1864:	88 0f       	add	r24, r24
    1866:	99 1f       	adc	r25, r25
    1868:	aa 1f       	adc	r26, r26
    186a:	bb 1f       	adc	r27, r27
    186c:	bc 01       	movw	r22, r24
    186e:	cd 01       	movw	r24, r26
    1870:	64 5e       	subi	r22, 0xE4	; 228
    1872:	7d 4f       	sbci	r23, 0xFD	; 253
    1874:	8f 4f       	sbci	r24, 0xFF	; 255
    1876:	9f 4f       	sbci	r25, 0xFF	; 255
    1878:	28 e4       	ldi	r18, 0x48	; 72
    187a:	30 e0       	ldi	r19, 0x00	; 0
    187c:	40 e0       	ldi	r20, 0x00	; 0
    187e:	50 e0       	ldi	r21, 0x00	; 0
    1880:	0e 94 96 12 	call	0x252c	; 0x252c <__udivmodsi4>
                    TMR_Timer1SetPWMDutyCycle(SRVM_OC_CONNECTED, Loc_u8DutyCycle);
    1884:	62 2f       	mov	r22, r18
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	0e 94 c8 0c 	call	0x1990	; 0x1990 <TMR_Timer1SetPWMDutyCycle>
    }
    else
    {
        /*Do nothing*/
    }
    188c:	1f 91       	pop	r17
    188e:	0f 91       	pop	r16
    1890:	08 95       	ret

00001892 <__vector_10>:
 */
void TMR_Timer2_OVF_SetCallBack     (Ptr_to_func_t P_funcCallBack)
{
    if(P_funcCallBack != NULL)
    {
        TMR_Timer2_OVF_PCallBack = P_funcCallBack;
    1892:	1f 92       	push	r1
    1894:	0f 92       	push	r0
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	0f 92       	push	r0
    189a:	11 24       	eor	r1, r1
    189c:	2f 93       	push	r18
    189e:	3f 93       	push	r19
    18a0:	4f 93       	push	r20
    18a2:	5f 93       	push	r21
    18a4:	6f 93       	push	r22
    18a6:	7f 93       	push	r23
    18a8:	8f 93       	push	r24
    18aa:	9f 93       	push	r25
    18ac:	af 93       	push	r26
    18ae:	bf 93       	push	r27
    18b0:	ef 93       	push	r30
    18b2:	ff 93       	push	r31
    18b4:	e0 91 20 08 	lds	r30, 0x0820	; 0x800820 <TMR_Timer0_CTC_PCallBack>
    18b8:	f0 91 21 08 	lds	r31, 0x0821	; 0x800821 <TMR_Timer0_CTC_PCallBack+0x1>
    18bc:	30 97       	sbiw	r30, 0x00	; 0
    18be:	09 f0       	breq	.+2      	; 0x18c2 <__vector_10+0x30>
    18c0:	09 95       	icall
    18c2:	ff 91       	pop	r31
    18c4:	ef 91       	pop	r30
    18c6:	bf 91       	pop	r27
    18c8:	af 91       	pop	r26
    18ca:	9f 91       	pop	r25
    18cc:	8f 91       	pop	r24
    18ce:	7f 91       	pop	r23
    18d0:	6f 91       	pop	r22
    18d2:	5f 91       	pop	r21
    18d4:	4f 91       	pop	r20
    18d6:	3f 91       	pop	r19
    18d8:	2f 91       	pop	r18
    18da:	0f 90       	pop	r0
    18dc:	0f be       	out	0x3f, r0	; 63
    18de:	0f 90       	pop	r0
    18e0:	1f 90       	pop	r1
    18e2:	18 95       	reti

000018e4 <__vector_11>:
    18e4:	1f 92       	push	r1
    18e6:	0f 92       	push	r0
    18e8:	0f b6       	in	r0, 0x3f	; 63
    18ea:	0f 92       	push	r0
    18ec:	11 24       	eor	r1, r1
    18ee:	2f 93       	push	r18
    18f0:	3f 93       	push	r19
    18f2:	4f 93       	push	r20
    18f4:	5f 93       	push	r21
    18f6:	6f 93       	push	r22
    18f8:	7f 93       	push	r23
    18fa:	8f 93       	push	r24
    18fc:	9f 93       	push	r25
    18fe:	af 93       	push	r26
    1900:	bf 93       	push	r27
    1902:	ef 93       	push	r30
    1904:	ff 93       	push	r31
    1906:	e0 91 1e 08 	lds	r30, 0x081E	; 0x80081e <TMR_Timer0_OVF_PCallBack>
    190a:	f0 91 1f 08 	lds	r31, 0x081F	; 0x80081f <TMR_Timer0_OVF_PCallBack+0x1>
    190e:	30 97       	sbiw	r30, 0x00	; 0
    1910:	09 f0       	breq	.+2      	; 0x1914 <__vector_11+0x30>
    1912:	09 95       	icall
    1914:	ff 91       	pop	r31
    1916:	ef 91       	pop	r30
    1918:	bf 91       	pop	r27
    191a:	af 91       	pop	r26
    191c:	9f 91       	pop	r25
    191e:	8f 91       	pop	r24
    1920:	7f 91       	pop	r23
    1922:	6f 91       	pop	r22
    1924:	5f 91       	pop	r21
    1926:	4f 91       	pop	r20
    1928:	3f 91       	pop	r19
    192a:	2f 91       	pop	r18
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63
    1930:	0f 90       	pop	r0
    1932:	1f 90       	pop	r1
    1934:	18 95       	reti

00001936 <TMR_Timer1Init>:
    1936:	81 b3       	in	r24, 0x11	; 17
    1938:	80 62       	ori	r24, 0x20	; 32
    193a:	81 bb       	out	0x11, r24	; 17
    193c:	81 b3       	in	r24, 0x11	; 17
    193e:	80 61       	ori	r24, 0x10	; 16
    1940:	81 bb       	out	0x11, r24	; 17
    1942:	8f b5       	in	r24, 0x2f	; 47
    1944:	8e 7f       	andi	r24, 0xFE	; 254
    1946:	8f bd       	out	0x2f, r24	; 47
    1948:	8f b5       	in	r24, 0x2f	; 47
    194a:	82 60       	ori	r24, 0x02	; 2
    194c:	8f bd       	out	0x2f, r24	; 47
    194e:	8e b5       	in	r24, 0x2e	; 46
    1950:	88 60       	ori	r24, 0x08	; 8
    1952:	8e bd       	out	0x2e, r24	; 46
    1954:	8e b5       	in	r24, 0x2e	; 46
    1956:	80 61       	ori	r24, 0x10	; 16
    1958:	8e bd       	out	0x2e, r24	; 46
    195a:	8f b5       	in	r24, 0x2f	; 47
    195c:	8f 7b       	andi	r24, 0xBF	; 191
    195e:	8f bd       	out	0x2f, r24	; 47
    1960:	8f b5       	in	r24, 0x2f	; 47
    1962:	80 68       	ori	r24, 0x80	; 128
    1964:	8f bd       	out	0x2f, r24	; 47
    1966:	08 95       	ret

00001968 <TMR_Timer1Start>:
    1968:	8e b5       	in	r24, 0x2e	; 46
    196a:	81 60       	ori	r24, 0x01	; 1
    196c:	8e bd       	out	0x2e, r24	; 46
    196e:	8e b5       	in	r24, 0x2e	; 46
    1970:	82 60       	ori	r24, 0x02	; 2
    1972:	8e bd       	out	0x2e, r24	; 46
    1974:	8e b5       	in	r24, 0x2e	; 46
    1976:	8b 7f       	andi	r24, 0xFB	; 251
    1978:	8e bd       	out	0x2e, r24	; 46
    197a:	08 95       	ret

0000197c <TMR_Timer1Stop>:
    197c:	8e b5       	in	r24, 0x2e	; 46
    197e:	8e 7f       	andi	r24, 0xFE	; 254
    1980:	8e bd       	out	0x2e, r24	; 46
    1982:	8e b5       	in	r24, 0x2e	; 46
    1984:	8d 7f       	andi	r24, 0xFD	; 253
    1986:	8e bd       	out	0x2e, r24	; 46
    1988:	8e b5       	in	r24, 0x2e	; 46
    198a:	8b 7f       	andi	r24, 0xFB	; 251
    198c:	8e bd       	out	0x2e, r24	; 46
    198e:	08 95       	ret

00001990 <TMR_Timer1SetPWMDutyCycle>:
    1990:	cf 93       	push	r28
    1992:	c8 2f       	mov	r28, r24
    1994:	65 36       	cpi	r22, 0x65	; 101
    1996:	f0 f4       	brcc	.+60     	; 0x19d4 <TMR_Timer1SetPWMDutyCycle+0x44>
    1998:	66 23       	and	r22, r22
    199a:	81 f0       	breq	.+32     	; 0x19bc <TMR_Timer1SetPWMDutyCycle+0x2c>
    199c:	a6 b5       	in	r26, 0x26	; 38
    199e:	b7 b5       	in	r27, 0x27	; 39
    19a0:	11 96       	adiw	r26, 0x01	; 1
    19a2:	26 2f       	mov	r18, r22
    19a4:	30 e0       	ldi	r19, 0x00	; 0
    19a6:	0e 94 be 12 	call	0x257c	; 0x257c <__umulhisi3>
    19aa:	24 e6       	ldi	r18, 0x64	; 100
    19ac:	30 e0       	ldi	r19, 0x00	; 0
    19ae:	40 e0       	ldi	r20, 0x00	; 0
    19b0:	50 e0       	ldi	r21, 0x00	; 0
    19b2:	0e 94 96 12 	call	0x252c	; 0x252c <__udivmodsi4>
    19b6:	21 50       	subi	r18, 0x01	; 1
    19b8:	31 09       	sbc	r19, r1
    19ba:	02 c0       	rjmp	.+4      	; 0x19c0 <TMR_Timer1SetPWMDutyCycle+0x30>
    19bc:	26 e7       	ldi	r18, 0x76	; 118
    19be:	31 e0       	ldi	r19, 0x01	; 1
    19c0:	c1 30       	cpi	r28, 0x01	; 1
    19c2:	19 f0       	breq	.+6      	; 0x19ca <TMR_Timer1SetPWMDutyCycle+0x3a>
    19c4:	c2 30       	cpi	r28, 0x02	; 2
    19c6:	21 f0       	breq	.+8      	; 0x19d0 <TMR_Timer1SetPWMDutyCycle+0x40>
    19c8:	05 c0       	rjmp	.+10     	; 0x19d4 <TMR_Timer1SetPWMDutyCycle+0x44>
    19ca:	3b bd       	out	0x2b, r19	; 43
    19cc:	2a bd       	out	0x2a, r18	; 42
    19ce:	02 c0       	rjmp	.+4      	; 0x19d4 <TMR_Timer1SetPWMDutyCycle+0x44>
    19d0:	39 bd       	out	0x29, r19	; 41
    19d2:	28 bd       	out	0x28, r18	; 40
    19d4:	cf 91       	pop	r28
    19d6:	08 95       	ret

000019d8 <TMR_Timer1SetFastPWMFreq>:
    19d8:	61 30       	cpi	r22, 0x01	; 1
    19da:	24 e2       	ldi	r18, 0x24	; 36
    19dc:	72 07       	cpc	r23, r18
    19de:	24 ef       	ldi	r18, 0xF4	; 244
    19e0:	82 07       	cpc	r24, r18
    19e2:	91 05       	cpc	r25, r1
    19e4:	30 f5       	brcc	.+76     	; 0x1a32 <TMR_Timer1SetFastPWMFreq+0x5a>
    19e6:	dc 01       	movw	r26, r24
    19e8:	cb 01       	movw	r24, r22
    19ea:	88 0f       	add	r24, r24
    19ec:	99 1f       	adc	r25, r25
    19ee:	aa 1f       	adc	r26, r26
    19f0:	bb 1f       	adc	r27, r27
    19f2:	88 0f       	add	r24, r24
    19f4:	99 1f       	adc	r25, r25
    19f6:	aa 1f       	adc	r26, r26
    19f8:	bb 1f       	adc	r27, r27
    19fa:	88 0f       	add	r24, r24
    19fc:	99 1f       	adc	r25, r25
    19fe:	aa 1f       	adc	r26, r26
    1a00:	bb 1f       	adc	r27, r27
    1a02:	88 0f       	add	r24, r24
    1a04:	99 1f       	adc	r25, r25
    1a06:	aa 1f       	adc	r26, r26
    1a08:	bb 1f       	adc	r27, r27
    1a0a:	9c 01       	movw	r18, r24
    1a0c:	ad 01       	movw	r20, r26
    1a0e:	22 0f       	add	r18, r18
    1a10:	33 1f       	adc	r19, r19
    1a12:	44 1f       	adc	r20, r20
    1a14:	55 1f       	adc	r21, r21
    1a16:	22 0f       	add	r18, r18
    1a18:	33 1f       	adc	r19, r19
    1a1a:	44 1f       	adc	r20, r20
    1a1c:	55 1f       	adc	r21, r21
    1a1e:	60 e0       	ldi	r22, 0x00	; 0
    1a20:	74 e2       	ldi	r23, 0x24	; 36
    1a22:	84 ef       	ldi	r24, 0xF4	; 244
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	0e 94 96 12 	call	0x252c	; 0x252c <__udivmodsi4>
    1a2a:	21 50       	subi	r18, 0x01	; 1
    1a2c:	31 09       	sbc	r19, r1
    1a2e:	37 bd       	out	0x27, r19	; 39
    1a30:	26 bd       	out	0x26, r18	; 38
    1a32:	08 95       	ret

00001a34 <__vector_7>:
    1a34:	1f 92       	push	r1
    1a36:	0f 92       	push	r0
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	0f 92       	push	r0
    1a3c:	11 24       	eor	r1, r1
    1a3e:	2f 93       	push	r18
    1a40:	3f 93       	push	r19
    1a42:	4f 93       	push	r20
    1a44:	5f 93       	push	r21
    1a46:	6f 93       	push	r22
    1a48:	7f 93       	push	r23
    1a4a:	8f 93       	push	r24
    1a4c:	9f 93       	push	r25
    1a4e:	af 93       	push	r26
    1a50:	bf 93       	push	r27
    1a52:	ef 93       	push	r30
    1a54:	ff 93       	push	r31
    1a56:	e0 91 1a 08 	lds	r30, 0x081A	; 0x80081a <TMR_Timer1_CTC1A_PCallBack>
    1a5a:	f0 91 1b 08 	lds	r31, 0x081B	; 0x80081b <TMR_Timer1_CTC1A_PCallBack+0x1>
    1a5e:	30 97       	sbiw	r30, 0x00	; 0
    1a60:	09 f0       	breq	.+2      	; 0x1a64 <__vector_7+0x30>
    1a62:	09 95       	icall
    1a64:	ff 91       	pop	r31
    1a66:	ef 91       	pop	r30
    1a68:	bf 91       	pop	r27
    1a6a:	af 91       	pop	r26
    1a6c:	9f 91       	pop	r25
    1a6e:	8f 91       	pop	r24
    1a70:	7f 91       	pop	r23
    1a72:	6f 91       	pop	r22
    1a74:	5f 91       	pop	r21
    1a76:	4f 91       	pop	r20
    1a78:	3f 91       	pop	r19
    1a7a:	2f 91       	pop	r18
    1a7c:	0f 90       	pop	r0
    1a7e:	0f be       	out	0x3f, r0	; 63
    1a80:	0f 90       	pop	r0
    1a82:	1f 90       	pop	r1
    1a84:	18 95       	reti

00001a86 <__vector_8>:
    1a86:	1f 92       	push	r1
    1a88:	0f 92       	push	r0
    1a8a:	0f b6       	in	r0, 0x3f	; 63
    1a8c:	0f 92       	push	r0
    1a8e:	11 24       	eor	r1, r1
    1a90:	2f 93       	push	r18
    1a92:	3f 93       	push	r19
    1a94:	4f 93       	push	r20
    1a96:	5f 93       	push	r21
    1a98:	6f 93       	push	r22
    1a9a:	7f 93       	push	r23
    1a9c:	8f 93       	push	r24
    1a9e:	9f 93       	push	r25
    1aa0:	af 93       	push	r26
    1aa2:	bf 93       	push	r27
    1aa4:	ef 93       	push	r30
    1aa6:	ff 93       	push	r31
    1aa8:	e0 91 18 08 	lds	r30, 0x0818	; 0x800818 <TMR_Timer1_CTC1B_PCallBack>
    1aac:	f0 91 19 08 	lds	r31, 0x0819	; 0x800819 <TMR_Timer1_CTC1B_PCallBack+0x1>
    1ab0:	30 97       	sbiw	r30, 0x00	; 0
    1ab2:	09 f0       	breq	.+2      	; 0x1ab6 <__vector_8+0x30>
    1ab4:	09 95       	icall
    1ab6:	ff 91       	pop	r31
    1ab8:	ef 91       	pop	r30
    1aba:	bf 91       	pop	r27
    1abc:	af 91       	pop	r26
    1abe:	9f 91       	pop	r25
    1ac0:	8f 91       	pop	r24
    1ac2:	7f 91       	pop	r23
    1ac4:	6f 91       	pop	r22
    1ac6:	5f 91       	pop	r21
    1ac8:	4f 91       	pop	r20
    1aca:	3f 91       	pop	r19
    1acc:	2f 91       	pop	r18
    1ace:	0f 90       	pop	r0
    1ad0:	0f be       	out	0x3f, r0	; 63
    1ad2:	0f 90       	pop	r0
    1ad4:	1f 90       	pop	r1
    1ad6:	18 95       	reti

00001ad8 <__vector_9>:
    1ad8:	1f 92       	push	r1
    1ada:	0f 92       	push	r0
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	0f 92       	push	r0
    1ae0:	11 24       	eor	r1, r1
    1ae2:	2f 93       	push	r18
    1ae4:	3f 93       	push	r19
    1ae6:	4f 93       	push	r20
    1ae8:	5f 93       	push	r21
    1aea:	6f 93       	push	r22
    1aec:	7f 93       	push	r23
    1aee:	8f 93       	push	r24
    1af0:	9f 93       	push	r25
    1af2:	af 93       	push	r26
    1af4:	bf 93       	push	r27
    1af6:	ef 93       	push	r30
    1af8:	ff 93       	push	r31
    1afa:	e0 91 1c 08 	lds	r30, 0x081C	; 0x80081c <TMR_Timer1_OVF_PCallBack>
    1afe:	f0 91 1d 08 	lds	r31, 0x081D	; 0x80081d <TMR_Timer1_OVF_PCallBack+0x1>
    1b02:	30 97       	sbiw	r30, 0x00	; 0
    1b04:	09 f0       	breq	.+2      	; 0x1b08 <__vector_9+0x30>
    1b06:	09 95       	icall
    1b08:	ff 91       	pop	r31
    1b0a:	ef 91       	pop	r30
    1b0c:	bf 91       	pop	r27
    1b0e:	af 91       	pop	r26
    1b10:	9f 91       	pop	r25
    1b12:	8f 91       	pop	r24
    1b14:	7f 91       	pop	r23
    1b16:	6f 91       	pop	r22
    1b18:	5f 91       	pop	r21
    1b1a:	4f 91       	pop	r20
    1b1c:	3f 91       	pop	r19
    1b1e:	2f 91       	pop	r18
    1b20:	0f 90       	pop	r0
    1b22:	0f be       	out	0x3f, r0	; 63
    1b24:	0f 90       	pop	r0
    1b26:	1f 90       	pop	r1
    1b28:	18 95       	reti

00001b2a <TMR_Timer2Init>:
    1b2a:	85 b5       	in	r24, 0x25	; 37
    1b2c:	80 64       	ori	r24, 0x40	; 64
    1b2e:	85 bd       	out	0x25, r24	; 37
    1b30:	85 b5       	in	r24, 0x25	; 37
    1b32:	88 60       	ori	r24, 0x08	; 8
    1b34:	85 bd       	out	0x25, r24	; 37
    1b36:	81 b3       	in	r24, 0x11	; 17
    1b38:	80 68       	ori	r24, 0x80	; 128
    1b3a:	81 bb       	out	0x11, r24	; 17
    1b3c:	85 b5       	in	r24, 0x25	; 37
    1b3e:	8f 7e       	andi	r24, 0xEF	; 239
    1b40:	85 bd       	out	0x25, r24	; 37
    1b42:	85 b5       	in	r24, 0x25	; 37
    1b44:	80 62       	ori	r24, 0x20	; 32
    1b46:	85 bd       	out	0x25, r24	; 37
    1b48:	08 95       	ret

00001b4a <TMR_Timer2Start>:
    1b4a:	85 b5       	in	r24, 0x25	; 37
    1b4c:	8e 7f       	andi	r24, 0xFE	; 254
    1b4e:	85 bd       	out	0x25, r24	; 37
    1b50:	85 b5       	in	r24, 0x25	; 37
    1b52:	8d 7f       	andi	r24, 0xFD	; 253
    1b54:	85 bd       	out	0x25, r24	; 37
    1b56:	85 b5       	in	r24, 0x25	; 37
    1b58:	84 60       	ori	r24, 0x04	; 4
    1b5a:	85 bd       	out	0x25, r24	; 37
    1b5c:	08 95       	ret

00001b5e <TMR_Timer2Stop>:
    1b5e:	85 b5       	in	r24, 0x25	; 37
    1b60:	8e 7f       	andi	r24, 0xFE	; 254
    1b62:	85 bd       	out	0x25, r24	; 37
    1b64:	85 b5       	in	r24, 0x25	; 37
    1b66:	8d 7f       	andi	r24, 0xFD	; 253
    1b68:	85 bd       	out	0x25, r24	; 37
    1b6a:	85 b5       	in	r24, 0x25	; 37
    1b6c:	8b 7f       	andi	r24, 0xFB	; 251
    1b6e:	85 bd       	out	0x25, r24	; 37
    1b70:	08 95       	ret

00001b72 <TMR_Timer2Set_PWM_DutyCycle>:
    1b72:	85 36       	cpi	r24, 0x65	; 101
    1b74:	78 f4       	brcc	.+30     	; 0x1b94 <TMR_Timer2Set_PWM_DutyCycle+0x22>
    1b76:	9f ef       	ldi	r25, 0xFF	; 255
    1b78:	89 9f       	mul	r24, r25
    1b7a:	b0 01       	movw	r22, r0
    1b7c:	11 24       	eor	r1, r1
    1b7e:	07 2e       	mov	r0, r23
    1b80:	00 0c       	add	r0, r0
    1b82:	88 0b       	sbc	r24, r24
    1b84:	99 0b       	sbc	r25, r25
    1b86:	24 e6       	ldi	r18, 0x64	; 100
    1b88:	30 e0       	ldi	r19, 0x00	; 0
    1b8a:	40 e0       	ldi	r20, 0x00	; 0
    1b8c:	50 e0       	ldi	r21, 0x00	; 0
    1b8e:	0e 94 96 12 	call	0x252c	; 0x252c <__udivmodsi4>
    1b92:	23 bd       	out	0x23, r18	; 35
    1b94:	08 95       	ret

00001b96 <__vector_4>:
    }
}
//ISR Function prototype for CTC2
void __vector_4(void) __attribute__ ((signal));
void __vector_4(void)
{
    1b96:	1f 92       	push	r1
    1b98:	0f 92       	push	r0
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	0f 92       	push	r0
    1b9e:	11 24       	eor	r1, r1
    1ba0:	2f 93       	push	r18
    1ba2:	3f 93       	push	r19
    1ba4:	4f 93       	push	r20
    1ba6:	5f 93       	push	r21
    1ba8:	6f 93       	push	r22
    1baa:	7f 93       	push	r23
    1bac:	8f 93       	push	r24
    1bae:	9f 93       	push	r25
    1bb0:	af 93       	push	r26
    1bb2:	bf 93       	push	r27
    1bb4:	ef 93       	push	r30
    1bb6:	ff 93       	push	r31
    if(TMR_Timer2_CTC_PCallBack != NULL)
    1bb8:	e0 91 14 08 	lds	r30, 0x0814	; 0x800814 <TMR_Timer2_CTC_PCallBack>
    1bbc:	f0 91 15 08 	lds	r31, 0x0815	; 0x800815 <TMR_Timer2_CTC_PCallBack+0x1>
    1bc0:	30 97       	sbiw	r30, 0x00	; 0
    1bc2:	09 f0       	breq	.+2      	; 0x1bc6 <__vector_4+0x30>
    {
        TMR_Timer2_CTC_PCallBack();
    1bc4:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1bc6:	ff 91       	pop	r31
    1bc8:	ef 91       	pop	r30
    1bca:	bf 91       	pop	r27
    1bcc:	af 91       	pop	r26
    1bce:	9f 91       	pop	r25
    1bd0:	8f 91       	pop	r24
    1bd2:	7f 91       	pop	r23
    1bd4:	6f 91       	pop	r22
    1bd6:	5f 91       	pop	r21
    1bd8:	4f 91       	pop	r20
    1bda:	3f 91       	pop	r19
    1bdc:	2f 91       	pop	r18
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63
    1be2:	0f 90       	pop	r0
    1be4:	1f 90       	pop	r1
    1be6:	18 95       	reti

00001be8 <__vector_5>:

//ISR Function prototype for OVF2
void __vector_5(void) __attribute__ ((signal));
void __vector_5(void)
{
    1be8:	1f 92       	push	r1
    1bea:	0f 92       	push	r0
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	0f 92       	push	r0
    1bf0:	11 24       	eor	r1, r1
    1bf2:	2f 93       	push	r18
    1bf4:	3f 93       	push	r19
    1bf6:	4f 93       	push	r20
    1bf8:	5f 93       	push	r21
    1bfa:	6f 93       	push	r22
    1bfc:	7f 93       	push	r23
    1bfe:	8f 93       	push	r24
    1c00:	9f 93       	push	r25
    1c02:	af 93       	push	r26
    1c04:	bf 93       	push	r27
    1c06:	ef 93       	push	r30
    1c08:	ff 93       	push	r31
    if(TMR_Timer2_OVF_PCallBack != NULL)
    1c0a:	e0 91 16 08 	lds	r30, 0x0816	; 0x800816 <TMR_Timer2_OVF_PCallBack>
    1c0e:	f0 91 17 08 	lds	r31, 0x0817	; 0x800817 <TMR_Timer2_OVF_PCallBack+0x1>
    1c12:	30 97       	sbiw	r30, 0x00	; 0
    1c14:	09 f0       	breq	.+2      	; 0x1c18 <__vector_5+0x30>
    {
        TMR_Timer2_OVF_PCallBack();
    1c16:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1c18:	ff 91       	pop	r31
    1c1a:	ef 91       	pop	r30
    1c1c:	bf 91       	pop	r27
    1c1e:	af 91       	pop	r26
    1c20:	9f 91       	pop	r25
    1c22:	8f 91       	pop	r24
    1c24:	7f 91       	pop	r23
    1c26:	6f 91       	pop	r22
    1c28:	5f 91       	pop	r21
    1c2a:	4f 91       	pop	r20
    1c2c:	3f 91       	pop	r19
    1c2e:	2f 91       	pop	r18
    1c30:	0f 90       	pop	r0
    1c32:	0f be       	out	0x3f, r0	; 63
    1c34:	0f 90       	pop	r0
    1c36:	1f 90       	pop	r1
    1c38:	18 95       	reti

00001c3a <UART_Init>:
 */
void UART_DataRegEmptySetCallback   (ptr_to_func_t P_DataRegEmptySetCallback)
{
    if(P_DataRegEmptySetCallback != NULL)
    {
        UART_DataRegEmpty_PCallback = P_DataRegEmptySetCallback;
    1c3a:	8a b1       	in	r24, 0x0a	; 10
    1c3c:	8b 7f       	andi	r24, 0xFB	; 251
    1c3e:	8a b9       	out	0x0a, r24	; 10
    1c40:	86 e8       	ldi	r24, 0x86	; 134
    1c42:	80 bd       	out	0x20, r24	; 32
    1c44:	87 e6       	ldi	r24, 0x67	; 103
    1c46:	89 b9       	out	0x09, r24	; 9
    1c48:	10 bc       	out	0x20, r1	; 32
    1c4a:	8a b1       	in	r24, 0x0a	; 10
    1c4c:	80 68       	ori	r24, 0x80	; 128
    1c4e:	8a b9       	out	0x0a, r24	; 10
    1c50:	8a b1       	in	r24, 0x0a	; 10
    1c52:	8f 7b       	andi	r24, 0xBF	; 191
    1c54:	8a b9       	out	0x0a, r24	; 10
    1c56:	8a b1       	in	r24, 0x0a	; 10
    1c58:	8f 7d       	andi	r24, 0xDF	; 223
    1c5a:	8a b9       	out	0x0a, r24	; 10
    1c5c:	8a b1       	in	r24, 0x0a	; 10
    1c5e:	88 60       	ori	r24, 0x08	; 8
    1c60:	8a b9       	out	0x0a, r24	; 10
    1c62:	8a b1       	in	r24, 0x0a	; 10
    1c64:	80 61       	ori	r24, 0x10	; 16
    1c66:	8a b9       	out	0x0a, r24	; 10
    1c68:	08 95       	ret

00001c6a <UART_TxChar>:
    1c6a:	8c b9       	out	0x0c, r24	; 12
    1c6c:	5d 9b       	sbis	0x0b, 5	; 11
    1c6e:	fe cf       	rjmp	.-4      	; 0x1c6c <UART_TxChar+0x2>
    1c70:	08 95       	ret

00001c72 <UART_RxChar>:
    1c72:	00 97       	sbiw	r24, 0x00	; 0
    1c74:	29 f0       	breq	.+10     	; 0x1c80 <UART_RxChar+0xe>
    1c76:	5f 9b       	sbis	0x0b, 7	; 11
    1c78:	fe cf       	rjmp	.-4      	; 0x1c76 <UART_RxChar+0x4>
    1c7a:	2c b1       	in	r18, 0x0c	; 12
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	20 83       	st	Z, r18
    1c80:	08 95       	ret

00001c82 <UART_TxString>:
    1c82:	0f 93       	push	r16
    1c84:	1f 93       	push	r17
    1c86:	cf 93       	push	r28
    1c88:	00 97       	sbiw	r24, 0x00	; 0
    1c8a:	29 f4       	brne	.+10     	; 0x1c96 <UART_TxString+0x14>
    1c8c:	0c c0       	rjmp	.+24     	; 0x1ca6 <UART_TxString+0x24>
    1c8e:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <UART_TxChar>
    1c92:	cf 5f       	subi	r28, 0xFF	; 255
    1c94:	02 c0       	rjmp	.+4      	; 0x1c9a <UART_TxString+0x18>
    1c96:	8c 01       	movw	r16, r24
    1c98:	c0 e0       	ldi	r28, 0x00	; 0
    1c9a:	f8 01       	movw	r30, r16
    1c9c:	ec 0f       	add	r30, r28
    1c9e:	f1 1d       	adc	r31, r1
    1ca0:	80 81       	ld	r24, Z
    1ca2:	81 11       	cpse	r24, r1
    1ca4:	f4 cf       	rjmp	.-24     	; 0x1c8e <UART_TxString+0xc>
    1ca6:	cf 91       	pop	r28
    1ca8:	1f 91       	pop	r17
    1caa:	0f 91       	pop	r16
    1cac:	08 95       	ret

00001cae <UART_RxString>:
    1cae:	ef 92       	push	r14
    1cb0:	ff 92       	push	r15
    1cb2:	1f 93       	push	r17
    1cb4:	cf 93       	push	r28
    1cb6:	df 93       	push	r29
    1cb8:	1f 92       	push	r1
    1cba:	cd b7       	in	r28, 0x3d	; 61
    1cbc:	de b7       	in	r29, 0x3e	; 62
    1cbe:	00 97       	sbiw	r24, 0x00	; 0
    1cc0:	c9 f0       	breq	.+50     	; 0x1cf4 <UART_RxString+0x46>
    1cc2:	7c 01       	movw	r14, r24
    1cc4:	19 82       	std	Y+1, r1	; 0x01
    1cc6:	10 e0       	ldi	r17, 0x00	; 0
    1cc8:	ce 01       	movw	r24, r28
    1cca:	01 96       	adiw	r24, 0x01	; 1
    1ccc:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <UART_RxChar>
    1cd0:	21 2f       	mov	r18, r17
    1cd2:	30 e0       	ldi	r19, 0x00	; 0
    1cd4:	d7 01       	movw	r26, r14
    1cd6:	a2 0f       	add	r26, r18
    1cd8:	b3 1f       	adc	r27, r19
    1cda:	99 81       	ldd	r25, Y+1	; 0x01
    1cdc:	9c 93       	st	X, r25
    1cde:	9a 30       	cpi	r25, 0x0A	; 10
    1ce0:	39 f4       	brne	.+14     	; 0x1cf0 <UART_RxString+0x42>
    1ce2:	21 50       	subi	r18, 0x01	; 1
    1ce4:	31 09       	sbc	r19, r1
    1ce6:	f7 01       	movw	r30, r14
    1ce8:	e2 0f       	add	r30, r18
    1cea:	f3 1f       	adc	r31, r19
    1cec:	10 82       	st	Z, r1
    1cee:	02 c0       	rjmp	.+4      	; 0x1cf4 <UART_RxString+0x46>
    1cf0:	1f 5f       	subi	r17, 0xFF	; 255
    1cf2:	ea cf       	rjmp	.-44     	; 0x1cc8 <UART_RxString+0x1a>
    1cf4:	0f 90       	pop	r0
    1cf6:	df 91       	pop	r29
    1cf8:	cf 91       	pop	r28
    1cfa:	1f 91       	pop	r17
    1cfc:	ff 90       	pop	r15
    1cfe:	ef 90       	pop	r14
    1d00:	08 95       	ret

00001d02 <UART_RxCompleteSetCallback>:
    1d02:	00 97       	sbiw	r24, 0x00	; 0
    1d04:	21 f0       	breq	.+8      	; 0x1d0e <UART_RxCompleteSetCallback+0xc>
    1d06:	90 93 25 08 	sts	0x0825, r25	; 0x800825 <UART_RxComplete_PCallback+0x1>
    1d0a:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <UART_RxComplete_PCallback>
    1d0e:	08 95       	ret

00001d10 <__vector_13>:
}

/*ISR Function for UART Rx Complete Interrupt*/
void __vector_13(void) __attribute__ ((signal));
void __vector_13(void)
{
    1d10:	1f 92       	push	r1
    1d12:	0f 92       	push	r0
    1d14:	0f b6       	in	r0, 0x3f	; 63
    1d16:	0f 92       	push	r0
    1d18:	11 24       	eor	r1, r1
    1d1a:	2f 93       	push	r18
    1d1c:	3f 93       	push	r19
    1d1e:	4f 93       	push	r20
    1d20:	5f 93       	push	r21
    1d22:	6f 93       	push	r22
    1d24:	7f 93       	push	r23
    1d26:	8f 93       	push	r24
    1d28:	9f 93       	push	r25
    1d2a:	af 93       	push	r26
    1d2c:	bf 93       	push	r27
    1d2e:	ef 93       	push	r30
    1d30:	ff 93       	push	r31
    if(UART_RxComplete_PCallback != NULL)
    1d32:	e0 91 24 08 	lds	r30, 0x0824	; 0x800824 <UART_RxComplete_PCallback>
    1d36:	f0 91 25 08 	lds	r31, 0x0825	; 0x800825 <UART_RxComplete_PCallback+0x1>
    1d3a:	30 97       	sbiw	r30, 0x00	; 0
    1d3c:	09 f0       	breq	.+2      	; 0x1d40 <__vector_13+0x30>
    {
        UART_RxComplete_PCallback();
    1d3e:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1d40:	ff 91       	pop	r31
    1d42:	ef 91       	pop	r30
    1d44:	bf 91       	pop	r27
    1d46:	af 91       	pop	r26
    1d48:	9f 91       	pop	r25
    1d4a:	8f 91       	pop	r24
    1d4c:	7f 91       	pop	r23
    1d4e:	6f 91       	pop	r22
    1d50:	5f 91       	pop	r21
    1d52:	4f 91       	pop	r20
    1d54:	3f 91       	pop	r19
    1d56:	2f 91       	pop	r18
    1d58:	0f 90       	pop	r0
    1d5a:	0f be       	out	0x3f, r0	; 63
    1d5c:	0f 90       	pop	r0
    1d5e:	1f 90       	pop	r1
    1d60:	18 95       	reti

00001d62 <__vector_14>:

/*ISR Function for UART Data Register Empty Interrupt*/
void __vector_14(void) __attribute__ ((signal));
void __vector_14(void)
{
    1d62:	1f 92       	push	r1
    1d64:	0f 92       	push	r0
    1d66:	0f b6       	in	r0, 0x3f	; 63
    1d68:	0f 92       	push	r0
    1d6a:	11 24       	eor	r1, r1
    1d6c:	2f 93       	push	r18
    1d6e:	3f 93       	push	r19
    1d70:	4f 93       	push	r20
    1d72:	5f 93       	push	r21
    1d74:	6f 93       	push	r22
    1d76:	7f 93       	push	r23
    1d78:	8f 93       	push	r24
    1d7a:	9f 93       	push	r25
    1d7c:	af 93       	push	r26
    1d7e:	bf 93       	push	r27
    1d80:	ef 93       	push	r30
    1d82:	ff 93       	push	r31
    if(UART_DataRegEmpty_PCallback != NULL)
    1d84:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <UART_DataRegEmpty_PCallback>
    1d88:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <UART_DataRegEmpty_PCallback+0x1>
    1d8c:	30 97       	sbiw	r30, 0x00	; 0
    1d8e:	09 f0       	breq	.+2      	; 0x1d92 <__vector_14+0x30>
    {
        UART_DataRegEmpty_PCallback();
    1d90:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
}
    1d92:	ff 91       	pop	r31
    1d94:	ef 91       	pop	r30
    1d96:	bf 91       	pop	r27
    1d98:	af 91       	pop	r26
    1d9a:	9f 91       	pop	r25
    1d9c:	8f 91       	pop	r24
    1d9e:	7f 91       	pop	r23
    1da0:	6f 91       	pop	r22
    1da2:	5f 91       	pop	r21
    1da4:	4f 91       	pop	r20
    1da6:	3f 91       	pop	r19
    1da8:	2f 91       	pop	r18
    1daa:	0f 90       	pop	r0
    1dac:	0f be       	out	0x3f, r0	; 63
    1dae:	0f 90       	pop	r0
    1db0:	1f 90       	pop	r1
    1db2:	18 95       	reti

00001db4 <__vector_15>:

/*ISR Function for UART Tx Complete Interrupt*/
void __vector_15(void) __attribute__ ((signal));
void __vector_15(void)
{
    1db4:	1f 92       	push	r1
    1db6:	0f 92       	push	r0
    1db8:	0f b6       	in	r0, 0x3f	; 63
    1dba:	0f 92       	push	r0
    1dbc:	11 24       	eor	r1, r1
    1dbe:	2f 93       	push	r18
    1dc0:	3f 93       	push	r19
    1dc2:	4f 93       	push	r20
    1dc4:	5f 93       	push	r21
    1dc6:	6f 93       	push	r22
    1dc8:	7f 93       	push	r23
    1dca:	8f 93       	push	r24
    1dcc:	9f 93       	push	r25
    1dce:	af 93       	push	r26
    1dd0:	bf 93       	push	r27
    1dd2:	ef 93       	push	r30
    1dd4:	ff 93       	push	r31
    if(UART_TxComplete_PCallback != NULL)
    1dd6:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <UART_TxComplete_PCallback>
    1dda:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <UART_TxComplete_PCallback+0x1>
    1dde:	30 97       	sbiw	r30, 0x00	; 0
    1de0:	09 f0       	breq	.+2      	; 0x1de4 <__vector_15+0x30>
    {
        UART_TxComplete_PCallback();
    1de2:	09 95       	icall
    }
    else
    {
        /*Do nothing*/
    }
    1de4:	ff 91       	pop	r31
    1de6:	ef 91       	pop	r30
    1de8:	bf 91       	pop	r27
    1dea:	af 91       	pop	r26
    1dec:	9f 91       	pop	r25
    1dee:	8f 91       	pop	r24
    1df0:	7f 91       	pop	r23
    1df2:	6f 91       	pop	r22
    1df4:	5f 91       	pop	r21
    1df6:	4f 91       	pop	r20
    1df8:	3f 91       	pop	r19
    1dfa:	2f 91       	pop	r18
    1dfc:	0f 90       	pop	r0
    1dfe:	0f be       	out	0x3f, r0	; 63
    1e00:	0f 90       	pop	r0
    1e02:	1f 90       	pop	r1
    1e04:	18 95       	reti

00001e06 <USER_PROGRAM_START>:


u8 USER_EXIST(void)
{
	return user_exist;
}
    1e06:	0e 94 c5 0a 	call	0x158a	; 0x158a <LCD_Init>
    1e0a:	0e 94 3c 09 	call	0x1278	; 0x1278 <KPD_Init>
    1e0e:	8e e8       	ldi	r24, 0x8E	; 142
    1e10:	96 e0       	ldi	r25, 0x06	; 6
    1e12:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1e16:	60 e0       	ldi	r22, 0x00	; 0
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <LCD_SetCursorPosition>
    1e1e:	89 e9       	ldi	r24, 0x99	; 153
    1e20:	96 e0       	ldi	r25, 0x06	; 6
    1e22:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1e26:	2f ef       	ldi	r18, 0xFF	; 255
    1e28:	87 ea       	ldi	r24, 0xA7	; 167
    1e2a:	91 e6       	ldi	r25, 0x61	; 97
    1e2c:	21 50       	subi	r18, 0x01	; 1
    1e2e:	80 40       	sbci	r24, 0x00	; 0
    1e30:	90 40       	sbci	r25, 0x00	; 0
    1e32:	e1 f7       	brne	.-8      	; 0x1e2c <USER_PROGRAM_START+0x26>
    1e34:	00 c0       	rjmp	.+0      	; 0x1e36 <USER_PROGRAM_START+0x30>
    1e36:	00 00       	nop
    1e38:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    1e3c:	08 95       	ret

00001e3e <USER_LOGIN>:
    1e3e:	ff 92       	push	r15
    1e40:	0f 93       	push	r16
    1e42:	1f 93       	push	r17
    1e44:	cf 93       	push	r28
    1e46:	df 93       	push	r29
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <USER_LOGIN+0xc>
    1e4a:	00 d0       	rcall	.+0      	; 0x1e4c <USER_LOGIN+0xe>
    1e4c:	00 d0       	rcall	.+0      	; 0x1e4e <USER_LOGIN+0x10>
    1e4e:	cd b7       	in	r28, 0x3d	; 61
    1e50:	de b7       	in	r29, 0x3e	; 62
    1e52:	8f ef       	ldi	r24, 0xFF	; 255
    1e54:	89 83       	std	Y+1, r24	; 0x01
    1e56:	84 ea       	ldi	r24, 0xA4	; 164
    1e58:	96 e0       	ldi	r25, 0x06	; 6
    1e5a:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1e5e:	04 c0       	rjmp	.+8      	; 0x1e68 <USER_LOGIN+0x2a>
    1e60:	ce 01       	movw	r24, r28
    1e62:	01 96       	adiw	r24, 0x01	; 1
    1e64:	0e 94 89 09 	call	0x1312	; 0x1312 <KPD_GetValue>
    1e68:	89 81       	ldd	r24, Y+1	; 0x01
    1e6a:	8f 3f       	cpi	r24, 0xFF	; 255
    1e6c:	c9 f3       	breq	.-14     	; 0x1e60 <USER_LOGIN+0x22>
    1e6e:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <LCD_WriteChar4Bit>
    1e72:	2f ef       	ldi	r18, 0xFF	; 255
    1e74:	87 ea       	ldi	r24, 0xA7	; 167
    1e76:	91 e6       	ldi	r25, 0x61	; 97
    1e78:	21 50       	subi	r18, 0x01	; 1
    1e7a:	80 40       	sbci	r24, 0x00	; 0
    1e7c:	90 40       	sbci	r25, 0x00	; 0
    1e7e:	e1 f7       	brne	.-8      	; 0x1e78 <USER_LOGIN+0x3a>
    1e80:	00 c0       	rjmp	.+0      	; 0x1e82 <USER_LOGIN+0x44>
    1e82:	00 00       	nop
    1e84:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    1e88:	82 eb       	ldi	r24, 0xB2	; 178
    1e8a:	96 e0       	ldi	r25, 0x06	; 6
    1e8c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1e90:	60 e0       	ldi	r22, 0x00	; 0
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <LCD_SetCursorPosition>
    1e98:	f1 2c       	mov	r15, r1
    1e9a:	02 e0       	ldi	r16, 0x02	; 2
    1e9c:	10 e0       	ldi	r17, 0x00	; 0
    1e9e:	0c 0f       	add	r16, r28
    1ea0:	1d 1f       	adc	r17, r29
    1ea2:	0f 0d       	add	r16, r15
    1ea4:	11 1d       	adc	r17, r1
    1ea6:	c8 01       	movw	r24, r16
    1ea8:	0e 94 89 09 	call	0x1312	; 0x1312 <KPD_GetValue>
    1eac:	f8 01       	movw	r30, r16
    1eae:	80 81       	ld	r24, Z
    1eb0:	8f 3f       	cpi	r24, 0xFF	; 255
    1eb2:	99 f3       	breq	.-26     	; 0x1e9a <USER_LOGIN+0x5c>
    1eb4:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <LCD_WriteChar4Bit>
    1eb8:	f3 94       	inc	r15
    1eba:	f3 e0       	ldi	r31, 0x03	; 3
    1ebc:	ff 12       	cpse	r15, r31
    1ebe:	ed cf       	rjmp	.-38     	; 0x1e9a <USER_LOGIN+0x5c>
    1ec0:	2f ef       	ldi	r18, 0xFF	; 255
    1ec2:	83 ed       	ldi	r24, 0xD3	; 211
    1ec4:	90 e3       	ldi	r25, 0x30	; 48
    1ec6:	21 50       	subi	r18, 0x01	; 1
    1ec8:	80 40       	sbci	r24, 0x00	; 0
    1eca:	90 40       	sbci	r25, 0x00	; 0
    1ecc:	e1 f7       	brne	.-8      	; 0x1ec6 <USER_LOGIN+0x88>
    1ece:	00 c0       	rjmp	.+0      	; 0x1ed0 <USER_LOGIN+0x92>
    1ed0:	00 00       	nop
    1ed2:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    1ed6:	1d 82       	std	Y+5, r1	; 0x05
    1ed8:	1e 82       	std	Y+6, r1	; 0x06
    1eda:	be 01       	movw	r22, r28
    1edc:	6b 5f       	subi	r22, 0xFB	; 251
    1ede:	7f 4f       	sbci	r23, 0xFF	; 255
    1ee0:	8a e0       	ldi	r24, 0x0A	; 10
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
    1ee8:	10 e0       	ldi	r17, 0x00	; 0
    1eea:	01 e0       	ldi	r16, 0x01	; 1
    1eec:	10 c0       	rjmp	.+32     	; 0x1f0e <USER_LOGIN+0xd0>
    1eee:	10 2f       	mov	r17, r16
    1ef0:	11 0f       	add	r17, r17
    1ef2:	11 0f       	add	r17, r17
    1ef4:	1e 5c       	subi	r17, 0xCE	; 206
    1ef6:	be 01       	movw	r22, r28
    1ef8:	6a 5f       	subi	r22, 0xFA	; 250
    1efa:	7f 4f       	sbci	r23, 0xFF	; 255
    1efc:	81 2f       	mov	r24, r17
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
    1f04:	9e 81       	ldd	r25, Y+6	; 0x06
    1f06:	89 81       	ldd	r24, Y+1	; 0x01
    1f08:	98 17       	cp	r25, r24
    1f0a:	31 f0       	breq	.+12     	; 0x1f18 <USER_LOGIN+0xda>
    1f0c:	0f 5f       	subi	r16, 0xFF	; 255
    1f0e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f10:	08 17       	cp	r16, r24
    1f12:	68 f3       	brcs	.-38     	; 0x1eee <USER_LOGIN+0xb0>
    1f14:	80 e0       	ldi	r24, 0x00	; 0
    1f16:	01 c0       	rjmp	.+2      	; 0x1f1a <USER_LOGIN+0xdc>
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	81 30       	cpi	r24, 0x01	; 1
    1f1c:	09 f0       	breq	.+2      	; 0x1f20 <USER_LOGIN+0xe2>
    1f1e:	59 c0       	rjmp	.+178    	; 0x1fd2 <USER_LOGIN+0x194>
    1f20:	1f 5f       	subi	r17, 0xFF	; 255
    1f22:	00 e0       	ldi	r16, 0x00	; 0
    1f24:	2c c0       	rjmp	.+88     	; 0x1f7e <USER_LOGIN+0x140>
    1f26:	be 01       	movw	r22, r28
    1f28:	6a 5f       	subi	r22, 0xFA	; 250
    1f2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f2c:	81 2f       	mov	r24, r17
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	0e 94 2a 09 	call	0x1254	; 0x1254 <Internal_EEPROM_ReadByte>
    1f34:	e2 e0       	ldi	r30, 0x02	; 2
    1f36:	f0 e0       	ldi	r31, 0x00	; 0
    1f38:	ec 0f       	add	r30, r28
    1f3a:	fd 1f       	adc	r31, r29
    1f3c:	e0 0f       	add	r30, r16
    1f3e:	f1 1d       	adc	r31, r1
    1f40:	90 81       	ld	r25, Z
    1f42:	8e 81       	ldd	r24, Y+6	; 0x06
    1f44:	98 17       	cp	r25, r24
    1f46:	c9 f0       	breq	.+50     	; 0x1f7a <USER_LOGIN+0x13c>
    1f48:	84 ec       	ldi	r24, 0xC4	; 196
    1f4a:	96 e0       	ldi	r25, 0x06	; 6
    1f4c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1f50:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <user_exist>
    1f54:	ef ef       	ldi	r30, 0xFF	; 255
    1f56:	f3 ed       	ldi	r31, 0xD3	; 211
    1f58:	20 e3       	ldi	r18, 0x30	; 48
    1f5a:	e1 50       	subi	r30, 0x01	; 1
    1f5c:	f0 40       	sbci	r31, 0x00	; 0
    1f5e:	20 40       	sbci	r18, 0x00	; 0
    1f60:	e1 f7       	brne	.-8      	; 0x1f5a <USER_LOGIN+0x11c>
    1f62:	00 c0       	rjmp	.+0      	; 0x1f64 <USER_LOGIN+0x126>
    1f64:	00 00       	nop
    1f66:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    1f6a:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <buzzer_check>
    1f6e:	8f 5f       	subi	r24, 0xFF	; 255
    1f70:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <buzzer_check>
    1f74:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <user_exist>
    1f78:	55 c0       	rjmp	.+170    	; 0x2024 <USER_LOGIN+0x1e6>
    1f7a:	1f 5f       	subi	r17, 0xFF	; 255
    1f7c:	0f 5f       	subi	r16, 0xFF	; 255
    1f7e:	03 30       	cpi	r16, 0x03	; 3
    1f80:	90 f2       	brcs	.-92     	; 0x1f26 <USER_LOGIN+0xe8>
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	80 93 29 08 	sts	0x0829, r24	; 0x800829 <user_exist>
    1f88:	8f ec       	ldi	r24, 0xCF	; 207
    1f8a:	96 e0       	ldi	r25, 0x06	; 6
    1f8c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1f90:	8f ef       	ldi	r24, 0xFF	; 255
    1f92:	93 ed       	ldi	r25, 0xD3	; 211
    1f94:	e0 e3       	ldi	r30, 0x30	; 48
    1f96:	81 50       	subi	r24, 0x01	; 1
    1f98:	90 40       	sbci	r25, 0x00	; 0
    1f9a:	e0 40       	sbci	r30, 0x00	; 0
    1f9c:	e1 f7       	brne	.-8      	; 0x1f96 <USER_LOGIN+0x158>
    1f9e:	00 c0       	rjmp	.+0      	; 0x1fa0 <USER_LOGIN+0x162>
    1fa0:	00 00       	nop
    1fa2:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    1fa6:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <buzzer_check>
    1faa:	83 30       	cpi	r24, 0x03	; 3
    1fac:	79 f4       	brne	.+30     	; 0x1fcc <USER_LOGIN+0x18e>
    1fae:	10 92 28 08 	sts	0x0828, r1	; 0x800828 <buzzer_check>
    1fb2:	0e 94 88 00 	call	0x110	; 0x110 <BUZZER_On>
    1fb6:	ff ef       	ldi	r31, 0xFF	; 255
    1fb8:	2b e7       	ldi	r18, 0x7B	; 123
    1fba:	82 e9       	ldi	r24, 0x92	; 146
    1fbc:	f1 50       	subi	r31, 0x01	; 1
    1fbe:	20 40       	sbci	r18, 0x00	; 0
    1fc0:	80 40       	sbci	r24, 0x00	; 0
    1fc2:	e1 f7       	brne	.-8      	; 0x1fbc <USER_LOGIN+0x17e>
    1fc4:	00 c0       	rjmp	.+0      	; 0x1fc6 <USER_LOGIN+0x188>
    1fc6:	00 00       	nop
    1fc8:	0e 94 8e 00 	call	0x11c	; 0x11c <BUZZER_Off>
    1fcc:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <user_exist>
    1fd0:	29 c0       	rjmp	.+82     	; 0x2024 <USER_LOGIN+0x1e6>
    1fd2:	8d ed       	ldi	r24, 0xDD	; 221
    1fd4:	96 e0       	ldi	r25, 0x06	; 6
    1fd6:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    1fda:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <user_exist>
    1fde:	9f ef       	ldi	r25, 0xFF	; 255
    1fe0:	e3 ed       	ldi	r30, 0xD3	; 211
    1fe2:	f0 e3       	ldi	r31, 0x30	; 48
    1fe4:	91 50       	subi	r25, 0x01	; 1
    1fe6:	e0 40       	sbci	r30, 0x00	; 0
    1fe8:	f0 40       	sbci	r31, 0x00	; 0
    1fea:	e1 f7       	brne	.-8      	; 0x1fe4 <USER_LOGIN+0x1a6>
    1fec:	00 c0       	rjmp	.+0      	; 0x1fee <USER_LOGIN+0x1b0>
    1fee:	00 00       	nop
    1ff0:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    1ff4:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <buzzer_check>
    1ff8:	8f 5f       	subi	r24, 0xFF	; 255
    1ffa:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <buzzer_check>
    1ffe:	83 30       	cpi	r24, 0x03	; 3
    2000:	79 f4       	brne	.+30     	; 0x2020 <USER_LOGIN+0x1e2>
    2002:	10 92 28 08 	sts	0x0828, r1	; 0x800828 <buzzer_check>
    2006:	0e 94 88 00 	call	0x110	; 0x110 <BUZZER_On>
    200a:	2f ef       	ldi	r18, 0xFF	; 255
    200c:	8b e7       	ldi	r24, 0x7B	; 123
    200e:	92 e9       	ldi	r25, 0x92	; 146
    2010:	21 50       	subi	r18, 0x01	; 1
    2012:	80 40       	sbci	r24, 0x00	; 0
    2014:	90 40       	sbci	r25, 0x00	; 0
    2016:	e1 f7       	brne	.-8      	; 0x2010 <USER_LOGIN+0x1d2>
    2018:	00 c0       	rjmp	.+0      	; 0x201a <USER_LOGIN+0x1dc>
    201a:	00 00       	nop
    201c:	0e 94 8e 00 	call	0x11c	; 0x11c <BUZZER_Off>
    2020:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <user_exist>
    2024:	26 96       	adiw	r28, 0x06	; 6
    2026:	0f b6       	in	r0, 0x3f	; 63
    2028:	f8 94       	cli
    202a:	de bf       	out	0x3e, r29	; 62
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	cd bf       	out	0x3d, r28	; 61
    2030:	df 91       	pop	r29
    2032:	cf 91       	pop	r28
    2034:	1f 91       	pop	r17
    2036:	0f 91       	pop	r16
    2038:	ff 90       	pop	r15
    203a:	08 95       	ret

0000203c <USER_Control_Leds>:
    203c:	cf 93       	push	r28
    203e:	df 93       	push	r29
    2040:	00 d0       	rcall	.+0      	; 0x2042 <USER_Control_Leds+0x6>
    2042:	1f 92       	push	r1
    2044:	cd b7       	in	r28, 0x3d	; 61
    2046:	de b7       	in	r29, 0x3e	; 62
    2048:	41 e0       	ldi	r20, 0x01	; 1
    204a:	62 e0       	ldi	r22, 0x02	; 2
    204c:	82 e0       	ldi	r24, 0x02	; 2
    204e:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    2052:	41 e0       	ldi	r20, 0x01	; 1
    2054:	67 e0       	ldi	r22, 0x07	; 7
    2056:	82 e0       	ldi	r24, 0x02	; 2
    2058:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    205c:	41 e0       	ldi	r20, 0x01	; 1
    205e:	63 e0       	ldi	r22, 0x03	; 3
    2060:	83 e0       	ldi	r24, 0x03	; 3
    2062:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    2066:	41 e0       	ldi	r20, 0x01	; 1
    2068:	67 e0       	ldi	r22, 0x07	; 7
    206a:	83 e0       	ldi	r24, 0x03	; 3
    206c:	0e 94 ca 00 	call	0x194	; 0x194 <DIO_SetPinDirection>
    2070:	8f ef       	ldi	r24, 0xFF	; 255
    2072:	89 83       	std	Y+1, r24	; 0x01
    2074:	86 ee       	ldi	r24, 0xE6	; 230
    2076:	96 e0       	ldi	r25, 0x06	; 6
    2078:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    207c:	2f ef       	ldi	r18, 0xFF	; 255
    207e:	87 ea       	ldi	r24, 0xA7	; 167
    2080:	91 e6       	ldi	r25, 0x61	; 97
    2082:	21 50       	subi	r18, 0x01	; 1
    2084:	80 40       	sbci	r24, 0x00	; 0
    2086:	90 40       	sbci	r25, 0x00	; 0
    2088:	e1 f7       	brne	.-8      	; 0x2082 <USER_Control_Leds+0x46>
    208a:	00 c0       	rjmp	.+0      	; 0x208c <USER_Control_Leds+0x50>
    208c:	00 00       	nop
    208e:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2092:	82 ef       	ldi	r24, 0xF2	; 242
    2094:	96 e0       	ldi	r25, 0x06	; 6
    2096:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    209a:	2f ef       	ldi	r18, 0xFF	; 255
    209c:	87 ea       	ldi	r24, 0xA7	; 167
    209e:	91 e6       	ldi	r25, 0x61	; 97
    20a0:	21 50       	subi	r18, 0x01	; 1
    20a2:	80 40       	sbci	r24, 0x00	; 0
    20a4:	90 40       	sbci	r25, 0x00	; 0
    20a6:	e1 f7       	brne	.-8      	; 0x20a0 <USER_Control_Leds+0x64>
    20a8:	00 c0       	rjmp	.+0      	; 0x20aa <USER_Control_Leds+0x6e>
    20aa:	00 00       	nop
    20ac:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    20b0:	89 ef       	ldi	r24, 0xF9	; 249
    20b2:	96 e0       	ldi	r25, 0x06	; 6
    20b4:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    20b8:	2f ef       	ldi	r18, 0xFF	; 255
    20ba:	87 ea       	ldi	r24, 0xA7	; 167
    20bc:	91 e6       	ldi	r25, 0x61	; 97
    20be:	21 50       	subi	r18, 0x01	; 1
    20c0:	80 40       	sbci	r24, 0x00	; 0
    20c2:	90 40       	sbci	r25, 0x00	; 0
    20c4:	e1 f7       	brne	.-8      	; 0x20be <USER_Control_Leds+0x82>
    20c6:	00 c0       	rjmp	.+0      	; 0x20c8 <USER_Control_Leds+0x8c>
    20c8:	00 00       	nop
    20ca:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	97 e0       	ldi	r25, 0x07	; 7
    20d2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    20d6:	2f ef       	ldi	r18, 0xFF	; 255
    20d8:	87 ea       	ldi	r24, 0xA7	; 167
    20da:	91 e6       	ldi	r25, 0x61	; 97
    20dc:	21 50       	subi	r18, 0x01	; 1
    20de:	80 40       	sbci	r24, 0x00	; 0
    20e0:	90 40       	sbci	r25, 0x00	; 0
    20e2:	e1 f7       	brne	.-8      	; 0x20dc <USER_Control_Leds+0xa0>
    20e4:	00 c0       	rjmp	.+0      	; 0x20e6 <USER_Control_Leds+0xaa>
    20e6:	00 00       	nop
    20e8:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    20ec:	87 e0       	ldi	r24, 0x07	; 7
    20ee:	97 e0       	ldi	r25, 0x07	; 7
    20f0:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    20f4:	2f ef       	ldi	r18, 0xFF	; 255
    20f6:	87 ea       	ldi	r24, 0xA7	; 167
    20f8:	91 e6       	ldi	r25, 0x61	; 97
    20fa:	21 50       	subi	r18, 0x01	; 1
    20fc:	80 40       	sbci	r24, 0x00	; 0
    20fe:	90 40       	sbci	r25, 0x00	; 0
    2100:	e1 f7       	brne	.-8      	; 0x20fa <USER_Control_Leds+0xbe>
    2102:	00 c0       	rjmp	.+0      	; 0x2104 <USER_Control_Leds+0xc8>
    2104:	00 00       	nop
    2106:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    210a:	8e e0       	ldi	r24, 0x0E	; 14
    210c:	97 e0       	ldi	r25, 0x07	; 7
    210e:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2112:	2f ef       	ldi	r18, 0xFF	; 255
    2114:	87 ea       	ldi	r24, 0xA7	; 167
    2116:	91 e6       	ldi	r25, 0x61	; 97
    2118:	21 50       	subi	r18, 0x01	; 1
    211a:	80 40       	sbci	r24, 0x00	; 0
    211c:	90 40       	sbci	r25, 0x00	; 0
    211e:	e1 f7       	brne	.-8      	; 0x2118 <USER_Control_Leds+0xdc>
    2120:	00 c0       	rjmp	.+0      	; 0x2122 <USER_Control_Leds+0xe6>
    2122:	00 00       	nop
    2124:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2128:	85 e1       	ldi	r24, 0x15	; 21
    212a:	97 e0       	ldi	r25, 0x07	; 7
    212c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2130:	2f ef       	ldi	r18, 0xFF	; 255
    2132:	87 ea       	ldi	r24, 0xA7	; 167
    2134:	91 e6       	ldi	r25, 0x61	; 97
    2136:	21 50       	subi	r18, 0x01	; 1
    2138:	80 40       	sbci	r24, 0x00	; 0
    213a:	90 40       	sbci	r25, 0x00	; 0
    213c:	e1 f7       	brne	.-8      	; 0x2136 <USER_Control_Leds+0xfa>
    213e:	00 c0       	rjmp	.+0      	; 0x2140 <USER_Control_Leds+0x104>
    2140:	00 00       	nop
    2142:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	8f 3f       	cpi	r24, 0xFF	; 255
    214a:	29 f4       	brne	.+10     	; 0x2156 <USER_Control_Leds+0x11a>
    214c:	ce 01       	movw	r24, r28
    214e:	01 96       	adiw	r24, 0x01	; 1
    2150:	0e 94 89 09 	call	0x1312	; 0x1312 <KPD_GetValue>
    2154:	f8 cf       	rjmp	.-16     	; 0x2146 <USER_Control_Leds+0x10a>
    2156:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <LCD_WriteChar4Bit>
    215a:	2f ef       	ldi	r18, 0xFF	; 255
    215c:	83 ed       	ldi	r24, 0xD3	; 211
    215e:	90 e3       	ldi	r25, 0x30	; 48
    2160:	21 50       	subi	r18, 0x01	; 1
    2162:	80 40       	sbci	r24, 0x00	; 0
    2164:	90 40       	sbci	r25, 0x00	; 0
    2166:	e1 f7       	brne	.-8      	; 0x2160 <USER_Control_Leds+0x124>
    2168:	00 c0       	rjmp	.+0      	; 0x216a <USER_Control_Leds+0x12e>
    216a:	00 00       	nop
    216c:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2170:	83 e2       	ldi	r24, 0x23	; 35
    2172:	97 e0       	ldi	r25, 0x07	; 7
    2174:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2178:	2f ef       	ldi	r18, 0xFF	; 255
    217a:	87 ea       	ldi	r24, 0xA7	; 167
    217c:	91 e6       	ldi	r25, 0x61	; 97
    217e:	21 50       	subi	r18, 0x01	; 1
    2180:	80 40       	sbci	r24, 0x00	; 0
    2182:	90 40       	sbci	r25, 0x00	; 0
    2184:	e1 f7       	brne	.-8      	; 0x217e <USER_Control_Leds+0x142>
    2186:	00 c0       	rjmp	.+0      	; 0x2188 <USER_Control_Leds+0x14c>
    2188:	00 00       	nop
    218a:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    218e:	88 e2       	ldi	r24, 0x28	; 40
    2190:	97 e0       	ldi	r25, 0x07	; 7
    2192:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2196:	2f ef       	ldi	r18, 0xFF	; 255
    2198:	87 ea       	ldi	r24, 0xA7	; 167
    219a:	91 e6       	ldi	r25, 0x61	; 97
    219c:	21 50       	subi	r18, 0x01	; 1
    219e:	80 40       	sbci	r24, 0x00	; 0
    21a0:	90 40       	sbci	r25, 0x00	; 0
    21a2:	e1 f7       	brne	.-8      	; 0x219c <USER_Control_Leds+0x160>
    21a4:	00 c0       	rjmp	.+0      	; 0x21a6 <USER_Control_Leds+0x16a>
    21a6:	00 00       	nop
    21a8:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    21ac:	8f ef       	ldi	r24, 0xFF	; 255
    21ae:	8a 83       	std	Y+2, r24	; 0x02
    21b0:	8a 81       	ldd	r24, Y+2	; 0x02
    21b2:	8f 3f       	cpi	r24, 0xFF	; 255
    21b4:	29 f4       	brne	.+10     	; 0x21c0 <USER_Control_Leds+0x184>
    21b6:	ce 01       	movw	r24, r28
    21b8:	02 96       	adiw	r24, 0x02	; 2
    21ba:	0e 94 89 09 	call	0x1312	; 0x1312 <KPD_GetValue>
    21be:	f8 cf       	rjmp	.-16     	; 0x21b0 <USER_Control_Leds+0x174>
    21c0:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <LCD_WriteChar4Bit>
    21c4:	2f ef       	ldi	r18, 0xFF	; 255
    21c6:	83 ed       	ldi	r24, 0xD3	; 211
    21c8:	90 e3       	ldi	r25, 0x30	; 48
    21ca:	21 50       	subi	r18, 0x01	; 1
    21cc:	80 40       	sbci	r24, 0x00	; 0
    21ce:	90 40       	sbci	r25, 0x00	; 0
    21d0:	e1 f7       	brne	.-8      	; 0x21ca <USER_Control_Leds+0x18e>
    21d2:	00 c0       	rjmp	.+0      	; 0x21d4 <USER_Control_Leds+0x198>
    21d4:	00 00       	nop
    21d6:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    21da:	89 81       	ldd	r24, Y+1	; 0x01
    21dc:	81 33       	cpi	r24, 0x31	; 49
    21de:	c1 f4       	brne	.+48     	; 0x2210 <USER_Control_Leds+0x1d4>
    21e0:	9a 81       	ldd	r25, Y+2	; 0x02
    21e2:	91 33       	cpi	r25, 0x31	; 49
    21e4:	a9 f4       	brne	.+42     	; 0x2210 <USER_Control_Leds+0x1d4>
    21e6:	41 e0       	ldi	r20, 0x01	; 1
    21e8:	62 e0       	ldi	r22, 0x02	; 2
    21ea:	82 e0       	ldi	r24, 0x02	; 2
    21ec:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    21f0:	8e e2       	ldi	r24, 0x2E	; 46
    21f2:	97 e0       	ldi	r25, 0x07	; 7
    21f4:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    21f8:	2f ef       	ldi	r18, 0xFF	; 255
    21fa:	87 ea       	ldi	r24, 0xA7	; 167
    21fc:	91 e6       	ldi	r25, 0x61	; 97
    21fe:	21 50       	subi	r18, 0x01	; 1
    2200:	80 40       	sbci	r24, 0x00	; 0
    2202:	90 40       	sbci	r25, 0x00	; 0
    2204:	e1 f7       	brne	.-8      	; 0x21fe <USER_Control_Leds+0x1c2>
    2206:	00 c0       	rjmp	.+0      	; 0x2208 <USER_Control_Leds+0x1cc>
    2208:	00 00       	nop
    220a:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    220e:	8d c0       	rjmp	.+282    	; 0x232a <USER_Control_Leds+0x2ee>
    2210:	82 33       	cpi	r24, 0x32	; 50
    2212:	c1 f4       	brne	.+48     	; 0x2244 <USER_Control_Leds+0x208>
    2214:	9a 81       	ldd	r25, Y+2	; 0x02
    2216:	91 33       	cpi	r25, 0x31	; 49
    2218:	a9 f4       	brne	.+42     	; 0x2244 <USER_Control_Leds+0x208>
    221a:	41 e0       	ldi	r20, 0x01	; 1
    221c:	67 e0       	ldi	r22, 0x07	; 7
    221e:	82 e0       	ldi	r24, 0x02	; 2
    2220:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    2224:	8e e2       	ldi	r24, 0x2E	; 46
    2226:	97 e0       	ldi	r25, 0x07	; 7
    2228:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    222c:	2f ef       	ldi	r18, 0xFF	; 255
    222e:	87 ea       	ldi	r24, 0xA7	; 167
    2230:	91 e6       	ldi	r25, 0x61	; 97
    2232:	21 50       	subi	r18, 0x01	; 1
    2234:	80 40       	sbci	r24, 0x00	; 0
    2236:	90 40       	sbci	r25, 0x00	; 0
    2238:	e1 f7       	brne	.-8      	; 0x2232 <USER_Control_Leds+0x1f6>
    223a:	00 c0       	rjmp	.+0      	; 0x223c <USER_Control_Leds+0x200>
    223c:	00 00       	nop
    223e:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2242:	73 c0       	rjmp	.+230    	; 0x232a <USER_Control_Leds+0x2ee>
    2244:	86 33       	cpi	r24, 0x36	; 54
    2246:	09 f0       	breq	.+2      	; 0x224a <USER_Control_Leds+0x20e>
    2248:	70 c0       	rjmp	.+224    	; 0x232a <USER_Control_Leds+0x2ee>
    224a:	8a 81       	ldd	r24, Y+2	; 0x02
    224c:	81 33       	cpi	r24, 0x31	; 49
    224e:	09 f0       	breq	.+2      	; 0x2252 <USER_Control_Leds+0x216>
    2250:	6c c0       	rjmp	.+216    	; 0x232a <USER_Control_Leds+0x2ee>
    2252:	88 e3       	ldi	r24, 0x38	; 56
    2254:	97 e0       	ldi	r25, 0x07	; 7
    2256:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    225a:	2f ef       	ldi	r18, 0xFF	; 255
    225c:	87 ea       	ldi	r24, 0xA7	; 167
    225e:	91 e6       	ldi	r25, 0x61	; 97
    2260:	21 50       	subi	r18, 0x01	; 1
    2262:	80 40       	sbci	r24, 0x00	; 0
    2264:	90 40       	sbci	r25, 0x00	; 0
    2266:	e1 f7       	brne	.-8      	; 0x2260 <USER_Control_Leds+0x224>
    2268:	00 c0       	rjmp	.+0      	; 0x226a <USER_Control_Leds+0x22e>
    226a:	00 00       	nop
    226c:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2270:	86 e4       	ldi	r24, 0x46	; 70
    2272:	97 e0       	ldi	r25, 0x07	; 7
    2274:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2278:	60 e0       	ldi	r22, 0x00	; 0
    227a:	81 e0       	ldi	r24, 0x01	; 1
    227c:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <LCD_SetCursorPosition>
    2280:	85 e5       	ldi	r24, 0x55	; 85
    2282:	97 e0       	ldi	r25, 0x07	; 7
    2284:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2288:	2f ef       	ldi	r18, 0xFF	; 255
    228a:	87 ea       	ldi	r24, 0xA7	; 167
    228c:	91 e6       	ldi	r25, 0x61	; 97
    228e:	21 50       	subi	r18, 0x01	; 1
    2290:	80 40       	sbci	r24, 0x00	; 0
    2292:	90 40       	sbci	r25, 0x00	; 0
    2294:	e1 f7       	brne	.-8      	; 0x228e <USER_Control_Leds+0x252>
    2296:	00 c0       	rjmp	.+0      	; 0x2298 <USER_Control_Leds+0x25c>
    2298:	00 00       	nop
    229a:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    229e:	84 e6       	ldi	r24, 0x64	; 100
    22a0:	97 e0       	ldi	r25, 0x07	; 7
    22a2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    22a6:	60 e0       	ldi	r22, 0x00	; 0
    22a8:	81 e0       	ldi	r24, 0x01	; 1
    22aa:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <LCD_SetCursorPosition>
    22ae:	8f ef       	ldi	r24, 0xFF	; 255
    22b0:	8b 83       	std	Y+3, r24	; 0x03
    22b2:	8b 81       	ldd	r24, Y+3	; 0x03
    22b4:	8f 3f       	cpi	r24, 0xFF	; 255
    22b6:	29 f4       	brne	.+10     	; 0x22c2 <USER_Control_Leds+0x286>
    22b8:	ce 01       	movw	r24, r28
    22ba:	03 96       	adiw	r24, 0x03	; 3
    22bc:	0e 94 89 09 	call	0x1312	; 0x1312 <KPD_GetValue>
    22c0:	f8 cf       	rjmp	.-16     	; 0x22b2 <USER_Control_Leds+0x276>
    22c2:	83 33       	cpi	r24, 0x33	; 51
    22c4:	d9 f0       	breq	.+54     	; 0x22fc <USER_Control_Leds+0x2c0>
    22c6:	28 f4       	brcc	.+10     	; 0x22d2 <USER_Control_Leds+0x296>
    22c8:	81 33       	cpi	r24, 0x31	; 49
    22ca:	41 f0       	breq	.+16     	; 0x22dc <USER_Control_Leds+0x2a0>
    22cc:	82 33       	cpi	r24, 0x32	; 50
    22ce:	71 f0       	breq	.+28     	; 0x22ec <USER_Control_Leds+0x2b0>
    22d0:	2c c0       	rjmp	.+88     	; 0x232a <USER_Control_Leds+0x2ee>
    22d2:	84 33       	cpi	r24, 0x34	; 52
    22d4:	d9 f0       	breq	.+54     	; 0x230c <USER_Control_Leds+0x2d0>
    22d6:	85 33       	cpi	r24, 0x35	; 53
    22d8:	09 f1       	breq	.+66     	; 0x231c <USER_Control_Leds+0x2e0>
    22da:	27 c0       	rjmp	.+78     	; 0x232a <USER_Control_Leds+0x2ee>
    22dc:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
    22e0:	84 e1       	ldi	r24, 0x14	; 20
    22e2:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
    22e6:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
    22ea:	1f c0       	rjmp	.+62     	; 0x232a <USER_Control_Leds+0x2ee>
    22ec:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
    22f0:	88 e2       	ldi	r24, 0x28	; 40
    22f2:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
    22f6:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
    22fa:	17 c0       	rjmp	.+46     	; 0x232a <USER_Control_Leds+0x2ee>
    22fc:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
    2300:	8c e3       	ldi	r24, 0x3C	; 60
    2302:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
    2306:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
    230a:	0f c0       	rjmp	.+30     	; 0x232a <USER_Control_Leds+0x2ee>
    230c:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
    2310:	80 e5       	ldi	r24, 0x50	; 80
    2312:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
    2316:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
    231a:	07 c0       	rjmp	.+14     	; 0x232a <USER_Control_Leds+0x2ee>
    231c:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
    2320:	84 e6       	ldi	r24, 0x64	; 100
    2322:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <TMR_Timer2Set_PWM_DutyCycle>
    2326:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <TMR_Timer2Start>
    232a:	89 81       	ldd	r24, Y+1	; 0x01
    232c:	81 33       	cpi	r24, 0x31	; 49
    232e:	c1 f4       	brne	.+48     	; 0x2360 <USER_Control_Leds+0x324>
    2330:	9a 81       	ldd	r25, Y+2	; 0x02
    2332:	92 33       	cpi	r25, 0x32	; 50
    2334:	a9 f4       	brne	.+42     	; 0x2360 <USER_Control_Leds+0x324>
    2336:	40 e0       	ldi	r20, 0x00	; 0
    2338:	62 e0       	ldi	r22, 0x02	; 2
    233a:	82 e0       	ldi	r24, 0x02	; 2
    233c:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    2340:	8e e2       	ldi	r24, 0x2E	; 46
    2342:	97 e0       	ldi	r25, 0x07	; 7
    2344:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2348:	2f ef       	ldi	r18, 0xFF	; 255
    234a:	87 ea       	ldi	r24, 0xA7	; 167
    234c:	91 e6       	ldi	r25, 0x61	; 97
    234e:	21 50       	subi	r18, 0x01	; 1
    2350:	80 40       	sbci	r24, 0x00	; 0
    2352:	90 40       	sbci	r25, 0x00	; 0
    2354:	e1 f7       	brne	.-8      	; 0x234e <USER_Control_Leds+0x312>
    2356:	00 c0       	rjmp	.+0      	; 0x2358 <USER_Control_Leds+0x31c>
    2358:	00 00       	nop
    235a:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    235e:	35 c0       	rjmp	.+106    	; 0x23ca <USER_Control_Leds+0x38e>
    2360:	82 33       	cpi	r24, 0x32	; 50
    2362:	c1 f4       	brne	.+48     	; 0x2394 <USER_Control_Leds+0x358>
    2364:	9a 81       	ldd	r25, Y+2	; 0x02
    2366:	92 33       	cpi	r25, 0x32	; 50
    2368:	a9 f4       	brne	.+42     	; 0x2394 <USER_Control_Leds+0x358>
    236a:	40 e0       	ldi	r20, 0x00	; 0
    236c:	67 e0       	ldi	r22, 0x07	; 7
    236e:	82 e0       	ldi	r24, 0x02	; 2
    2370:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    2374:	8e e2       	ldi	r24, 0x2E	; 46
    2376:	97 e0       	ldi	r25, 0x07	; 7
    2378:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    237c:	2f ef       	ldi	r18, 0xFF	; 255
    237e:	87 ea       	ldi	r24, 0xA7	; 167
    2380:	91 e6       	ldi	r25, 0x61	; 97
    2382:	21 50       	subi	r18, 0x01	; 1
    2384:	80 40       	sbci	r24, 0x00	; 0
    2386:	90 40       	sbci	r25, 0x00	; 0
    2388:	e1 f7       	brne	.-8      	; 0x2382 <USER_Control_Leds+0x346>
    238a:	00 c0       	rjmp	.+0      	; 0x238c <USER_Control_Leds+0x350>
    238c:	00 00       	nop
    238e:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2392:	1b c0       	rjmp	.+54     	; 0x23ca <USER_Control_Leds+0x38e>
    2394:	86 33       	cpi	r24, 0x36	; 54
    2396:	c9 f4       	brne	.+50     	; 0x23ca <USER_Control_Leds+0x38e>
    2398:	8a 81       	ldd	r24, Y+2	; 0x02
    239a:	82 33       	cpi	r24, 0x32	; 50
    239c:	b1 f4       	brne	.+44     	; 0x23ca <USER_Control_Leds+0x38e>
    239e:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <TMR_Timer2Stop>
    23a2:	40 e0       	ldi	r20, 0x00	; 0
    23a4:	67 e0       	ldi	r22, 0x07	; 7
    23a6:	83 e0       	ldi	r24, 0x03	; 3
    23a8:	0e 94 45 01 	call	0x28a	; 0x28a <DIO_SetPinValue>
    23ac:	8e e2       	ldi	r24, 0x2E	; 46
    23ae:	97 e0       	ldi	r25, 0x07	; 7
    23b0:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    23b4:	2f ef       	ldi	r18, 0xFF	; 255
    23b6:	87 ea       	ldi	r24, 0xA7	; 167
    23b8:	91 e6       	ldi	r25, 0x61	; 97
    23ba:	21 50       	subi	r18, 0x01	; 1
    23bc:	80 40       	sbci	r24, 0x00	; 0
    23be:	90 40       	sbci	r25, 0x00	; 0
    23c0:	e1 f7       	brne	.-8      	; 0x23ba <USER_Control_Leds+0x37e>
    23c2:	00 c0       	rjmp	.+0      	; 0x23c4 <USER_Control_Leds+0x388>
    23c4:	00 00       	nop
    23c6:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    23ca:	0f 90       	pop	r0
    23cc:	0f 90       	pop	r0
    23ce:	0f 90       	pop	r0
    23d0:	df 91       	pop	r29
    23d2:	cf 91       	pop	r28
    23d4:	08 95       	ret

000023d6 <USER_LOGOUT>:
    23d6:	8b e6       	ldi	r24, 0x6B	; 107
    23d8:	97 e0       	ldi	r25, 0x07	; 7
    23da:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    23de:	2f ef       	ldi	r18, 0xFF	; 255
    23e0:	87 ea       	ldi	r24, 0xA7	; 167
    23e2:	91 e6       	ldi	r25, 0x61	; 97
    23e4:	21 50       	subi	r18, 0x01	; 1
    23e6:	80 40       	sbci	r24, 0x00	; 0
    23e8:	90 40       	sbci	r25, 0x00	; 0
    23ea:	e1 f7       	brne	.-8      	; 0x23e4 <USER_LOGOUT+0xe>
    23ec:	00 c0       	rjmp	.+0      	; 0x23ee <USER_LOGOUT+0x18>
    23ee:	00 00       	nop
    23f0:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    23f4:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <user_exist>
    23f8:	08 95       	ret

000023fa <USER_PROGRAM>:
    23fa:	cf 93       	push	r28
    23fc:	df 93       	push	r29
    23fe:	1f 92       	push	r1
    2400:	cd b7       	in	r28, 0x3d	; 61
    2402:	de b7       	in	r29, 0x3e	; 62
    2404:	8f ef       	ldi	r24, 0xFF	; 255
    2406:	89 83       	std	Y+1, r24	; 0x01
    2408:	85 e7       	ldi	r24, 0x75	; 117
    240a:	97 e0       	ldi	r25, 0x07	; 7
    240c:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    2410:	2f ef       	ldi	r18, 0xFF	; 255
    2412:	87 ea       	ldi	r24, 0xA7	; 167
    2414:	91 e6       	ldi	r25, 0x61	; 97
    2416:	21 50       	subi	r18, 0x01	; 1
    2418:	80 40       	sbci	r24, 0x00	; 0
    241a:	90 40       	sbci	r25, 0x00	; 0
    241c:	e1 f7       	brne	.-8      	; 0x2416 <USER_PROGRAM+0x1c>
    241e:	00 c0       	rjmp	.+0      	; 0x2420 <USER_PROGRAM+0x26>
    2420:	00 00       	nop
    2422:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2426:	85 e8       	ldi	r24, 0x85	; 133
    2428:	97 e0       	ldi	r25, 0x07	; 7
    242a:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    242e:	2f ef       	ldi	r18, 0xFF	; 255
    2430:	87 ea       	ldi	r24, 0xA7	; 167
    2432:	91 e6       	ldi	r25, 0x61	; 97
    2434:	21 50       	subi	r18, 0x01	; 1
    2436:	80 40       	sbci	r24, 0x00	; 0
    2438:	90 40       	sbci	r25, 0x00	; 0
    243a:	e1 f7       	brne	.-8      	; 0x2434 <USER_PROGRAM+0x3a>
    243c:	00 c0       	rjmp	.+0      	; 0x243e <USER_PROGRAM+0x44>
    243e:	00 00       	nop
    2440:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2444:	84 e9       	ldi	r24, 0x94	; 148
    2446:	97 e0       	ldi	r25, 0x07	; 7
    2448:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    244c:	2f ef       	ldi	r18, 0xFF	; 255
    244e:	87 ea       	ldi	r24, 0xA7	; 167
    2450:	91 e6       	ldi	r25, 0x61	; 97
    2452:	21 50       	subi	r18, 0x01	; 1
    2454:	80 40       	sbci	r24, 0x00	; 0
    2456:	90 40       	sbci	r25, 0x00	; 0
    2458:	e1 f7       	brne	.-8      	; 0x2452 <USER_PROGRAM+0x58>
    245a:	00 c0       	rjmp	.+0      	; 0x245c <USER_PROGRAM+0x62>
    245c:	00 00       	nop
    245e:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2462:	8e e9       	ldi	r24, 0x9E	; 158
    2464:	97 e0       	ldi	r25, 0x07	; 7
    2466:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    246a:	2f ef       	ldi	r18, 0xFF	; 255
    246c:	87 ea       	ldi	r24, 0xA7	; 167
    246e:	91 e6       	ldi	r25, 0x61	; 97
    2470:	21 50       	subi	r18, 0x01	; 1
    2472:	80 40       	sbci	r24, 0x00	; 0
    2474:	90 40       	sbci	r25, 0x00	; 0
    2476:	e1 f7       	brne	.-8      	; 0x2470 <USER_PROGRAM+0x76>
    2478:	00 c0       	rjmp	.+0      	; 0x247a <USER_PROGRAM+0x80>
    247a:	00 00       	nop
    247c:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    2480:	89 81       	ldd	r24, Y+1	; 0x01
    2482:	8f 3f       	cpi	r24, 0xFF	; 255
    2484:	29 f4       	brne	.+10     	; 0x2490 <USER_PROGRAM+0x96>
    2486:	ce 01       	movw	r24, r28
    2488:	01 96       	adiw	r24, 0x01	; 1
    248a:	0e 94 89 09 	call	0x1312	; 0x1312 <KPD_GetValue>
    248e:	f8 cf       	rjmp	.-16     	; 0x2480 <USER_PROGRAM+0x86>
    2490:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <LCD_WriteChar4Bit>
    2494:	2f ef       	ldi	r18, 0xFF	; 255
    2496:	83 ed       	ldi	r24, 0xD3	; 211
    2498:	90 e3       	ldi	r25, 0x30	; 48
    249a:	21 50       	subi	r18, 0x01	; 1
    249c:	80 40       	sbci	r24, 0x00	; 0
    249e:	90 40       	sbci	r25, 0x00	; 0
    24a0:	e1 f7       	brne	.-8      	; 0x249a <USER_PROGRAM+0xa0>
    24a2:	00 c0       	rjmp	.+0      	; 0x24a4 <USER_PROGRAM+0xaa>
    24a4:	00 00       	nop
    24a6:	0e 94 c1 0a 	call	0x1582	; 0x1582 <LCD_ClearDisplay>
    24aa:	89 81       	ldd	r24, Y+1	; 0x01
    24ac:	81 33       	cpi	r24, 0x31	; 49
    24ae:	19 f0       	breq	.+6      	; 0x24b6 <USER_PROGRAM+0xbc>
    24b0:	82 33       	cpi	r24, 0x32	; 50
    24b2:	19 f1       	breq	.+70     	; 0x24fa <USER_PROGRAM+0x100>
    24b4:	26 c0       	rjmp	.+76     	; 0x2502 <USER_PROGRAM+0x108>
    24b6:	0e 94 9c 04 	call	0x938	; 0x938 <HC05_AdminLoginCheck>
    24ba:	87 30       	cpi	r24, 0x07	; 7
    24bc:	79 f4       	brne	.+30     	; 0x24dc <USER_PROGRAM+0xe2>
    24be:	89 ea       	ldi	r24, 0xA9	; 169
    24c0:	97 e0       	ldi	r25, 0x07	; 7
    24c2:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    24c6:	88 ed       	ldi	r24, 0xD8	; 216
    24c8:	97 e0       	ldi	r25, 0x07	; 7
    24ca:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <UART_TxString>
    24ce:	0e 94 12 09 	call	0x1224	; 0x1224 <HC05_ScreenChangeToAdminResponse>
    24d2:	0e 94 01 09 	call	0x1202	; 0x1202 <HC05_AdminApproval>
    24d6:	83 30       	cpi	r24, 0x03	; 3
    24d8:	e1 f3       	breq	.-8      	; 0x24d2 <USER_PROGRAM+0xd8>
    24da:	01 c0       	rjmp	.+2      	; 0x24de <USER_PROGRAM+0xe4>
    24dc:	80 e0       	ldi	r24, 0x00	; 0
    24de:	81 30       	cpi	r24, 0x01	; 1
    24e0:	21 f4       	brne	.+8      	; 0x24ea <USER_PROGRAM+0xf0>
    24e2:	0e 94 1e 10 	call	0x203c	; 0x203c <USER_Control_Leds>
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	0f c0       	rjmp	.+30     	; 0x2508 <USER_PROGRAM+0x10e>
    24ea:	82 30       	cpi	r24, 0x02	; 2
    24ec:	61 f4       	brne	.+24     	; 0x2506 <USER_PROGRAM+0x10c>
    24ee:	8d ee       	ldi	r24, 0xED	; 237
    24f0:	97 e0       	ldi	r25, 0x07	; 7
    24f2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_WriteString>
    24f6:	81 e0       	ldi	r24, 0x01	; 1
    24f8:	07 c0       	rjmp	.+14     	; 0x2508 <USER_PROGRAM+0x10e>
    24fa:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <USER_LOGOUT>
    24fe:	80 e0       	ldi	r24, 0x00	; 0
    2500:	03 c0       	rjmp	.+6      	; 0x2508 <USER_PROGRAM+0x10e>
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	01 c0       	rjmp	.+2      	; 0x2508 <USER_PROGRAM+0x10e>
    2506:	81 e0       	ldi	r24, 0x01	; 1
    2508:	0f 90       	pop	r0
    250a:	df 91       	pop	r29
    250c:	cf 91       	pop	r28
    250e:	08 95       	ret

00002510 <USER_APP>:

///////////////////////////////////////*************************///////////////////////////////


void USER_APP(void)
{
    2510:	cf 93       	push	r28
	u8 check1 = 0 ;
	u8 check2 = 0 ;
	check1 = USER_LOGIN();
    2512:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <USER_LOGIN>
	if(check1==1)
    2516:	81 30       	cpi	r24, 0x01	; 1
    2518:	39 f4       	brne	.+14     	; 0x2528 <USER_APP+0x18>
	{
		while(1)
		{
			check2 = USER_PROGRAM();
    251a:	0e 94 fd 11 	call	0x23fa	; 0x23fa <USER_PROGRAM>
    251e:	c8 2f       	mov	r28, r24
			AC_Auto();
    2520:	0e 94 94 00 	call	0x128	; 0x128 <AC_Auto>
			if(check2==0)
    2524:	c1 11       	cpse	r28, r1
    2526:	f9 cf       	rjmp	.-14     	; 0x251a <USER_APP+0xa>
		}
	}
	else
	{
	}
    2528:	cf 91       	pop	r28
    252a:	08 95       	ret

0000252c <__udivmodsi4>:
    252c:	a1 e2       	ldi	r26, 0x21	; 33
    252e:	1a 2e       	mov	r1, r26
    2530:	aa 1b       	sub	r26, r26
    2532:	bb 1b       	sub	r27, r27
    2534:	fd 01       	movw	r30, r26
    2536:	0d c0       	rjmp	.+26     	; 0x2552 <__udivmodsi4_ep>

00002538 <__udivmodsi4_loop>:
    2538:	aa 1f       	adc	r26, r26
    253a:	bb 1f       	adc	r27, r27
    253c:	ee 1f       	adc	r30, r30
    253e:	ff 1f       	adc	r31, r31
    2540:	a2 17       	cp	r26, r18
    2542:	b3 07       	cpc	r27, r19
    2544:	e4 07       	cpc	r30, r20
    2546:	f5 07       	cpc	r31, r21
    2548:	20 f0       	brcs	.+8      	; 0x2552 <__udivmodsi4_ep>
    254a:	a2 1b       	sub	r26, r18
    254c:	b3 0b       	sbc	r27, r19
    254e:	e4 0b       	sbc	r30, r20
    2550:	f5 0b       	sbc	r31, r21

00002552 <__udivmodsi4_ep>:
    2552:	66 1f       	adc	r22, r22
    2554:	77 1f       	adc	r23, r23
    2556:	88 1f       	adc	r24, r24
    2558:	99 1f       	adc	r25, r25
    255a:	1a 94       	dec	r1
    255c:	69 f7       	brne	.-38     	; 0x2538 <__udivmodsi4_loop>
    255e:	60 95       	com	r22
    2560:	70 95       	com	r23
    2562:	80 95       	com	r24
    2564:	90 95       	com	r25
    2566:	9b 01       	movw	r18, r22
    2568:	ac 01       	movw	r20, r24
    256a:	bd 01       	movw	r22, r26
    256c:	cf 01       	movw	r24, r30
    256e:	08 95       	ret

00002570 <__tablejump2__>:
    2570:	ee 0f       	add	r30, r30
    2572:	ff 1f       	adc	r31, r31
    2574:	05 90       	lpm	r0, Z+
    2576:	f4 91       	lpm	r31, Z
    2578:	e0 2d       	mov	r30, r0
    257a:	09 94       	ijmp

0000257c <__umulhisi3>:
    257c:	a2 9f       	mul	r26, r18
    257e:	b0 01       	movw	r22, r0
    2580:	b3 9f       	mul	r27, r19
    2582:	c0 01       	movw	r24, r0
    2584:	a3 9f       	mul	r26, r19
    2586:	70 0d       	add	r23, r0
    2588:	81 1d       	adc	r24, r1
    258a:	11 24       	eor	r1, r1
    258c:	91 1d       	adc	r25, r1
    258e:	b2 9f       	mul	r27, r18
    2590:	70 0d       	add	r23, r0
    2592:	81 1d       	adc	r24, r1
    2594:	11 24       	eor	r1, r1
    2596:	91 1d       	adc	r25, r1
    2598:	08 95       	ret

0000259a <_exit>:
    259a:	f8 94       	cli

0000259c <__stop_program>:
    259c:	ff cf       	rjmp	.-2      	; 0x259c <__stop_program>
